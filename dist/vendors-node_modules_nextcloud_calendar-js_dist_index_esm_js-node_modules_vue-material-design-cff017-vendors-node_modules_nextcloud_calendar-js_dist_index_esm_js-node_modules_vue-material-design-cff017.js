(globalThis["webpackChunknextcloud"] = globalThis["webpackChunknextcloud"] || []).push([["vendors-node_modules_nextcloud_calendar-js_dist_index_esm_js-node_modules_vue-material-design-cff017"],{

/***/ "./node_modules/@nextcloud/calendar-js/dist/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@nextcloud/calendar-js/dist/index.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractComponent: () => (/* binding */ AbstractComponent),
/* harmony export */   AbstractParser: () => (/* binding */ AbstractParser),
/* harmony export */   AbstractRecurringComponent: () => (/* binding */ AbstractRecurringComponent),
/* harmony export */   AbstractValue: () => (/* binding */ AbstractValue),
/* harmony export */   AlarmComponent: () => (/* binding */ AlarmComponent),
/* harmony export */   AttachmentProperty: () => (/* binding */ AttachmentProperty),
/* harmony export */   AttendeeProperty: () => (/* binding */ AttendeeProperty),
/* harmony export */   BinaryValue: () => (/* binding */ BinaryValue),
/* harmony export */   CalendarComponent: () => (/* binding */ CalendarComponent),
/* harmony export */   ConferenceProperty: () => (/* binding */ ConferenceProperty),
/* harmony export */   DateTimeValue: () => (/* binding */ DateTimeValue),
/* harmony export */   DurationValue: () => (/* binding */ DurationValue),
/* harmony export */   EventComponent: () => (/* binding */ EventComponent),
/* harmony export */   ExpectedICalJSError: () => (/* binding */ ExpectedICalJSError),
/* harmony export */   FreeBusyComponent: () => (/* binding */ FreeBusyComponent),
/* harmony export */   FreeBusyProperty: () => (/* binding */ FreeBusyProperty),
/* harmony export */   GeoProperty: () => (/* binding */ GeoProperty),
/* harmony export */   ICalendarParser: () => (/* binding */ ICalendarParser),
/* harmony export */   IllegalValueError: () => (/* binding */ IllegalValueError),
/* harmony export */   ImageProperty: () => (/* binding */ ImageProperty),
/* harmony export */   JournalComponent: () => (/* binding */ JournalComponent),
/* harmony export */   ModificationNotAllowedError: () => (/* binding */ ModificationNotAllowedError),
/* harmony export */   Parameter: () => (/* binding */ Parameter),
/* harmony export */   ParserManager: () => (/* binding */ ParserManager),
/* harmony export */   PeriodValue: () => (/* binding */ PeriodValue),
/* harmony export */   Property: () => (/* binding */ Property),
/* harmony export */   RecurValue: () => (/* binding */ RecurValue),
/* harmony export */   RecurrenceManager: () => (/* binding */ RecurrenceManager),
/* harmony export */   RecurringWithoutDtStartError: () => (/* binding */ RecurringWithoutDtStartError),
/* harmony export */   RelationProperty: () => (/* binding */ RelationProperty),
/* harmony export */   RequestStatusProperty: () => (/* binding */ RequestStatusProperty),
/* harmony export */   TextProperty: () => (/* binding */ TextProperty),
/* harmony export */   Timezone: () => (/* binding */ Timezone),
/* harmony export */   TimezoneAdapter: () => (/* binding */ TimezoneAdapter),
/* harmony export */   TimezoneComponent: () => (/* binding */ TimezoneComponent),
/* harmony export */   TimezoneManager: () => (/* binding */ TimezoneManager),
/* harmony export */   ToDoComponent: () => (/* binding */ ToDoComponent),
/* harmony export */   TriggerProperty: () => (/* binding */ TriggerProperty),
/* harmony export */   UTCOffsetValue: () => (/* binding */ UTCOffsetValue),
/* harmony export */   UnknownICALTypeError: () => (/* binding */ UnknownICALTypeError),
/* harmony export */   createEvent: () => (/* binding */ createEvent),
/* harmony export */   createFreeBusyRequest: () => (/* binding */ createFreeBusyRequest),
/* harmony export */   getConstructorForICALType: () => (/* binding */ getConstructorForICALType),
/* harmony export */   getConstructorForPropertyName: () => (/* binding */ getConstructorForPropertyName),
/* harmony export */   getParserManager: () => (/* binding */ getParserManager),
/* harmony export */   getReadableTimezoneName: () => (/* binding */ getReadableTimezoneName),
/* harmony export */   getSortedTimezoneList: () => (/* binding */ getSortedTimezoneList),
/* harmony export */   getTimezoneManager: () => (/* binding */ getTimezoneManager),
/* harmony export */   isOlsonTimezone: () => (/* binding */ isOlsonTimezone),
/* harmony export */   parseICSAndGetAllOccurrencesBetween: () => (/* binding */ parseICSAndGetAllOccurrencesBetween),
/* harmony export */   setConfig: () => (/* binding */ setConfig)
/* harmony export */ });
/* harmony import */ var ical_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ical.js */ "./node_modules/ical.js/build/ical.js");
/* harmony import */ var ical_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ical_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");



/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractParser
 * @classdesc
 */
class AbstractParser {
  /**
   * @class
   *
   * @param {object=} options Object of options
   * @param {boolean=} options.extractGlobalProperties Whether or not to preserve properties from the VCALENDAR component (defaults to false)
   * @param {boolean=} options.removeRSVPForAttendees Whether or not to remove RSVP from attendees (defaults to false)
   * @param {boolean=} options.includeTimezones Whether or not to include timezones (defaults to false)
   * @param {boolean=} options.preserveMethod Whether or not to preserve the iCalendar method (defaults to false)
   * @param {boolean=} options.processFreeBusy Whether or not to process VFreeBusy components (defaults to false)
   */
  constructor(options = {}) {
    if (new.target === AbstractParser) {
      throw new TypeError('Cannot instantiate abstract class AbstractParser');
    }

    /**
     * Options for the parser
     *
     * @type {{removeRSVPForAttendees: boolean}}
     * @private
     */
    this._options = Object.assign({}, options);

    /**
     * A name extracted from the calendar-data
     *
     * @type {string | null}
     * @protected
     */
    this._name = null;

    /**
     * A color extracted from the calendar-data
     *
     * @type {string | null}
     * @protected
     */
    this._color = null;

    /**
     * Gets the url that this icalendar file can be updated from
     *
     * @type {string}
     * @protected
     */
    this._sourceURL = null;

    /**
     * Gets the update interval if this icalendar file can be updated from a source
     *
     * @type {string}
     * @protected
     */
    this._refreshInterval = null;

    /**
     * Gets the default timezone of this calendar
     *
     * @type {string}
     * @protected
     */
    this._calendarTimezone = null;

    /**
     * Error count during parsing
     *
     * @type {Array}
     * @protected
     */
    this._errors = [];
  }

  /**
   * Gets the name extracted from the calendar-data
   *
   * @return {string | null}
   */
  getName() {
    return this._name;
  }

  /**
   * Gets the color extracted from the calendar-data
   *
   * @return {string | null}
   */
  getColor() {
    return this._color;
  }

  /**
   * Gets whether this import can be converted into a webcal subscription
   *
   * @return {boolean}
   */
  offersWebcalFeed() {
    return this._sourceURL !== null;
  }

  /**
   * Gets the url pointing to the webcal source
   *
   * @return {string | null}
   */
  getSourceURL() {
    return this._sourceURL;
  }

  /**
   * Gets the recommended refresh rate to update this subscription
   *
   * @return {string | null}
   */
  getRefreshInterval() {
    return this._refreshInterval;
  }

  /**
   * Gets the default timezone of this calendar
   *
   * @return {string}
   */
  getCalendarTimezone() {
    return this._calendarTimezone;
  }

  /**
   * {String|Object} data
   *
   * @param {any} data The data to parse
   * @throws TypeError
   */
  parse(data) {
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * Returns one CalendarComponent at a time
   */
  *getItemIterator() {
    // eslint-disable-line require-yield
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * Get an array of all items
   *
   * @return {CalendarComponent[]}
   */
  getAllItems() {
    return Array.from(this.getItemIterator());
  }

  /**
   * Returns a boolean whether or not the parsed data contains vevents
   *
   * @return {boolean}
   */
  containsVEvents() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vjournals
   *
   * @return {boolean}
   */
  containsVJournals() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vtodos
   *
   * @return {boolean}
   */
  containsVTodos() {
    return false;
  }

  /**
   * Returns a boolean whether or not the parsed data contains vfreebusys
   *
   * @return {boolean}
   */
  containsVFreeBusy() {
    return false;
  }

  /**
   * Returns a boolean whether
   *
   * @return {boolean}
   */
  hasErrors() {
    return this._errors.length !== 0;
  }

  /**
   * Get a list of all errors that occurred
   *
   * @return {*[]}
   */
  getErrorList() {
    return this._errors.slice();
  }

  /**
   * Returns the number of calendar-objects in parser
   *
   * @return {number}
   */
  getItemCount() {
    return 0;
  }

  /**
   * Gets an option provided
   *
   * @param {string} name The name of the option to get
   * @param {*} defaultValue The default value to return if option not provided
   * @return {any}
   * @protected
   */
  _getOption(name, defaultValue) {
    return Object.prototype.hasOwnProperty.call(this._options, name) ? this._options[name] : defaultValue;
  }

  /**
   * Return list of supported mime types
   *
   * @static
   */
  static getMimeTypes() {
    throw new TypeError('Abstract method not implemented by subclass');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class ModificationNotAllowedError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param baseClass
 */
function lockableTrait(baseClass) {
  /**
   * @class LockableTrait
   */
  return class extends baseClass {
    /**
     * Constructor
     *
     * @param {...any} args
     */
    constructor(...args) {
      super(...args);

      /**
       * Indicator whether this value was locked for changes
       *
       * @type {boolean}
       * @private
       */
      this._mutable = true;
    }

    /**
     * Returns whether or not this object is locked
     *
     * @return {boolean}
     */
    isLocked() {
      return !this._mutable;
    }

    /**
     * Marks this object is immutable
     * locks it against further modification
     */
    lock() {
      this._mutable = false;
    }

    /**
     * Marks this object as mutable
     * allowing further modification
     */
    unlock() {
      this._mutable = true;
    }

    /**
     * Check if modifications are allowed
     *
     * @throws {ModificationNotAllowedError} if this object is locked for modification
     * @protected
     */
    _modify() {
      if (!this._mutable) {
        throw new ModificationNotAllowedError();
      }
    }

    /**
     * Check if modification of content is allowed
     *
     * @throws {ModificationNotAllowedError} if this object is locked for modification
     * @protected
     */
    _modifyContent() {
      this._modify();
    }
  };
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class ExpectedICalJSError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Turns the entire string lowercase
 *
 * @param {string} str The string to turn lowercase
 * @return {string}
 */
function lc(str) {
  return str.toLowerCase();
}

/**
 * Turns the entire string uppercase
 *
 * @param {string} str The string to turn uppercase
 * @return {string}
 */
function uc(str) {
  return str.toUpperCase();
}

/**
 * Capitalizes the string
 *
 * @param {string} str The string of which the first character will be turned uppercase
 * @return {string}
 */
function ucFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Makes sure that a string starts with a certain other string
 * This is mostly used in the attendeeProperty to assure the uri starts with mailto:
 *
 * @param {string} str The string to check for the prefix and prepend if necessary
 * @param {string} startWith The prefix to be added if necessary
 * @return {string}
 */
function startStringWith(str, startWith) {
  if (!str.startsWith(startWith)) {
    str = startWith + str;
  }
  return str;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @type {Map<string, *>}
 */
const GLOBAL_CONFIG = new Map();

/**
 * Sets a new config key
 *
 * @param {string} key The config-key to set
 * @param {*} value The value to set for given config-key
 */
function setConfig(key, value) {
  GLOBAL_CONFIG.set(key, value);
}

/**
 * gets value of a config key
 *
 * @param {string} key The config-key to get
 * @param {*} defaultValue Default value of config does not exist
 * @return {*}
 */
function getConfig(key, defaultValue) {
  return GLOBAL_CONFIG.get(key) || defaultValue;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * creates a new ICAL.Component object
 *
 * @param {string} componentName The name of the component to create
 * @return {ICAL.Component}
 */
function createComponent(componentName) {
  return new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Component)(lc(componentName));
}

/**
 * creates a new ICAL.Property object
 *
 * @param {string} propertyName The name of the property to create
 * @return {ICAL.Property}
 */
function createProperty(propertyName) {
  return new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Property)(lc(propertyName));
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param baseClass
 */
function observerTrait(baseClass) {
  /**
   * @class ObserverTrait
   */
  return class extends baseClass {
    /**
     * Constructor
     *
     * @param {...any} args
     */
    constructor(...args) {
      super(...args);

      /**
       * List of subscribers
       *
       * @type {Function[]}
       * @private
       */
      this._subscribers = [];
    }

    /**
     * Adds a new subscriber
     *
     * @param {Function} handler - Handler to be called when modification happens
     */
    subscribe(handler) {
      this._subscribers.push(handler);
    }

    /**
     * Removes a subscriber
     *
     * @param {Function} handler - Handler to be no longer called when modification happens
     */
    unsubscribe(handler) {
      const index = this._subscribers.indexOf(handler);
      if (index === -1) {
        return;
      }
      this._subscribers.splice(index, 1);
    }

    /**
     * Notify all subscribed handlers
     *
     * @param {...any} args
     * @protected
     */
    _notifySubscribers(...args) {
      for (const handler of this._subscribers) {
        handler(...args);
      }
    }
  };
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * @class Parameter
 * @classdesc This class represents a property parameters as defined in RFC 5545 Section 3.2
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.2
 * @url
 */
class Parameter extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name The name of the parameter
   * @param {string|Array|null} value The value of the parameter
   */
  constructor(name, value = null) {
    super();

    /**
     * Name of the parameter
     *
     * @type {string}
     * @private
     */
    this._name = uc(name);

    /**
     * Value of the parameter
     *
     * @type {string|Array|null}
     * @private
     */
    this._value = value;
  }

  /**
   * Get parameter name
   *
   * @readonly
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Get parameter value
   *
   * @return {string | Array}
   */
  get value() {
    return this._value;
  }

  /**
   * Set new parameter value
   *
   * @throws {ModificationNotAllowedError} if parameter is locked for modification
   * @param {string | Array} value The new value to set
   */
  set value(value) {
    this._modifyContent();
    this._value = value;
  }

  /**
   * Gets the first value of this parameter
   *
   * @return {string | null}
   */
  getFirstValue() {
    if (!this.isMultiValue()) {
      return this.value;
    } else {
      if (this.value.length > 0) {
        return this.value[0];
      }
    }
    return null;
  }

  /**
   * Gets an iterator for all values
   */
  *getValueIterator() {
    if (this.isMultiValue()) {
      yield* this.value.slice()[Symbol.iterator]();
    } else {
      yield this.value;
    }
  }

  /**
   * Returns whether or not the value is a multivalue
   *
   * @return {boolean}
   */
  isMultiValue() {
    return Array.isArray(this._value);
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {Parameter}
   */
  clone() {
    const parameter = new this.constructor(this._name);
    if (this.isMultiValue()) {
      // only copy array values, don't copy array reference
      parameter.value = this._value.slice();
    } else {
      parameter.value = this._value;
    }

    // cloned parameters are always mutable
    return parameter;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractValue
 * @classdesc BaseClass for all values
 */
class AbstractValue extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {ICAL.Binary|ICAL.Duration|ICAL.Period|ICAL.Recur|ICAL.Time|ICAL.UtcOffset} icalValue The ICAL.JS object to wrap
   */
  constructor(icalValue) {
    if (new.target === AbstractValue) {
      throw new TypeError('Cannot instantiate abstract class AbstractValue');
    }
    super();

    /**
     * Wrapped ICAL.js value
     *
     * @type {ICAL.Binary|ICAL.Duration|ICAL.Period|ICAL.Recur|ICAL.Time|ICAL.UtcOffset}
     */
    this._innerValue = icalValue;
  }

  /**
   * Gets wrapped ICAL.JS object
   *
   * @return {*}
   */
  toICALJs() {
    return this._innerValue;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class BinaryValue
 * @classdesc Wrapper for ICAL.Binary
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.1.3
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/binary.js
 */
class BinaryValue extends AbstractValue {
  /**
   * Sets the raw b64 encoded value
   *
   * @return {string}
   */
  get rawValue() {
    return this._innerValue.value;
  }

  /**
   * Gets the raw b64 encoded value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} value - The new raw value
   */
  set rawValue(value) {
    this._modifyContent();
    this._innerValue.value = value;
  }

  /**
   * Gets the decoded value
   *
   * @return {string}
   */
  get value() {
    return this._innerValue.decodeValue();
  }

  /**
   * Sets the decoded Value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param  {string} decodedValue - The new encoded value
   */
  set value(decodedValue) {
    this._modifyContent();
    this._innerValue.setEncodedValue(decodedValue);
  }

  /**
   * clones this value
   *
   * @return {BinaryValue}
   */
  clone() {
    return BinaryValue.fromRawValue(this._innerValue.value);
  }

  /**
   * Create a new BinaryValue object from an ICAL.Binary object
   *
   * @param {ICAL.Binary} icalValue - The ICAL.Binary object
   * @return {BinaryValue}
   */
  static fromICALJs(icalValue) {
    return new BinaryValue(icalValue);
  }

  /**
   * Create a new BinaryValue object from a raw b64 encoded value
   *
   * @param {string} rawValue - The raw value
   * @return {BinaryValue}
   */
  static fromRawValue(rawValue) {
    const icalBinary = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Binary)(rawValue);
    return BinaryValue.fromICALJs(icalBinary);
  }

  /**
   * Create a new BinaryValue object from decoded value
   *
   * @param {string} decodedValue - The encoded value
   * @return {BinaryValue}
   */
  static fromDecodedValue(decodedValue) {
    const icalBinary = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Binary)();
    icalBinary.setEncodedValue(decodedValue);
    return BinaryValue.fromICALJs(icalBinary);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class DurationValue
 * @classdesc Wrapper for ICAL.Duration
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.6
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/duration.js
 */
class DurationValue extends AbstractValue {
  /**
   * Gets the weeks of the stored duration-value
   *
   * @return {number}
   */
  get weeks() {
    return this._innerValue.weeks;
  }

  /**
   * Sets the weeks of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} weeks Amount of weeks
   */
  set weeks(weeks) {
    this._modifyContent();
    if (weeks < 0) {
      throw new TypeError('Weeks cannot be negative, use isNegative instead');
    }
    this._innerValue.weeks = weeks;
  }

  /**
   * Gets the days of the stored duration-value
   *
   * @return {number}
   */
  get days() {
    return this._innerValue.days;
  }

  /**
   * Sets the days of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} days Amount of days
   */
  set days(days) {
    this._modifyContent();
    if (days < 0) {
      throw new TypeError('Days cannot be negative, use isNegative instead');
    }
    this._innerValue.days = days;
  }

  /**
   * Gets the hours of the stored duration-value
   *
   * @return {number}
   */
  get hours() {
    return this._innerValue.hours;
  }

  /**
   * Sets the weeks of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} hours Amount of hours
   */
  set hours(hours) {
    this._modifyContent();
    if (hours < 0) {
      throw new TypeError('Hours cannot be negative, use isNegative instead');
    }
    this._innerValue.hours = hours;
  }

  /**
   * Gets the minutes of the stored duration-value
   *
   * @return {number}
   */
  get minutes() {
    return this._innerValue.minutes;
  }

  /**
   * Sets the minutes of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} minutes Amount of minutes
   */
  set minutes(minutes) {
    this._modifyContent();
    if (minutes < 0) {
      throw new TypeError('Minutes cannot be negative, use isNegative instead');
    }
    this._innerValue.minutes = minutes;
  }

  /**
   * Gets the seconds of the stored duration-value
   *
   * @return {number}
   */
  get seconds() {
    return this._innerValue.seconds;
  }

  /**
   * Sets the seconds of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if value is negative
   * @param {number} seconds Amount of seconds
   */
  set seconds(seconds) {
    this._modifyContent();
    if (seconds < 0) {
      throw new TypeError('Seconds cannot be negative, use isNegative instead');
    }
    this._innerValue.seconds = seconds;
  }

  /**
   * Gets the negative-indicator of the stored duration-value
   *
   * @return {boolean}
   */
  get isNegative() {
    return this._innerValue.isNegative;
  }

  /**
   * Gets the negative-indicator of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {boolean} isNegative Whether or not the duration is negative
   */
  set isNegative(isNegative) {
    this._modifyContent();
    this._innerValue.isNegative = !!isNegative;
  }

  /**
   * Gets the amount of total seconds of the stored duration-value
   *
   * @return {* | number}
   */
  get totalSeconds() {
    return this._innerValue.toSeconds();
  }

  /**
   * Sets the amount of total seconds of the stored duration-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} totalSeconds The total amounts of seconds to set
   */
  set totalSeconds(totalSeconds) {
    this._modifyContent();
    this._innerValue.fromSeconds(totalSeconds);
  }

  /**
   * Compares this duration to another one
   *
   * @param {DurationValue} otherDuration The duration to compare to
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(otherDuration) {
    return this._innerValue.compare(otherDuration.toICALJs());
  }

  /**
   * Adds the value of another duration to this one
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} otherDuration The duration to add
   */
  addDuration(otherDuration) {
    this._modifyContent();
    this.totalSeconds += otherDuration.totalSeconds;
    this._innerValue.normalize();
  }

  /**
   * Subtract the value of another duration from this one
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} otherDuration The duration to subtract
   */
  subtractDuration(otherDuration) {
    this._modifyContent();
    this.totalSeconds -= otherDuration.totalSeconds;
    this._innerValue.normalize();
  }

  /**
   * clones this value
   *
   * @return {DurationValue}
   */
  clone() {
    return DurationValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new DurationValue object from an ICAL.Duration object
   *
   * @param {ICAL.Duration} icalValue The ical.js duration value
   * @return {DurationValue}
   */
  static fromICALJs(icalValue) {
    return new DurationValue(icalValue);
  }

  /**
   * Create a new DurationValue object from a number of seconds
   *
   * @param {number} seconds Total amount of seconds
   * @return {DurationValue}
   */
  static fromSeconds(seconds) {
    const icalDuration = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Duration.fromSeconds(seconds);
    return new DurationValue(icalDuration);
  }

  /**
   * Create a new DurationValue object from data
   *
   * @param {object} data The destructuring object
   * @param {number=} data.weeks Number of weeks to set
   * @param {number=} data.days Number of days to set
   * @param {number=} data.hours Number of hours to set
   * @param {number=} data.minutes Number of minutes to set
   * @param {number=} data.seconds Number of seconds to set
   * @param {boolean=} data.isNegative Whether or not duration is negative
   * @return {DurationValue}
   */
  static fromData(data) {
    const icalDuration = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Duration.fromData(data);
    return new DurationValue(icalDuration);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class DateTimeValue
 * @classdesc Wrapper for ICAL.Time
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.4
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.5
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.12
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/time.js
 */
class DateTimeValue extends AbstractValue {
  /**
   * Gets the year of the stored date-time-value
   *
   * @return {number}
   */
  get year() {
    return this._innerValue.year;
  }

  /**
   * Sets the year of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} year Number of years to set
   */
  set year(year) {
    this._modifyContent();
    this._innerValue.year = year;
  }

  /**
   * Gets the month of the stored date-time-value
   *
   * @return {number}
   */
  get month() {
    return this._innerValue.month;
  }

  /**
   * Sets the month of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} month Number of months to set
   */
  set month(month) {
    this._modifyContent();
    if (month < 1 || month > 12) {
      throw new TypeError('Month out of range');
    }
    this._innerValue.month = month;
  }

  /**
   * Gets the day of the stored date-time-value
   *
   * @return {number}
   */
  get day() {
    return this._innerValue.day;
  }

  /**
   * Sets the day of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} day Number of days to set
   */
  set day(day) {
    this._modifyContent();
    if (day < 1 || day > 31) {
      throw new TypeError('Day out of range');
    }
    this._innerValue.day = day;
  }

  /**
   * Gets the hour of the stored date-time-value
   *
   * @return {number}
   */
  get hour() {
    return this._innerValue.hour;
  }

  /**
   * Sets the hour of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} hour Number of hours to set
   */
  set hour(hour) {
    this._modifyContent();
    if (hour < 0 || hour > 23) {
      throw new TypeError('Hour out of range');
    }
    this._innerValue.hour = hour;
  }

  /**
   * Gets the minute of the stored date-time-value
   *
   * @return {number}
   */
  get minute() {
    return this._innerValue.minute;
  }

  /**
   * Sets the minute of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} minute Number of minutes to set
   */
  set minute(minute) {
    this._modifyContent();
    if (minute < 0 || minute > 59) {
      throw new TypeError('Minute out of range');
    }
    this._innerValue.minute = minute;
  }

  /**
   * Gets the second of the stored date-time-value
   *
   * @return {number}
   */
  get second() {
    return this._innerValue.second;
  }

  /**
   * Sets the second of the stored date-time-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if out of range
   * @param {number} second Number of seconds to set
   */
  set second(second) {
    this._modifyContent();
    if (second < 0 || second > 59) {
      throw new TypeError('Second out of range');
    }
    this._innerValue.second = second;
  }

  /**
   * Gets the timezone of this date-time-value
   *
   * @return {string | null}
   */
  get timezoneId() {
    // If zone.tzid is set and it's not 'floating' nor 'UTC', then it's a proper
    // timezone that we also have a timezone id for
    if (this._innerValue.zone.tzid && this._innerValue.zone.tzid !== 'floating' && this._innerValue.zone.tzid === 'UTC') {
      return this._innerValue.zone.tzid;
    }

    // If there is a timezone set, but we didn't have a zone.tzid in the previous if,
    // this means that the tzid does not have a definition stored along it.
    // we will keep this information anyway to not lose it
    if (this._innerValue.timezone) {
      return this._innerValue.timezone;
    }

    // this is the case when it's floating / UTC
    return this._innerValue.zone.tzid || null;
  }

  /**
   * Gets whether this date-time-value is a date or date-time
   *
   * @return {boolean}
   */
  get isDate() {
    return this._innerValue.isDate;
  }

  /**
   * Sets whether this date-time-value is a date or date-time
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {boolean} isDate Whether this is a date or date-time value
   */
  set isDate(isDate) {
    this._modifyContent();
    this._innerValue.isDate = !!isDate;
    if (isDate) {
      this._innerValue.hour = 0;
      this._innerValue.minute = 0;
      this._innerValue.second = 0;
    }
  }

  /**
   * Gets the unix-time
   *
   * @return {number}
   */
  get unixTime() {
    return this._innerValue.toUnixTime();
  }

  /**
   * returns vanilla javascript date object
   *
   * @return {Date}
   */
  get jsDate() {
    return this._innerValue.toJSDate();
  }

  /**
   * Adds a duration to this date-time-value
   *
   * @param {DurationValue} duration The duration to ad
   */
  addDuration(duration) {
    this._innerValue.addDuration(duration.toICALJs());
  }

  /**
   * Subtract another date excluding timezones
   *
   * @param {DateTimeValue} other The date-time value to subtract
   * @return {DurationValue}
   */
  subtractDateWithoutTimezone(other) {
    const icalDuration = this._innerValue.subtractDate(other.toICALJs());
    return DurationValue.fromICALJs(icalDuration);
  }

  /**
   * Subtract another date, taking timezones into account
   *
   * @param {DateTimeValue} other The date-time value to subtract
   * @return {DurationValue}
   */
  subtractDateWithTimezone(other) {
    const icalDuration = this._innerValue.subtractDateTz(other.toICALJs());
    return DurationValue.fromICALJs(icalDuration);
  }

  /**
   * Compares this DateTimeValue object with another one
   *
   * @param {DateTimeValue} other The date-time to compare to
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    return this._innerValue.compare(other.toICALJs());
  }

  /**
   * Compares only the date part in a given timezone
   *
   * @param {DateTimeValue} other The date-time to compare to
   * @param {Timezone} timezone The timezone to compare in
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compareDateOnlyInGivenTimezone(other, timezone) {
    return this._innerValue.compareDateOnlyTz(other.toICALJs(), timezone.toICALTimezone());
  }

  /**
   * Returns a clone of this object which was converted to a different timezone
   *
   * @param {Timezone} timezone TimezoneId to convert to
   * @return {DateTimeValue}
   */
  getInTimezone(timezone) {
    const clonedICALTime = this._innerValue.convertToZone(timezone.toICALTimezone());
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * Get the inner ICAL.Timezone
   *
   * @return {ICAL.Timezone}
   * @package
   */
  getICALTimezone() {
    return this._innerValue.zone;
  }

  /**
   * Returns a clone of this object which was converted to a different timezone
   *
   * @param {ICAL.Timezone} timezone TimezoneId to convert to
   * @return {DateTimeValue}
   * @package
   */
  getInICALTimezone(timezone) {
    const clonedICALTime = this._innerValue.convertToZone(timezone);
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * Returns a clone of this object which was converted to UTC
   *
   * @return {DateTimeValue}
   */
  getInUTC() {
    const clonedICALTime = this._innerValue.convertToZone((ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone).utcTimezone);
    return DateTimeValue.fromICALJs(clonedICALTime);
  }

  /**
   * This silently replaces the inner timezone without converting the actual time
   *
   * @param {ICAL.Timezone} timezone The timezone to replace with
   * @package
   */
  silentlyReplaceTimezone(timezone) {
    this._modify();
    this._innerValue = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)({
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      isDate: this.isDate,
      timezone
    });
  }

  /**
   * Replaces the inner timezone without converting the actual time
   *
   * @param {Timezone} timezone The timezone to replace with
   */
  replaceTimezone(timezone) {
    this._modifyContent();
    this._innerValue = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time.fromData({
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      isDate: this.isDate
    }, timezone.toICALTimezone());
  }

  /**
   * Calculates the UTC offset of the date-time-value in its timezone
   *
   * @return {number}
   */
  utcOffset() {
    return this._innerValue.utcOffset();
  }

  /**
   * Check if this is an event with floating time
   *
   * @return {boolean}
   */
  isFloatingTime() {
    return this._innerValue.zone.tzid === 'floating';
  }

  /**
   * clones this value
   *
   * @return {DateTimeValue}
   */
  clone() {
    return DateTimeValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new DateTimeValue object from an ICAL.Time object
   *
   * @param {ICAL.Time} icalValue The ical.js Date value to initialise from
   * @return {DateTimeValue}
   */
  static fromICALJs(icalValue) {
    return new DateTimeValue(icalValue);
  }

  /**
   * Creates a new DateTimeValue object based on a vanilla javascript object
   *
   * @param {Date} jsDate The JavaScript date to initialise from
   * @param {boolean=} useUTC Whether or not to treat it as UTC
   * @return {DateTimeValue}
   */
  static fromJSDate(jsDate, useUTC = false) {
    const icalValue = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time.fromJSDate(jsDate, useUTC);
    return DateTimeValue.fromICALJs(icalValue);
  }

  /**
   * Creates a new DateTimeValue object based on simple parameters
   *
   * @param {object} data The destructuring object
   * @param {number=} data.year Amount of years to set
   * @param {number=} data.month Amount of month to set (1-based)
   * @param {number=} data.day Amount of days to set
   * @param {number=} data.hour Amount of hours to set
   * @param {number=} data.minute Amount of minutes to set
   * @param {number=} data.second Amount of seconds to set
   * @param {boolean=} data.isDate Whether this is a date or date-time
   * @param {Timezone=} timezone The timezone of the DateTimeValue
   * @return {DateTimeValue}
   */
  static fromData(data, timezone) {
    const icalValue = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time.fromData(data, timezone ? timezone.toICALTimezone() : undefined);
    return DateTimeValue.fromICALJs(icalValue);
  }
}
DateTimeValue.SUNDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).SUNDAY;
DateTimeValue.MONDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).MONDAY;
DateTimeValue.TUESDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).TUESDAY;
DateTimeValue.WEDNESDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).WEDNESDAY;
DateTimeValue.THURSDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).THURSDAY;
DateTimeValue.FRIDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).FRIDAY;
DateTimeValue.SATURDAY = (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time).SATURDAY;
DateTimeValue.DEFAULT_WEEK_START = DateTimeValue.MONDAY;

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class PeriodValue
 * @classdesc Wrapper for ICAL.Period
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.9
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/period.js
 */
class PeriodValue extends AbstractValue {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * DateTimeValue object for start
     *
     * @type {DateTimeValue}
     * @private
     */
    this._start = DateTimeValue.fromICALJs(this._innerValue.start);

    /**
     * DateTimeValue object for end
     *
     * @type {DateTimeValue|null}
     * @private
     */
    this._end = null;

    /**
     * DurationValue object for duration
     *
     * @type {DurationValue|null}
     * @private
     */
    this._duration = null;
  }

  /**
   * Gets the start of the period-value
   *
   * @return {DateTimeValue}
   */
  get start() {
    return this._start;
  }

  /**
   * Sets the start of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} start The start of the period
   */
  set start(start) {
    this._modifyContent();
    this._start = start;
    this._innerValue.start = start.toICALJs();
  }

  /**
   * Gets the end of the period-value
   *
   * @return {DateTimeValue}
   */
  get end() {
    if (!this._end) {
      if (this._duration) {
        this._duration.lock();
        this._duration = null;
      }
      this._innerValue.end = this._innerValue.getEnd();
      this._end = DateTimeValue.fromICALJs(this._innerValue.end);
      this._innerValue.duration = null;
      if (this.isLocked()) {
        this._end.lock();
      }
    }
    return this._end;
  }

  /**
   * Sets the end of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} end The end of the period
   */
  set end(end) {
    this._modifyContent();
    this._innerValue.duration = null;
    this._innerValue.end = end.toICALJs();
    this._end = end;
  }

  /**
   * Gets the duration of the period-value
   * The value is automatically locked.
   * If you want to edit the value, clone it and it as new duration
   *
   * @return {DurationValue}
   */
  get duration() {
    if (!this._duration) {
      if (this._end) {
        this._end.lock();
        this._end = null;
      }
      this._innerValue.duration = this._innerValue.getDuration();
      this._duration = DurationValue.fromICALJs(this._innerValue.duration);
      this._innerValue.end = null;
      if (this.isLocked()) {
        this._duration.lock();
      }
    }
    return this._duration;
  }

  /**
   * Sets the duration of the period-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DurationValue} duration The duration to set
   */
  set duration(duration) {
    this._modifyContent();
    this._innerValue.end = null;
    this._innerValue.duration = duration.toICALJs();
    this._duration = duration;
  }

  /**
   * @inheritDoc
   */
  lock() {
    super.lock();
    this.start.lock();
    if (this._end) {
      this._end.lock();
    }
    if (this._duration) {
      this._duration.lock();
    }
  }

  /**
   * @inheritDoc
   */
  unlock() {
    super.unlock();
    this.start.unlock();
    if (this._end) {
      this._end.unlock();
    }
    if (this._duration) {
      this._duration.unlock();
    }
  }

  /**
   * clones this value
   *
   * @return {PeriodValue}
   */
  clone() {
    return PeriodValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new PeriodValue object from a ICAL.Period object
   *
   * @param {ICAL.Period} icalValue The ical.js period value to initialise from
   * @return {PeriodValue}
   */
  static fromICALJs(icalValue) {
    return new PeriodValue(icalValue);
  }

  /**
   * Create a new PeriodValue object from start and end
   *
   * @param {object} data The destructuring object
   * @param {DateTimeValue} data.start The start of the period
   * @param {DateTimeValue} data.end The end of the period
   * @return {PeriodValue}
   */
  static fromDataWithEnd(data) {
    const icalPeriod = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Period.fromData({
      start: data.start.toICALJs(),
      end: data.end.toICALJs()
    });
    return PeriodValue.fromICALJs(icalPeriod);
  }

  /**
   * Create a new PeriodValue object from start and duration
   *
   * @param {object} data The destructuring object
   * @param {DateTimeValue} data.start The start of the period
   * @param {DurationValue} data.duration The duration of the period
   * @return {PeriodValue}
   */
  static fromDataWithDuration(data) {
    const icalPeriod = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Period.fromData({
      start: data.start.toICALJs(),
      duration: data.duration.toICALJs()
    });
    return PeriodValue.fromICALJs(icalPeriod);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
const ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];

/**
 * @class RecurValue
 * @classdesc Wrapper for ICAL.Recur
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.10
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/recur.js
 */
class RecurValue extends AbstractValue {
  /**
   * Constructor
   *
   * @param {ICAL.Recur} icalValue The ical.js rrule value
   * @param {DateTimeValue?} until The Until date
   */
  constructor(icalValue, until) {
    super(icalValue);

    /**
     * DateTimeValue object for Until
     *
     * @type {DateTimeValue}
     * @private
     */
    this._until = until;
  }

  /**
   * Gets the stored interval of this recurrence rule
   *
   * @return {number}
   */
  get interval() {
    return this._innerValue.interval;
  }

  /**
   * Sets the stored interval of this recurrence rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} interval New Interval to set
   */
  set interval(interval) {
    this._modifyContent();
    this._innerValue.interval = parseInt(interval, 10);
  }

  /**
   * Gets the weekstart used to calculate the recurrence expansion
   *
   * @return {number}
   */
  get weekStart() {
    return this._innerValue.wkst;
  }

  /**
   * Sets the weekstart used to calculate the recurrence expansion
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if weekstart out of range
   * @param {number} weekStart New start of week to set
   */
  set weekStart(weekStart) {
    this._modifyContent();
    if (weekStart < DateTimeValue.SUNDAY || weekStart > DateTimeValue.SATURDAY) {
      throw new TypeError('Weekstart out of range');
    }
    this._innerValue.wkst = weekStart;
  }

  /**
   * Gets the until value if set
   * The value is automatically locked.
   * If you want to edit the value, clone it and it as new until
   *
   * @return {null|DateTimeValue}
   */
  get until() {
    if (!this._until && this._innerValue.until) {
      this._until = DateTimeValue.fromICALJs(this._innerValue.until);
    }
    return this._until;
  }

  /**
   * Sets the until value, automatically removes count
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {DateTimeValue} until New until date to set
   */
  set until(until) {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
    }
    this._until = until;
    this._innerValue.count = null;
    this._innerValue.until = until.toICALJs();
  }

  /**
   * Gets the count value if set
   *
   * @return {null | number}
   */
  get count() {
    return this._innerValue.count;
  }

  /**
   * Sets the count value, automatically removes until
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} count New occurrence limit to set
   */
  set count(count) {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
      this._until = null;
    }
    this._innerValue.until = null;
    this._innerValue.count = parseInt(count, 10);
  }

  /**
   * Gets the frequency of the recurrence rule
   *
   * @return {string} see
   */
  get frequency() {
    return this._innerValue.freq;
  }

  /**
   * Sets the frequency of the recurrence rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if frequency is unknown
   * @param {string} freq New frequency to set
   */
  set frequency(freq) {
    this._modifyContent();
    if (!ALLOWED_FREQ.includes(freq)) {
      throw new TypeError('Unknown frequency');
    }
    this._innerValue.freq = freq;
  }

  /**
   * Modifies this recurrence-value to unset count and until
   */
  setToInfinite() {
    this._modifyContent();
    if (this._until) {
      this._until.lock();
      this._until = null;
    }
    this._innerValue.until = null;
    this._innerValue.count = null;
  }

  /**
   * Checks whether the stored rule is finite
   *
   * @return {boolean}
   */
  isFinite() {
    return this._innerValue.isFinite();
  }

  /**
   * Checks whether the recurrence rule is limited by count
   *
   * @return {boolean}
   */
  isByCount() {
    return this._innerValue.isByCount();
  }

  /**
   * Adds a part to a component to the recurrence-rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the recurrence-component to add
   * @param {string | number} value The value to add
   */
  addComponent(componentName, value) {
    this._modifyContent();
    this._innerValue.addComponent(componentName, value);
  }

  /**
   * Sets / overwrites a component to the recurrence-rule
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the component to set
   * @param {number[] | string[]} value The value to set
   */
  setComponent(componentName, value) {
    this._modifyContent();
    if (value.length === 0) {
      delete this._innerValue.parts[componentName.toUpperCase()];
    } else {
      this._innerValue.setComponent(componentName, value);
    }
  }

  /**
   * Removes all parts of a component
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {string} componentName The name of the component to remove
   */
  removeComponent(componentName) {
    delete this._innerValue.parts[uc(componentName)];
  }

  /**
   * Gets all parts of a component
   *
   * @param {string} componentName The name of the component to get
   * @return {Array}
   */
  getComponent(componentName) {
    return this._innerValue.getComponent(componentName);
  }

  /**
   * Checks if this recurrence rule is valid according to RFC 5545
   *
   * @return {boolean}
   */
  isRuleValid() {
    return true;
  }

  /**
   * @inheritDoc
   */
  lock() {
    super.lock();
    if (this._until) {
      this._until.lock();
    }
  }

  /**
   * @inheritDoc
   */
  unlock() {
    super.unlock();
    if (this._until) {
      this._until.unlock();
    }
  }

  /**
   * clones this value
   *
   * @return {RecurValue}
   */
  clone() {
    return RecurValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new RecurValue object from a ICAL.Recur object
   *
   * @param {ICAL.Recur} icalValue The ICAL.JS Recur value
   * @param {DateTimeValue?} until The Until date
   * @return {RecurValue}
   */
  static fromICALJs(icalValue, until = null) {
    return new RecurValue(icalValue, until);
  }

  /**
   * Create a new RecurValue object from a data object
   *
   * @param {object} data The destructuring object
   * @param {string=} data.freq FREQ part of RRULE
   * @param {number=} data.interval INTERVAL part of RRULE
   * @param {number=} data.wkst WEEKSTART part of RRULE
   * @param {DateTimeValue=} data.until UNTIL part of RRULE
   * @param {number=} data.count COUNT part of RRULE
   * @param {number[]=} data.bysecond BYSECOND part of RRULE
   * @param {number[]=} data.byminute BYMINUTE part of RRULE
   * @param {number[]=} data.byhour BYHOUR part of RRULE
   * @param {string[]=} data.byday BYDAY part of RRULE
   * @param {number[]=} data.bymonthday BYMONTHDAY part of RRULE
   * @param {number[]=} data.byyearday BYYEARDAY part of RRULE
   * @param {number[]=} data.byweekno BYWEEKNO part of RRULE
   * @param {number[]=} data.bymonth BYMONTH part of RRULE
   * @param {number[]=} data.bysetpos BYSETPOS part of RRULE
   * @return {RecurValue}
   */
  static fromData(data) {
    let until = null;
    if (data.until) {
      until = data.until;
      data.until = data.until.toICALJs();
    }
    const icalRecur = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Recur.fromData(data);
    return RecurValue.fromICALJs(icalRecur, until);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class UTCOffsetValue
 * @classdesc Wrapper for ICAL.UtcOffset
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.3.14
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/utc_offset.js
 */
class UTCOffsetValue extends AbstractValue {
  /**
   * Gets the hour part of the offset-value
   *
   * @return {number}
   */
  get hours() {
    return this._innerValue.hours;
  }

  /**
   * Sets the hour part of the offset-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} hours - New hours to set
   */
  set hours(hours) {
    this._modifyContent();
    this._innerValue.hours = hours;
  }

  /**
   * Gets the minute part of the offset-value
   *
   * @return {number}
   */
  get minutes() {
    return this._innerValue.minutes;
  }

  /**
   * Sets the minute part of the offset-value
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} minutes - New minutes to set
   */
  set minutes(minutes) {
    this._modifyContent();
    this._innerValue.minutes = minutes;
  }

  /**
   * Gets the factor
   *
   * @return {number}
   */
  get factor() {
    return this._innerValue.factor;
  }

  /**
   * Sets the factor
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @throws {TypeError} if factor is neither 1 nor -1
   * @param {number} factor - New factor to set, 1 for positive, -1 for negative
   */
  set factor(factor) {
    this._modifyContent();
    if (factor !== 1 && factor !== -1) {
      throw new TypeError('Factor may only be set to 1 or -1');
    }
    this._innerValue.factor = factor;
  }

  /**
   * Gets the total amount of seconds
   *
   * @return {number}
   */
  get totalSeconds() {
    return this._innerValue.toSeconds();
  }

  /**
   * Sets the total amount of seconds
   *
   * @throws {ModificationNotAllowedError} if value is locked for modification
   * @param {number} totalSeconds - New number of total seconds to set
   */
  set totalSeconds(totalSeconds) {
    this._modifyContent();
    this._innerValue.fromSeconds(totalSeconds);
  }

  /**
   * Compares this UTCOffset to another one
   *
   * @param {UTCOffsetValue} other - The other UTCOffsetValue to compare with
   * @return {number} -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    return this._innerValue.compare(other.toICALJs());
  }

  /**
   * Clones this value
   *
   * @return {UTCOffsetValue}
   */
  clone() {
    return UTCOffsetValue.fromICALJs(this._innerValue.clone());
  }

  /**
   * Create a new UTCOffsetValue object from a ICAL.UTCOffset object
   *
   * @param {ICAL.UtcOffset} icalValue - The ICAL.UtcOffset object to initialize this object from
   * @return {UTCOffsetValue}
   */
  static fromICALJs(icalValue) {
    return new UTCOffsetValue(icalValue);
  }

  /**
   * Create a new UTCOffsetValue object from a data object
   *
   * @param {object} data - Object with data to create UTCOffsetValue object from
   * @param {number=} data.hours - The number of hours to set
   * @param {number=} data.minutes - The number of minutes to set
   * @param {number=} data.factor - The factor to use, 1 for positive, -1 for negative
   * @return {UTCOffsetValue}
   */
  static fromData(data) {
    const icalUTCOffset = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().UtcOffset)();
    icalUTCOffset.fromData(data);
    return UTCOffsetValue.fromICALJs(icalUTCOffset);
  }

  /**
   * Create a new UTCOffsetValue object from an amount of seconds
   *w
   *
   * @param {number} seconds - The total number of seconds to create the UTCOffsetValue object from
   * @return {UTCOffsetValue}
   */
  static fromSeconds(seconds) {
    const icalUTCOffset = ical_js__WEBPACK_IMPORTED_MODULE_0___default().UtcOffset.fromSeconds(seconds);
    return UTCOffsetValue.fromICALJs(icalUTCOffset);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class UnknownICALTypeError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string} icaltype The icaltype to get a Value constructor for
 * @return {RecurValue|PeriodValue|BinaryValue|DurationValue|UTCOffsetValue|DateTimeValue}
 */
function getConstructorForICALType(icaltype) {
  switch (lc(icaltype)) {
    case 'binary':
      return BinaryValue;
    case 'date':
    case 'date-time':
      return DateTimeValue;
    case 'duration':
      return DurationValue;
    case 'period':
      return PeriodValue;
    case 'recur':
      return RecurValue;
    case 'utc-offset':
      return UTCOffsetValue;
    default:
      throw new UnknownICALTypeError();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class Property
 * @classdesc This class represents a property as defined in RFC 5545 Section 3.5
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.5
 * @url https://github.com/mozilla-comm/ical.js/blob/master/lib/ical/property.js
 */
class Property extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name The name of the property
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value of the property
   * @param {Parameter[] | [string][]} parameters Array of parameters
   * @param {CalendarComponent|null} root The root of the calendar-document
   * @param {AbstractComponent|null} parent The parent-element of this property
   */
  constructor(name, value = null, parameters = [], root = null, parent = null) {
    super();

    /**
     * Name of the property
     *
     * @type {string}
     * @protected
     */
    this._name = uc(name);

    /**
     * Value of the property
     *
     * @type {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
     * @protected
     */
    this._value = value;

    /**
     * List of parameters associated with this parameter
     *
     * @type {Map<string, Parameter>}
     */
    this._parameters = new Map();

    /**
     * Root node of ical document
     *
     * @type {CalendarComponent|null}
     * @protected
     */
    this._root = root;

    /**
     * Parent node
     *
     * @type {AbstractComponent|null}
     * @protected
     */
    this._parent = parent;
    this._setParametersFromConstructor(parameters);
    if (value instanceof AbstractValue) {
      value.subscribe(() => this._notifySubscribers());
    }
  }

  /**
   * Get property name
   *
   * @readonly
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Get parameter value
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   */
  get value() {
    return this._value;
  }

  /**
   * Set new parameter value
   *
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value of the property
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set value(value) {
    this._modifyContent();
    this._value = value;
    if (value instanceof AbstractValue) {
      value.subscribe(() => this._notifySubscribers());
    }
  }

  /**
   * Gets the root of this property
   *
   * @return {CalendarComponent|null}
   */
  get root() {
    return this._root;
  }

  /**
   * Sets the root of this property
   *
   * @param {CalendarComponent|null} root The root of the calendar-document
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set root(root) {
    this._modify();
    this._root = root;
  }

  /**
   * Gets the direct parent element of this property
   *
   * @return {AbstractComponent}
   */
  get parent() {
    return this._parent;
  }

  /**
   * Sets the direct parent element of this property
   *
   * @param {AbstractComponent|null} parent The parent element of this property
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  set parent(parent) {
    this._modify();
    this._parent = parent;
  }

  /**
   * Gets the first value of this property
   *
   * @return {null | string | number | AbstractValue}
   */
  getFirstValue() {
    if (!this.isMultiValue()) {
      return this.value;
    } else {
      if (this.value.length > 0) {
        return this.value[0];
      }
    }
    return null;
  }

  /**
   * Gets an iterator over all values
   */
  *getValueIterator() {
    if (this.isMultiValue()) {
      yield* this.value.slice()[Symbol.iterator]();
    } else {
      yield this.value;
    }
  }

  /**
   * Adds a value to the multi-value property
   *
   * @param {string | AbstractValue} value Value to add
   */
  addValue(value) {
    if (!this.isMultiValue()) {
      throw new TypeError('This is not a multivalue property');
    }
    this._modifyContent();
    this.value.push(value);
  }

  /**
   * Checks if a value is inside this multi-value property
   *
   * @param {string | AbstractValue} value Value to check for
   * @return {boolean}
   */
  hasValue(value) {
    if (!this.isMultiValue()) {
      throw new TypeError('This is not a multivalue property');
    }
    return this.value.includes(value);
  }

  /**
   * Removes a value from this multi-value property
   *
   * @param {string | AbstractValue} value Value to remove
   */
  removeValue(value) {
    if (!this.hasValue(value)) {
      return;
    }
    this._modifyContent();
    const index = this.value.indexOf(value);
    this.value.splice(index, 1);
  }

  /**
   * Sets a parameter on this property
   *
   * @param {Parameter} parameter The parameter to set
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  setParameter(parameter) {
    this._modify();
    this._parameters.set(parameter.name, parameter);
    parameter.subscribe(() => this._notifySubscribers());
  }

  /**
   * Gets a parameter on this property by its name
   *
   * @param {string} parameterName Name of the parameter to get
   * @return {Parameter}
   */
  getParameter(parameterName) {
    return this._parameters.get(uc(parameterName));
  }

  /**
   * Gets an iterator over all available parameters
   */
  *getParametersIterator() {
    yield* this._parameters.values();
  }

  /**
   * Get first value of a parameter
   *
   * @param {string} parameterName Name of the parameter
   * @return {null | string}
   */
  getParameterFirstValue(parameterName) {
    const parameter = this.getParameter(parameterName);
    if (parameter instanceof Parameter) {
      if (parameter.isMultiValue()) {
        return parameter.value[0];
      } else {
        return parameter.value;
      }
    }
    return null;
  }

  /**
   * Returns whether a parameter exists on this property
   *
   * @param {string} parameterName Name of the parameter
   * @return {boolean}
   */
  hasParameter(parameterName) {
    return this._parameters.has(uc(parameterName));
  }

  /**
   * Deletes a parameter on this property
   *
   * @param {string} parameterName Name of the parameter
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  deleteParameter(parameterName) {
    this._modify();
    this._parameters.delete(uc(parameterName));
  }

  /**
   * update a parameter if it exists,
   * create a new one if it doesn't
   *
   * @param {string} parameterName Name of the parameter
   * @param {string|Array|null} value Value to set
   * @throws {ModificationNotAllowedError} if property is locked for modification
   */
  updateParameterIfExist(parameterName, value) {
    this._modify();
    if (this.hasParameter(parameterName)) {
      const parameter = this.getParameter(parameterName);
      parameter.value = value;
    } else {
      const parameter = new Parameter(uc(parameterName), value);
      this.setParameter(parameter);
    }
  }

  /**
   * Returns whether or not the value is a multivalue
   *
   * @return {boolean}
   */
  isMultiValue() {
    return Array.isArray(this._value);
  }

  /**
   * Returns whether or not this valus is decorated
   *
   * @return {boolean}
   */
  isDecoratedValue() {
    if (this.isMultiValue()) {
      return this._value[0] instanceof AbstractValue;
    } else {
      return this._value instanceof AbstractValue;
    }
  }

  /**
   * Marks this parameter is immutable
   * locks it against further modification
   */
  lock() {
    super.lock();
    for (const parameter of this.getParametersIterator()) {
      parameter.lock();
    }
    if (this.isDecoratedValue()) {
      for (const value of this.getValueIterator()) {
        value.lock();
      }
    }
  }

  /**
   * Marks this parameter as mutable
   * allowing further modification
   */
  unlock() {
    super.unlock();
    for (const parameter of this.getParametersIterator()) {
      parameter.unlock();
    }
    if (this.isDecoratedValue()) {
      for (const value of this.getValueIterator()) {
        value.unlock();
      }
    }
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {Property}
   */
  clone() {
    const parameters = [];
    for (const parameter of this.getParametersIterator()) {
      parameters.push(parameter.clone());
    }
    return new this.constructor(this.name, this._cloneValue(), parameters, this.root, this.parent);
  }

  /**
   * Copies the values of this property
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   * @protected
   */
  _cloneValue() {
    if (this.isDecoratedValue()) {
      if (this.isMultiValue()) {
        return this._value.map(val => val.clone());
      } else {
        return this._value.clone();
      }
    } else {
      if (this.isMultiValue()) {
        // only copy array values, don't copy array reference
        return this._value.slice();
      } else {
        return this._value;
      }
    }
  }

  /**
   * Sets parameters from the constructor
   *
   * @param {Parameter[] | [string][]} parameters Array of parameters to set
   * @private
   */
  _setParametersFromConstructor(parameters) {
    parameters.forEach(parameter => {
      if (!(parameter instanceof Parameter)) {
        parameter = new Parameter(parameter[0], parameter[1]);
      }
      this.setParameter(parameter);
    });
  }

  /**
   * Creates a new Component based on an ical object
   *
   * @param {ICAL.Property} icalProperty The ical.js property to initialise from
   * @param {CalendarComponent=} root The root of the calendar-document
   * @param {AbstractComponent=} parent The parent element of this property
   * @return {Property}
   */
  static fromICALJs(icalProperty, root = null, parent = null) {
    if (!(icalProperty instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Property))) {
      throw new ExpectedICalJSError();
    }
    let value;
    if (icalProperty.isDecorated) {
      const constructor = getConstructorForICALType(icalProperty.getFirstValue().icaltype);
      if (icalProperty.isMultiValue) {
        value = icalProperty.getValues().map(val => constructor.fromICALJs(val));
      } else {
        value = constructor.fromICALJs(icalProperty.getFirstValue());
      }
    } else {
      if (icalProperty.isMultiValue) {
        value = icalProperty.getValues();
      } else {
        value = icalProperty.getFirstValue();
      }
    }
    const parameters = [];
    const paramNames = Object.keys(Object.assign({}, icalProperty.toJSON()[1]));
    paramNames.forEach(paramName => {
      // Timezone id is handled by DateTimeValue
      if (uc(paramName) === 'TZID') {
        return;
      }
      parameters.push([paramName, icalProperty.getParameter(paramName)]);
    });
    return new this(icalProperty.name, value, parameters, root, parent);
  }

  /**
   * Returns an ICAL.js property based on this Property
   *
   * @return {ICAL.Property}
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    if (this.isMultiValue()) {
      if (this.isDecoratedValue()) {
        icalProperty.setValues(this.value.map(val => val.toICALJs()));
      } else {
        icalProperty.setValues(this.value);
      }
    } else {
      if (this.isDecoratedValue()) {
        icalProperty.setValue(this.value.toICALJs());
      } else {
        icalProperty.setValue(this.value);
      }
    }
    for (const parameter of this.getParametersIterator()) {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    }
    const firstValue = this.getFirstValue();
    if (firstValue instanceof DateTimeValue && firstValue.timezoneId !== 'floating' && firstValue.timezoneId !== 'UTC' && !firstValue.isDate) {
      icalProperty.setParameter('tzid', firstValue.timezoneId);
    }
    return icalProperty;
  }

  /**
   * @inheritDoc
   */
  _modifyContent() {
    super._modifyContent();
    this._notifySubscribers();
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AttachmentProperty
 * @classdesc This class represents an attachment property as defined in RFC 5545 Section 3.8.1.1
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.1
 */
class AttachmentProperty extends Property {
  /**
   * Gets the format-type of this attachment
   *
   * @return {string}
   */
  get formatType() {
    return this.getParameterFirstValue('FMTTYPE');
  }

  /**
   * Sets the format-type of this attachment
   *
   * @param {string} fmtType Mime-type of attachment
   */
  set formatType(fmtType) {
    this.updateParameterIfExist('FMTTYPE', fmtType);
  }

  /**
   * Gets the uri of this attachment
   *
   * @return {string | null}
   */
  get uri() {
    if (this._value instanceof BinaryValue) {
      return null;
    }
    return this._value;
  }

  /**
   * Sets the uri of this attachment
   *
   * @param {string} uri Link to attachment if applicable
   */
  set uri(uri) {
    this.value = uri;
  }

  /**
   * Gets the encoding of this attachment
   *
   * @return {string|null}
   */
  get encoding() {
    if (this._value instanceof BinaryValue) {
      return 'BASE64';
    }
    return null;
  }

  /**
   * Gets the data stored in this attachment
   *
   * @return {string | null}
   */
  get data() {
    if (this._value instanceof BinaryValue) {
      return this._value.value;
    }
    return null;
  }

  /**
   * Sets the data stored in this attachment
   *
   * @param {string} data The data of the attachment
   */
  set data(data) {
    if (this.value instanceof BinaryValue) {
      this.value.value = data;
    } else {
      this.value = BinaryValue.fromDecodedValue(data);
    }
  }

  /**
   * @inheritDoc
   */
  toICALJs() {
    const icalProperty = super.toICALJs();
    if (this._value instanceof BinaryValue && this.getParameterFirstValue('ENCODING') !== 'BASE64') {
      icalProperty.setParameter('ENCODING', 'BASE64');
    }
    return icalProperty;
  }

  /**
   * Creates a new AttachmentProperty based on data
   *
   * @param {string} data The data of the attachment
   * @param {string=} formatType The mime-type of the data
   * @return {AttachmentProperty}
   */
  static fromData(data, formatType = null) {
    const binaryValue = BinaryValue.fromDecodedValue(data);
    const property = new AttachmentProperty('ATTACH', binaryValue);
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }

  /**
   * Creates a new AttachmentProperty based on a link
   *
   * @param {string} uri The URI for the attachment
   * @param {string=} formatType The mime-type of the uri
   * @return {AttachmentProperty}
   */
  static fromLink(uri, formatType = null) {
    const property = new AttachmentProperty('ATTACH', uri);
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AttendeeProperty
 * @classdesc This class represents an attendee property as defined in RFC 5545 Section 3.8.4.1
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 */
class AttendeeProperty extends Property {
  /**
   * Returns the role of the attendee.
   *
   * @return {string}
   */
  get role() {
    const allowed = ['CHAIR', 'REQ-PARTICIPANT', 'OPT-PARTICIPANT', 'NON-PARTICIPANT'];
    const defaultValue = 'REQ-PARTICIPANT';
    if (this.hasParameter('ROLE')) {
      const value = this.getParameterFirstValue('ROLE');
      if (allowed.includes(value)) {
        return value;
      }
    }
    return defaultValue;
  }

  /**
   * Sets new role of the attendee
   *
   * @param {string} role The role of the attendee (e.g. CHAIR, REQ-PARTICIPANT)
   */
  set role(role) {
    this.updateParameterIfExist('ROLE', role);
  }

  /**
   * Returns the calendar-user-type of an attendee
   *
   * @return {string}
   */
  get userType() {
    const allowed = ['INDIVIDUAL', 'GROUP', 'RESOURCE', 'ROOM', 'UNKNOWN'];
    if (!this.hasParameter('CUTYPE')) {
      return 'INDIVIDUAL';
    } else {
      const value = this.getParameterFirstValue('CUTYPE');
      if (allowed.includes(value)) {
        return value;
      }
      return 'UNKNOWN';
    }
  }

  /**
   * Sets new calendar-user-type of attendee
   *
   * @param {string} userType The type of user (e.g. INDIVIDUAL, GROUP)
   */
  set userType(userType) {
    this.updateParameterIfExist('CUTYPE', userType);
  }

  /**
   * Returns the "Répondez s'il vous plaît" value for attendee
   *
   * @return {boolean}
   */
  get rsvp() {
    if (!this.hasParameter('RSVP')) {
      return false;
    } else {
      const value = this.getParameterFirstValue('RSVP');
      return uc(value) === 'TRUE';
    }
  }

  /**
   * Updates the "Répondez s'il vous plaît" value for attendee
   *
   * @param {boolean} rsvp Whether or not to send out an invitation
   */
  set rsvp(rsvp) {
    this.updateParameterIfExist('RSVP', rsvp ? 'TRUE' : 'FALSE');
  }

  /**
   * Returns the common-name of the attendee
   *
   * @return {string|null}
   */
  get commonName() {
    return this.getParameterFirstValue('CN');
  }

  /**
   * Sets a new common-name of the attendee
   *
   * @param {string} commonName The display name of the attendee
   */
  set commonName(commonName) {
    this.updateParameterIfExist('CN', commonName);
  }

  /**
   * Returns the participation-status of the attendee
   *
   * @return {string}
   */
  get participationStatus() {
    let vobjectType;
    if (this.parent) {
      vobjectType = this.parent.name;
    } else {
      // let's assume we are inside an event
      // if we don't know better
      vobjectType = 'VEVENT';
    }
    const allowed = {
      VEVENT: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED', 'TENTATIVE', 'DELEGATED'],
      VJOURNAL: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED'],
      VTODO: ['NEEDS-ACTION', 'ACCEPTED', 'DECLINED', 'TENTATIVE', 'DELEGATED', 'COMPLETED', 'IN-PROCESS']
    };
    if (!this.hasParameter('PARTSTAT')) {
      return 'NEEDS-ACTION';
    } else {
      const value = this.getParameterFirstValue('PARTSTAT');
      if (allowed[vobjectType].includes(value)) {
        return value;
      }
      return 'NEEDS-ACTION';
    }
  }

  /**
   * Sets a new participation-status of the attendee
   *
   * @param {string} participationStatus The participation status (e.g. ACCEPTED, DECLINED)
   */
  set participationStatus(participationStatus) {
    this.updateParameterIfExist('PARTSTAT', participationStatus);
  }

  /**
   * Gets this attendee's language
   *
   * @return {string}
   */
  get language() {
    return this.getParameterFirstValue('LANGUAGE');
  }

  /**
   * Sets this attendee's language
   * This can be used to influence the language of the invitation email
   *
   * @param {string} language The preferred language of the attendee
   */
  set language(language) {
    this.updateParameterIfExist('LANGUAGE', language);
  }

  /**
   * Gets the email of the attendee
   *
   * @return {string}
   */
  get email() {
    return this.value;
  }

  /**
   * Sets the email address of the attendee
   *
   * @param {string} email The e-email address of the attendee
   */
  set email(email) {
    this.value = startStringWith(email, 'mailto:');
  }

  /**
   * Is this attendee the organizer?
   *
   * @return {boolean}
   */
  isOrganizer() {
    return this._name === 'ORGANIZER';
  }

  /**
   * Creates a new AttendeeProperty from name and email
   *
   * @param {string} name The display name
   * @param {string} email The email address
   * @param {boolean=} isOrganizer Whether this is the organizer or an attendee
   * @return {AttendeeProperty}
   */
  static fromNameAndEMail(name, email, isOrganizer = false) {
    const propertyName = isOrganizer ? 'ORGANIZER' : 'ATTENDEE';
    email = startStringWith(email, 'mailto:');
    return new AttendeeProperty(propertyName, email, [['CN', name]]);
  }

  /**
   * Creates a new AttendeeProperty from name, email, role, userType and rsvp
   *
   * @param {string} name The display name
   * @param {string} email The email address
   * @param {string} role The role
   * @param {string} userType The type of user
   * @param {boolean} rsvp Whether to send out an invitation
   * @param {boolean=} isOrganizer Whether this is the organizer or an attendee
   * @return {AttendeeProperty}
   */
  static fromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp, isOrganizer = false) {
    const propertyName = isOrganizer ? 'ORGANIZER' : 'ATTENDEE';
    email = startStringWith(email, 'mailto:');
    return new AttendeeProperty(propertyName, email, [['CN', name], ['ROLE', role], ['CUTYPE', userType], ['RSVP', rsvp ? 'TRUE' : 'FALSE']]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
(ical_js__WEBPACK_IMPORTED_MODULE_0___default().design).icalendar.property.conference = {
  defaultType: 'uri'
};
(ical_js__WEBPACK_IMPORTED_MODULE_0___default().design).icalendar.param.feature = {
  valueType: 'cal-address',
  multiValue: ','
};

/**
 * @class ConferenceProperty
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 */
class ConferenceProperty extends Property {
  /**
   * Iterator that iterates over all supported features
   * of the conference system
   */
  *getFeatureIterator() {
    if (!this.hasParameter('FEATURE')) {
      return;
    }
    const parameter = this.getParameter('FEATURE');
    yield* parameter.getValueIterator();
  }

  /**
   * Lists all supported features of the conference system
   *
   * @return {string[]}
   */
  listAllFeatures() {
    if (!this.hasParameter('FEATURE')) {
      return [];
    }
    return this.getParameter('FEATURE').value.slice();
  }

  /**
   * Adds a supported feature to the conference system
   *
   * @param {string} featureToAdd Feature to add
   */
  addFeature(featureToAdd) {
    this._modify();
    if (!this.hasParameter('FEATURE')) {
      this.updateParameterIfExist('FEATURE', [featureToAdd]);
    } else {
      if (this.hasFeature(featureToAdd)) {
        return;
      }
      const parameter = this.getParameter('FEATURE');
      parameter.value.push(featureToAdd);
    }
  }

  /**
   * Removes a supported feature
   *
   * @param {string} feature The feature to remove
   */
  removeFeature(feature) {
    this._modify();
    if (!this.hasFeature(feature)) {
      return;
    }
    const parameter = this.getParameter('FEATURE');
    const index = parameter.value.indexOf(feature);
    parameter.value.splice(index, 1);
  }

  /**
   * Removes all supported features from this conference system
   */
  clearAllFeatures() {
    this.deleteParameter('FEATURE');
  }

  /**
   * Check if this conference system supports a feature
   *
   * @param {string} feature The feature to check
   * @return {boolean}
   */
  hasFeature(feature) {
    if (!this.hasParameter('FEATURE')) {
      return false;
    }
    const parameter = this.getParameter('FEATURE');
    if (!Array.isArray(parameter.value)) {
      return false;
    }
    return parameter.value.includes(feature);
  }

  /**
   * Gets label for the conference system
   *
   * @return {string}
   */
  get label() {
    return this.getParameterFirstValue('LABEL');
  }

  /**
   * Updates the label for the conference system
   *
   * @param {string} label The label to set
   */
  set label(label) {
    this.updateParameterIfExist('LABEL', label);
  }

  /**
   * Gets the uri for this conference system
   */
  get uri() {
    return this.value;
  }

  /**
   * Sets the uri for this conference system
   *
   * @param {string} uri The URI to set
   */
  set uri(uri) {
    this.value = uri;
  }

  /**
   * @inheritDoc
   */
  toICALJs() {
    const icalProperty = super.toICALJs();
    icalProperty.setParameter('value', 'URI');
    return icalProperty;
  }

  /**
   * Creates a new ConferenceProperty based on URI, label and features
   *
   * @param {string} uri URI of the Conference
   * @param {string=} label Label of the conference
   * @param {string[]=} features Features of the conference
   * @return {ConferenceProperty}
   */
  static fromURILabelAndFeatures(uri, label = null, features = null) {
    const property = new ConferenceProperty('CONFERENCE', uri);
    if (label) {
      property.updateParameterIfExist('label', label);
    }
    if (features) {
      property.updateParameterIfExist('feature', features);
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class FreeBusyProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.6
 */
class FreeBusyProperty extends Property {
  /**
   * Gets the type of this FreeBusyProperty
   *
   * @return {string}
   */
  get type() {
    const allowed = ['FREE', 'BUSY', 'BUSY-UNAVAILABLE', 'BUSY-TENTATIVE'];
    const defaultValue = 'BUSY';
    if (this.hasParameter('FBTYPE')) {
      const value = this.getParameterFirstValue('FBTYPE');
      if (allowed.includes(value)) {
        return value;
      }
    }
    return defaultValue;
  }

  /**
   * Sets the type of this FreeBusyProperty
   *
   * @param {string} type The type of information (e.g. FREE, BUSY, etc.)
   */
  set type(type) {
    this.updateParameterIfExist('FBTYPE', type);
  }

  /**
   * Creates a new FreeBusyProperty based on period and type
   *
   * @param {PeriodValue} period The period for FreeBusy Information
   * @param {string} type The type of the period
   * @return {FreeBusyProperty}
   */
  static fromPeriodAndType(period, type) {
    return new FreeBusyProperty('FREEBUSY', period, [['fbtype', type]]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class GeoProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
 */
class GeoProperty extends Property {
  /**
   * @inheritDoc
   */
  constructor(name, value = [0, 0], parameters = [], root = null, parent = null) {
    super(name, value, parameters, root, parent);
  }

  /**
   * Gets the latitude stored in this property
   *
   * @return {number}
   */
  get latitude() {
    return this._value[0];
  }

  /**
   * Sets the latitude stored in this property
   *
   * @param {string | number} lat Latitude
   */
  set latitude(lat) {
    this._modifyContent();
    if (typeof lat !== 'number') {
      lat = parseFloat(lat);
    }
    this._value[0] = lat;
  }

  /**
   * Gets the longitude stored in this property
   */
  get longitude() {
    return this._value[1];
  }

  /**
   * Sets the longitude stored in this property
   *
   * @param {string | number} long Longitude
   */
  set longitude(long) {
    this._modifyContent();
    if (typeof long !== 'number') {
      long = parseFloat(long);
    }
    this._value[1] = long;
  }

  /**
   * @inheritDoc
   *
   * TODO: this is an ugly hack right now.
   * As soon as the value is an array, we assume it's multivalue
   * but GEO is a (the one and only besides request-status) structured value and is also
   * stored inside an array.
   *
   * Calling icalProperty.setValues will throw an error
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    icalProperty.setValue(this.value);
    this._parameters.forEach(parameter => {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    });
    return icalProperty;
  }

  /**
   * Creates a new GeoProperty based on a latitude and a longitude value
   *
   * @param {number} lat Latitude
   * @param {number} long Longitude
   * @return {GeoProperty}
   */
  static fromPosition(lat, long) {
    return new GeoProperty('GEO', [lat, long]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ImageProperty
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.10
 */
class ImageProperty extends AttachmentProperty {
  /**
   * Gets the image-type
   */
  get display() {
    return this.getParameterFirstValue('DISPLAY') || 'BADGE';
  }

  /**
   * Gets the image-type
   *
   * @param {string} display The display-type image is optimized for
   */
  set display(display) {
    this.updateParameterIfExist('DISPLAY', display);
  }

  /**
   * Creates a new ImageProperty based on data
   *
   * @param {string} data The data of the image
   * @param {string=} display The display-type it's optimized for
   * @param {string=} formatType The mime-type of the image
   * @return {ImageProperty}
   */
  static fromData(data, display = null, formatType = null) {
    const binaryValue = BinaryValue.fromDecodedValue(data);
    const property = new ImageProperty('IMAGE', binaryValue);
    if (display) {
      property.display = display;
    }
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }

  /**
   * Creates a new ImageProperty based on a link
   *
   * @param {string} uri The uri of the image
   * @param {string=} display The display-type it's optimized for
   * @param {string=} formatType The mime-type of the image
   * @return {ImageProperty}
   */
  static fromLink(uri, display = null, formatType = null) {
    const property = new ImageProperty('IMAGE', uri);
    if (display) {
      property.display = display;
    }
    if (formatType) {
      property.formatType = formatType;
    }
    return property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RelationProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.5
 */
class RelationProperty extends Property {
  /**
   * Get's the relation-type of this related-to property
   *
   * @return {string}
   */
  get relationType() {
    const allowed = ['PARENT', 'CHILD', 'SIBLING'];
    const defaultValue = 'PARENT';
    if (!this.hasParameter('RELTYPE')) {
      return defaultValue;
    } else {
      const value = this.getParameterFirstValue('RELTYPE');
      if (allowed.includes(value)) {
        return value;
      }
      return defaultValue;
    }
  }

  /**
   * Sets a new relation type
   *
   * @param {string} relationType The type of relation (e.g. SIBLING, PARENT, etc.)
   */
  set relationType(relationType) {
    this.updateParameterIfExist('RELTYPE', relationType);
  }

  /**
   * Gets Id of related object
   *
   * @return {string}
   */
  get relatedId() {
    return this.value;
  }

  /**
   * Sets a new related id
   *
   * @param {string} relatedId The Id of the related document
   */
  set relatedId(relatedId) {
    this.value = relatedId;
  }

  /**
   * Creates a new RELATED-TO property based on a relation-type and id
   *
   * @param {string} relType The type of the relation (e.g. SIBLING, CHILD)
   * @param {string} relId The Id of the related document
   * @return {RelationProperty}
   */
  static fromRelTypeAndId(relType, relId) {
    return new RelationProperty('RELATED-TO', relId, [['RELTYPE', relType]]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RequestStatusProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.8.3
 */
class RequestStatusProperty extends Property {
  /**
   * @inheritDoc
   */
  constructor(name, value = ['1', 'Pending'], parameters = [], root = null, parent = null) {
    super(name, value, parameters, root, parent);
  }

  /**
   * Gets the status code of the request status
   *
   * @return {number}
   */
  get statusCode() {
    return parseFloat(this.value[0]);
  }

  /**
   * Sets the status code of the request status
   *
   * @param {number} statusCode The statusCode of the request
   */
  set statusCode(statusCode) {
    this._modifyContent();
    this.value[0] = statusCode.toString();

    // This makes sure 2.0 is actually saved as 2.0, not 2
    if (statusCode === Math.floor(statusCode)) {
      this.value[0] += '.0';
    }
  }

  /**
   * Gets the status message of the request status
   *
   * @return {string}
   */
  get statusMessage() {
    return this.value[1];
  }

  /**
   * Sets the status message of the request status
   *
   * @param {string} statusMessage The message of the request
   */
  set statusMessage(statusMessage) {
    this._modifyContent();
    this.value[1] = statusMessage;
  }

  /**
   * Gets the exception data of the request status if available
   *
   * @return {null | string}
   */
  get exceptionData() {
    if (!this.value[2]) {
      return null;
    }
    return this.value[2];
  }

  /**
   * Sets the exception dtat of the request status
   *
   * @param {string} exceptionData The additional exception-data
   */
  set exceptionData(exceptionData) {
    this._modifyContent();
    this.value[2] = exceptionData;
  }

  /**
   * Check if request is pending
   *
   * @return {boolean}
   */
  isPending() {
    return this.statusCode >= 1 && this.statusCode < 2;
  }

  /**
   * Check if request was successful
   *
   * @return {boolean}
   */
  isSuccessful() {
    return this.statusCode >= 2 && this.statusCode < 3;
  }

  /**
   * Check if a client error occurred
   *
   * @return {boolean}
   */
  isClientError() {
    return this.statusCode >= 3 && this.statusCode < 4;
  }

  /**
   * Check if a scheduling error occurred
   *
   * @return {boolean}
   */
  isSchedulingError() {
    return this.statusCode >= 4 && this.statusCode < 5;
  }

  /**
   * @inheritDoc
   *
   * TODO: this is an ugly hack right now.
   * As soon as the value is an array, we assume it's multivalue
   * but REQUEST-STATUS is a (the one and only besides GEO) structured value and is also
   * stored inside an array.
   *
   * Calling icalProperty.setValues will throw an error
   */
  toICALJs() {
    const icalProperty = createProperty(lc(this.name));
    icalProperty.setValue(this.value);
    this._parameters.forEach(parameter => {
      icalProperty.setParameter(lc(parameter.name), parameter.value);
    });
    return icalProperty;
  }

  /**
   * Creates a new RequestStatusProperty from a code and a status message
   *
   * @param {number} code The status-code of the request
   * @param {string} message The message of the request
   * @return {RequestStatusProperty}
   */
  static fromCodeAndMessage(code, message) {
    return new RequestStatusProperty('REQUEST-STATUS', [code.toString(), message]);
  }
}

// All request statuses registered in RFC 5546
RequestStatusProperty.SUCCESS = [2.0, 'Success'];
RequestStatusProperty.SUCCESS_FALLBACK = [2.1, 'Success, but fallback taken on one or more property values.'];
RequestStatusProperty.SUCCESS_PROP_IGNORED = [2.2, 'Success; invalid property ignored.'];
RequestStatusProperty.SUCCESS_PROPPARAM_IGNORED = [2.3, 'Success; invalid property parameter ignored.'];
RequestStatusProperty.SUCCESS_NONSTANDARD_PROP_IGNORED = [2.4, 'Success; unknown, non-standard property ignored.'];
RequestStatusProperty.SUCCESS_NONSTANDARD_PROPPARAM_IGNORED = [2.5, 'Success; unknown, non-standard property value ignored.'];
RequestStatusProperty.SUCCESS_COMP_IGNORED = [2.6, 'Success; invalid calendar component ignored.'];
RequestStatusProperty.SUCCESS_FORWARDED = [2.7, 'Success; request forwarded to Calendar User.'];
RequestStatusProperty.SUCCESS_REPEATING_IGNORED = [2.8, 'Success; repeating event ignored. Scheduled as a single component.'];
RequestStatusProperty.SUCCESS_TRUNCATED_END = [2.9, 'Success; truncated end date time to date boundary.'];
RequestStatusProperty.SUCCESS_REPEATING_VTODO_IGNORED = [2.10, 'Success; repeating VTODO ignored.  Scheduled as a single VTODO.'];
RequestStatusProperty.SUCCESS_UNBOUND_RRULE_CLIPPED = [2.11, 'Success; unbounded RRULE clipped at some finite number of instances.'];
RequestStatusProperty.CLIENT_INVALID_PROPNAME = [3.0, 'Invalid property name.'];
RequestStatusProperty.CLIENT_INVALID_PROPVALUE = [3.1, 'Invalid property value.'];
RequestStatusProperty.CLIENT_INVALID_PROPPARAM = [3.2, 'Invalid property parameter.'];
RequestStatusProperty.CLIENT_INVALID_PROPPARAMVALUE = [3.3, 'Invalid property parameter value.'];
RequestStatusProperty.CLIENT_INVALUD_CALENDAR_COMP_SEQ = [3.4, 'Invalid calendar component sequence.'];
RequestStatusProperty.CLIENT_INVALID_DATE_TIME = [3.5, 'Invalid date or time.'];
RequestStatusProperty.CLIENT_INVALID_RRULE = [3.6, 'Invalid rule.'];
RequestStatusProperty.CLIENT_INVALID_CU = [3.7, 'Invalid Calendar User.'];
RequestStatusProperty.CLIENT_NO_AUTHORITY = [3.8, 'No authority.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_VERSION = [3.9, 'Unsupported version.'];
RequestStatusProperty.CLIENT_TOO_LARGE = [3.10, 'Request entity too large.'];
RequestStatusProperty.CLIENT_REQUIRED_COMP_OR_PROP_MISSING = [3.11, 'Required component or property missing.'];
RequestStatusProperty.CLIENT_UNKNOWN_COMP_OR_PROP = [3.12, 'Unknown component or property found.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_COMP_OR_PROP = [3.13, 'Unsupported component or property found.'];
RequestStatusProperty.CLIENT_UNSUPPORTED_CAPABILITY = [3.14, 'Unsupported capability.'];
RequestStatusProperty.SCHEDULING_EVENT_CONFLICT = [4.0, 'Event conflict.  Date/time is busy.'];
RequestStatusProperty.SERVER_REQUEST_NOT_SUPPORTED = [5.0, 'Request not supported.'];
RequestStatusProperty.SERVER_SERVICE_UNAVAILABLE = [5.1, 'Service unavailable.'];
RequestStatusProperty.SERVER_INVALID_CALENDAR_SERVICE = [5.2, 'Invalid calendar service.'];
RequestStatusProperty.SERVER_NO_SCHEDULING_FOR_USER = [5.3, 'No scheduling support for user.'];

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TextProperty
 * @classdesc
 */
class TextProperty extends Property {
  /**
   * Gets the alternate text
   *
   * @return {string}
   */
  get alternateText() {
    return this.getParameterFirstValue('ALTREP');
  }

  /**
   * Sets the alternate text
   *
   * @param {string} altRep The alternative text
   */
  set alternateText(altRep) {
    this.updateParameterIfExist('ALTREP', altRep);
  }

  /**
   * Gets language of this property
   *
   * @return {string}
   */
  get language() {
    return this.getParameterFirstValue('LANGUAGE');
  }

  /**
   * Sets language of this property
   *
   * @param {string} language The language of the text
   */
  set language(language) {
    this.updateParameterIfExist('LANGUAGE', language);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TriggerProperty
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.3
 */
class TriggerProperty extends Property {
  /**
   * Gets the related parameter
   *
   * @return {string}
   */
  get related() {
    if (!this.hasParameter('RELATED')) {
      return 'START';
    }
    return this.getParameterFirstValue('RELATED');
  }

  /**
   * Sets the related parameter
   *
   * @param {string} related Either START or END
   */
  set related(related) {
    this.updateParameterIfExist('RELATED', related);
  }

  /**
   * Gets the value of this trigger
   * (If you override the setter, you also have to override the getter or
   *  it will simply be undefined)
   *
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[]}
   */
  get value() {
    return super.value;
  }

  /**
   * Set the value of this trigger
   *
   * @param {DurationValue|DateTimeValue} value The time of trigger
   */
  set value(value) {
    super.value = value;

    // If it's not a duration, remove related parameter
    if (value instanceof DateTimeValue) {
      this.deleteParameter('RELATED');
      super.value = value.getInUTC();
    }
  }

  /**
   * Gets whether this alarm trigger is relative
   *
   * @return {boolean}
   */
  isRelative() {
    return this.getFirstValue() instanceof DurationValue;
  }

  /**
   * Creates a new absolute trigger
   *
   * @param {DateTimeValue} alarmTime Time to create Trigger from
   * @return {TriggerProperty}
   */
  static fromAbsolute(alarmTime) {
    return new TriggerProperty('TRIGGER', alarmTime);
  }

  /**
   * Creates a new relative trigger
   *
   * @param {DurationValue} alarmOffset Duration to create Trigger from
   * @param {boolean=} relatedToStart Related to Start or end?
   * @return {TriggerProperty}
   */
  static fromRelativeAndRelated(alarmOffset, relatedToStart = true) {
    return new TriggerProperty('TRIGGER', alarmOffset, [['RELATED', relatedToStart ? 'START' : 'END']]);
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string} propName Name of the prop to get constructor for
 * @return {AttendeeProperty|GeoProperty|ConferenceProperty|Property|AttachmentProperty|ImageProperty|RelationProperty|RequestStatusProperty}
 */
function getConstructorForPropertyName(propName) {
  switch (uc(propName)) {
    case 'ATTACH':
      return AttachmentProperty;
    case 'ATTENDEE':
    case 'ORGANIZER':
      return AttendeeProperty;
    case 'CONFERENCE':
      return ConferenceProperty;
    case 'FREEBUSY':
      return FreeBusyProperty;
    case 'GEO':
      return GeoProperty;
    case 'IMAGE':
      return ImageProperty;
    case 'RELATED-TO':
      return RelationProperty;
    case 'REQUEST-STATUS':
      return RequestStatusProperty;
    case 'TRIGGER':
      return TriggerProperty;
    case 'COMMENT':
    case 'CONTACT':
    case 'DESCRIPTION':
    case 'LOCATION':
    case 'SUMMARY':
      return TextProperty;
    default:
      return Property;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractComponent
 */
class AbstractComponent extends observerTrait(lockableTrait(class {})) {
  /**
   * Constructor
   *
   * @param {string} name - Name of component
   * @param {Property[]} properties - Array of properties stored inside the component
   * @param {AbstractComponent[]} components - Array of subcomponents stored inside this component
   * @param {CalendarComponent|null} root - The root of this calendar document
   * @param {AbstractComponent|null} parent - The parent component of this element
   */
  constructor(name, properties = [], components = [], root = null, parent = null) {
    super();

    /**
     * Name of component
     *
     * @type {string}
     * @private
     */
    this._name = uc(name);

    /**
     * All properties in this component
     *
     * @type {Map<string, Property[]>}
     * @private
     */
    this._properties = new Map();

    /**
     * All subcomponents of this component
     *
     * @type {Map<string, AbstractComponent[]>}
     * @private
     */
    this._components = new Map();

    /**
     * Root node of ical document
     *
     * @type {CalendarComponent|null}
     * @private
     */
    this._root = root;

    /**
     * Parent node
     *
     * @type {AbstractComponent|null}
     * @private
     */
    this._parent = parent;
    this._setPropertiesFromConstructor(properties);
    this._setComponentsFromConstructor(components);
  }

  /**
   * Get the component's name
   *
   * @return {string}
   */
  get name() {
    return this._name;
  }

  /**
   * Gets the root of this calendar-document
   *
   * @return {CalendarComponent}
   */
  get root() {
    return this._root;
  }

  /**
   * Sets the root of this calendar-document
   *
   * @param {CalendarComponent} root The new root element
   */
  set root(root) {
    this._modify();
    this._root = root;
    for (const property of this.getPropertyIterator()) {
      property.root = root;
    }
    for (const component of this.getComponentIterator()) {
      component.root = root;
    }
  }

  /**
   * Gets the parent component
   *
   * @return {AbstractComponent}
   */
  get parent() {
    return this._parent;
  }

  /**
   * Sets the parent component
   *
   * @param {AbstractComponent} parent The new parent element
   */
  set parent(parent) {
    this._modify();
    this._parent = parent;
  }

  /**
   * Gets the first property that matches the given propertyName
   *
   * @param {string} propertyName Name of the property to get
   * @return {Property|null}
   */
  getFirstProperty(propertyName) {
    if (!this._properties.has(uc(propertyName))) {
      return null;
    }
    return this._properties.get(uc(propertyName))[0];
  }

  /**
   * Gets the first value of the first property matching that name
   *
   * @param {string} propertyName Name of the property to get first value of
   * @return {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null}
   */
  getFirstPropertyFirstValue(propertyName) {
    const property = this.getFirstProperty(propertyName);
    if (!property) {
      return null;
    }
    return property.getFirstValue();
  }

  /**
   * update a property if it exists,
   * create a new one if it doesn't
   *
   * @param {string} propertyName Name of the property to update / create
   * @param {string | number | AbstractValue | string[] | number[] | AbstractValue[] | null} value The value to set
   */
  updatePropertyWithValue(propertyName, value) {
    this._modify();
    const property = this.getFirstProperty(propertyName);
    if (property) {
      property.value = value;
    } else {
      const constructor = getConstructorForPropertyName(propertyName);
      const newProperty = new constructor(propertyName, value, [], this, this.root);
      this.addProperty(newProperty);
    }
  }

  /**
   * Returns iterator for all properties of a given propertyName
   * or if no propertyName was given over all available properties
   *
   * @param {string=} propertyName Name of the property to get an iterator for
   */
  *getPropertyIterator(propertyName = null) {
    if (propertyName) {
      if (!this.hasProperty(propertyName)) {
        return;
      }

      // this._properties.get() returns an array
      // [Symbol.iterator]() creates an iterator from that array
      yield* this._properties.get(uc(propertyName)).slice()[Symbol.iterator]();
    } else {
      for (const key of this._properties.keys()) {
        yield* this.getPropertyIterator(key);
      }
    }
  }

  /**
   * Get all properties by name that match the given LANG parameter
   *
   * @param {string} propertyName The name of the property
   * @param {string | null} lang The lang to query
   * @private
   */
  *_getAllOfPropertyByLang(propertyName, lang) {
    for (const property of this.getPropertyIterator(propertyName)) {
      // getParameterFirstValue will return null if language not set, so no language parameter will match lang=null
      if (property.getParameterFirstValue('LANGUAGE') === lang) {
        yield property;
      }
    }
  }

  /**
   * Get the first property by name that matches the given LANG parameter
   *
   * @param {string} propertyName The name of the property
   * @param {string | null} lang The lang to query
   * @return {Property|null}
   * @private
   */
  _getFirstOfPropertyByLang(propertyName, lang) {
    const iterator = this._getAllOfPropertyByLang(propertyName, lang);
    return iterator.next().value || null;
  }

  /**
   * Adds a property
   *
   * @param {Property} property The property to add
   * @return {boolean}
   */
  addProperty(property) {
    this._modify();
    property.root = this.root;
    property.parent = this;
    if (this._properties.has(property.name)) {
      const arr = this._properties.get(property.name);
      if (arr.indexOf(property) !== -1) {
        // If the property is already part of this component,
        // return false to indicate an error
        return false;
      }
      arr.push(property);
    } else {
      this._properties.set(property.name, [property]);
    }
    property.subscribe(() => this._notifySubscribers());
    return true;
  }

  /**
   * Checks if this component has a property of the given name
   *
   * @param {string} propertyName The name of the property
   * @return {boolean}
   */
  hasProperty(propertyName) {
    return this._properties.has(uc(propertyName));
  }

  /**
   * Removes the given property from this component
   *
   * @param {Property} property The property to delete
   * @return {boolean}
   */
  deleteProperty(property) {
    this._modify();
    if (!this._properties.has(property.name)) {
      return false;
    }
    const arr = this._properties.get(property.name);
    const index = arr.indexOf(property);
    if (index === -1) {
      return false;
    }
    if (index !== -1 && arr.length === 1) {
      // If this is the last property of the given name,
      // remove the entire array from _properties
      // This is required for hasProperty to work properly
      this._properties.delete(property.name);
    } else {
      arr.splice(index, 1);
    }
    return true;
  }

  /**
   * Removes all properties of a given name
   *
   * @param {string} propertyName The name of the property
   * @return {boolean}
   */
  deleteAllProperties(propertyName) {
    this._modify();
    return this._properties.delete(uc(propertyName));
  }

  /**
   * Gets the first component of a given name
   *
   * @param {string} componentName The name of the component
   * @return {AbstractComponent|null}
   */
  getFirstComponent(componentName) {
    if (!this.hasComponent(componentName)) {
      return null;
    }
    return this._components.get(uc(componentName))[0];
  }

  /**
   * Returns iterator for all components of a given componentName
   * or if no componentName was given over all available components
   *
   * @param {string=} componentName The name of the component
   */
  *getComponentIterator(componentName) {
    if (componentName) {
      if (!this.hasComponent(componentName)) {
        return;
      }

      // this._components.get() returns an array
      // [Symbol.iterator]() creates an iterator from that array
      yield* this._components.get(uc(componentName)).slice()[Symbol.iterator]();
    } else {
      for (const key of this._components.keys()) {
        yield* this.getComponentIterator(key);
      }
    }
  }

  /**
   * Adds a new component to this component
   *
   * @param {AbstractComponent} component The component to add
   * @return {boolean}
   */
  addComponent(component) {
    this._modify();
    component.root = this.root;
    component.parent = this;
    if (this._components.has(component.name)) {
      const arr = this._components.get(component.name);
      if (arr.indexOf(component) !== -1) {
        // If the property is already part of this component,
        // return false to indicate an error
        return false;
      }
      arr.push(component);
    } else {
      this._components.set(component.name, [component]);
    }
    component.subscribe(() => this._notifySubscribers());
    return true;
  }

  /**
   * Checks if this component has a component of the given name
   *
   * @param {string} componentName The name of the component
   * @return {boolean}
   */
  hasComponent(componentName) {
    return this._components.has(uc(componentName));
  }

  /**
   * Removes the given component from this component
   *
   * @param {AbstractComponent} component The component to delete
   * @return {boolean}
   */
  deleteComponent(component) {
    this._modify();
    if (!this._components.has(component.name)) {
      return false;
    }
    const arr = this._components.get(component.name);
    const index = arr.indexOf(component);
    if (index === -1) {
      return false;
    }
    if (index !== -1 && arr.length === 1) {
      // If this is the last component of the given name,
      // remove the entire array from _components
      // This is required for hasComponent to work properly
      this._components.delete(component.name);
    } else {
      arr.splice(index, 1);
    }
    return true;
  }

  /**
   * Removes all components of a given name
   *
   * @param {string} componentName The name of the component
   * @return {boolean}
   */
  deleteAllComponents(componentName) {
    this._modify();
    return this._components.delete(uc(componentName));
  }

  /**
   * Marks this parameter is immutable
   * locks it against further modification
   */
  lock() {
    super.lock();
    for (const property of this.getPropertyIterator()) {
      property.lock();
    }
    for (const component of this.getComponentIterator()) {
      component.lock();
    }
  }

  /**
   * Marks this parameter as mutable
   * allowing further modification
   */
  unlock() {
    super.unlock();
    for (const property of this.getPropertyIterator()) {
      property.unlock();
    }
    for (const component of this.getComponentIterator()) {
      component.unlock();
    }
  }

  /**
   * Creates a copy of this parameter
   *
   * @return {AbstractComponent}
   */
  clone() {
    const properties = [];
    for (const property of this.getPropertyIterator()) {
      properties.push(property.clone());
    }
    const components = [];
    for (const component of this.getComponentIterator()) {
      components.push(component.clone());
    }
    return new this.constructor(this.name, properties, components, this.root, this.parent);
  }

  /**
   * Adds properties from constructor to this._properties
   *
   * @param {Property[]} properties Array of properties
   * @private
   */
  _setPropertiesFromConstructor(properties) {
    for (let property of properties) {
      if (Array.isArray(property)) {
        const constructor = getConstructorForPropertyName(property[0]);
        property = new constructor(property[0], property[1]);
      }
      this.addProperty(property);
    }
  }

  /**
   * Adds components from constructor to this._components
   *
   * @param {AbstractComponent[]} components Array of components
   * @private
   */
  _setComponentsFromConstructor(components) {
    for (const component of components) {
      this.addComponent(component);
    }
  }

  /**
   * Creates a new Component based on an ical object
   *
   * @param {ICAL.Component} icalValue The ical.js component to initialise from
   * @param {CalendarComponent=} root The root of the Calendar Document
   * @param {AbstractComponent=} parent The parent element of this component
   * @return {AbstractComponent}
   */
  static fromICALJs(icalValue, root = null, parent = null) {
    if (!(icalValue instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Component))) {
      throw new ExpectedICalJSError();
    }
    const name = icalValue.name;
    const newComponent = new this(name, [], [], root, parent);
    for (const icalProp of icalValue.getAllProperties()) {
      const constructor = getConstructorForPropertyName(icalProp.name);
      const property = constructor.fromICALJs(icalProp, root, newComponent);
      newComponent.addProperty(property);
    }
    for (const icalComp of icalValue.getAllSubcomponents()) {
      const constructor = this._getConstructorForComponentName(icalComp.name);
      const component = constructor.fromICALJs(icalComp, root, newComponent);
      newComponent.addComponent(component);
    }
    return newComponent;
  }

  /**
   * Gets a constructor for a give component name
   *
   * @param {string} componentName The name of the component
   * @return {AbstractComponent}
   * @protected
   */
  static _getConstructorForComponentName(componentName) {
    return AbstractComponent;
  }

  /**
   * turns this Component into an ICAL.js component
   *
   * @return {ICAL.Component}
   */
  toICALJs() {
    const component = createComponent(lc(this.name));
    for (const prop of this.getPropertyIterator()) {
      component.addProperty(prop.toICALJs());
    }
    for (const comp of this.getComponentIterator()) {
      component.addSubcomponent(comp.toICALJs());
    }
    return component;
  }
}

/**
 * Advertise properties that may at most occur once
 *
 * Properties, which may at most occur once, get a simple getter and setter
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 * @param {boolean} advertiseValueOnly Whether to advertise the value only or the entire property
 */
function advertiseSingleOccurrenceProperty(prototype, options, advertiseValueOnly = true) {
  options = getDefaultOncePropConfig(options);
  Object.defineProperty(prototype, options.name, {
    get() {
      const value = this.getFirstPropertyFirstValue(options.iCalendarName);
      if (!value) {
        return options.defaultValue;
      } else {
        if (Array.isArray(options.allowedValues) && !options.allowedValues.includes(value)) {
          return options.unknownValue;
        }
        return value;
      }
    },
    set(value) {
      this._modify();
      if (value === null) {
        this.deleteAllProperties(options.iCalendarName);
        return;
      }
      if (Array.isArray(options.allowedValues) && !options.allowedValues.includes(value)) {
        throw new TypeError('Illegal value');
      }
      this.updatePropertyWithValue(options.iCalendarName, value);
    }
  });
}

/**
 * Advertise properties that may occur more than once
 *
 * Properties, which may occur more than once, won't get simple getter / setter,
 * but rather a more advanced set of get{name}Iterator, get{name}List, add{name},
 * remove{name} and clearAll{name} methods
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 */
function advertiseMultipleOccurrenceProperty(prototype, options) {
  options = getDefaultMultiplePropConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* () {
    yield* this.getPropertyIterator(options.iCalendarName);
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function () {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator']());
  };
  prototype['remove' + ucFirst(options.name)] = function (property) {
    this.deleteProperty(property);
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function () {
    this.deleteAllProperties(options.iCalendarName);
  };
}

/**
 * advertises a multi-value string property enabling simple access by language
 * This is used for:
 * - CATEGORIES
 * - RESOURCES
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising properties
 */
function advertiseMultiValueStringPropertySeparatedByLang(prototype, options) {
  options = getDefaultMultiplePropConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* (lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      yield* property.getValueIterator();
    }
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function (lang = null) {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator'](lang));
  };
  prototype['add' + ucFirst(options.name)] = function (value, lang = null) {
    const property = this._getFirstOfPropertyByLang(options.iCalendarName, lang);
    if (property) {
      property.addValue(value);
    } else {
      const newProperty = new Property(options.iCalendarName, [value]);
      if (lang) {
        const languageParameter = new Parameter('LANGUAGE', lang);
        newProperty.setParameter(languageParameter);
      }
      this.addProperty(newProperty);
    }
  };
  prototype['remove' + ucFirst(options.name)] = function (value, lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      if (property.isMultiValue() && property.hasValue(value)) {
        if (property.value.length === 1) {
          this.deleteProperty(property);
          return true;
        }
        property.removeValue(value);
        return true;
      }
    }
    return false;
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function (lang = null) {
    for (const property of this._getAllOfPropertyByLang(options.iCalendarName, lang)) {
      this.deleteProperty(property);
    }
  };
}

/**
 * advertise a component
 *
 * @param {object} prototype The object's prototype
 * @param {object} options The options for advertising components
 */
function advertiseComponent(prototype, options) {
  options = getDefaultMultipleCompConfig(options);
  prototype['get' + ucFirst(options.name) + 'Iterator'] = function* () {
    yield* this.getComponentIterator(options.iCalendarName);
  };
  prototype['get' + ucFirst(options.name) + 'List'] = function () {
    return Array.from(this['get' + ucFirst(options.name) + 'Iterator']());
  };
  prototype['remove' + ucFirst(options.name)] = function (component) {
    this.deleteComponent(component);
  };
  prototype['clearAll' + ucFirst(options.pluralName)] = function () {
    this.deleteAllComponents(options.iCalendarName);
  };
}

/**
 * Fill up the options object for advertiseProperty
 *
 * @param {object | string} options The options object
 * @param {string} options.name Advertised name of the property
 * @param {string=} options.iCalendarName The iCalendar name of the property
 * @param {string[]=} options.allowedValues A list of allowed values
 * @param {string | number=} options.defaultValue The default value if unset
 * @param {string | number=} options.unknownValue The fallback value if unknown value
 * @return {object}
 */
function getDefaultOncePropConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: uc(options.name),
    pluralName: options.name + 's',
    allowedValues: null,
    defaultValue: null,
    unknownValue: null
  }, options);
}

/**
 * Fill up the options object for advertiseProperty
 *
 * @param {object | string} options The options object
 * @param {string} options.name Advertised name of property
 * @param {string=} options.iCalendarName The iCalendar name of the property
 * @param {boolean=} options.customAddMethod Whether or not to use a custom add method
 * @return {object}
 */
function getDefaultMultiplePropConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: uc(options.name),
    pluralName: options.name + 's'
  }, options);
}

/**
 * Fill up the options object for advertiseComponent
 *
 * @param {object | string} options Options destructuring object
 * @param {string} options.name Advertised name of component
 * @param {string=} options.iCalendarName The iCalendar name of the component
 * @param {boolean=} options.customAddMethod Whether or not to use a custom add method
 * @return {object}
 */
function getDefaultMultipleCompConfig(options) {
  if (typeof options === 'string') {
    options = {
      name: options
    };
  }
  return Object.assign({}, {
    iCalendarName: 'V' + uc(options.name),
    pluralName: options.name + 's'
  }, options);
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets a new DateObject set to now
 *
 * @return {Date}
 */
function dateFactory() {
  return new Date();
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class RecurringWithoutDtStartError extends Error {}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class RecurrenceHelper
 * @classdesc
 *
 * TODO: This needs caching
 */
class RecurrenceManager {
  /**
   * Constructor
   *
   * @param {AbstractRecurringComponent} masterItem The master-item of the recurrence-set
   */
  constructor(masterItem) {
    /**
     *
     * @type {AbstractRecurringComponent}
     * @private
     */
    this._masterItem = masterItem;

    /**
     * Set of Recurrence exception items
     *
     * Number is the unix time representation of the recurrence ID
     *
     * @type {Map<number, AbstractRecurringComponent>}
     * @private
     */
    this._recurrenceExceptionItems = new Map();

    /**
     * A sorted index of recurrence ids with range
     *
     * @type {number[]}
     * @private
     */
    this._rangeRecurrenceExceptionItemsIndex = [];

    /**
     * Cached difference of dtstart and recurrenceId for recurrence exceptions with range
     *
     * @type {Map<number, DurationValue>}
     * @private
     */
    this._rangeRecurrenceExceptionItemsDiffCache = new Map();

    /**
     * Set of Recurrence exception items that have a RANGE of THISANDFUTURE
     *
     * Number is the unix time representation of the recurrence ID
     *
     * @type {Map<number, AbstractRecurringComponent>}
     * @private
     */
    this._rangeRecurrenceExceptionItems = new Map();
  }

  /**
   *
   * @return {AbstractRecurringComponent}
   */
  get masterItem() {
    return this._masterItem;
  }

  /**
   *
   * @param {AbstractRecurringComponent} masterItem The master-item of the recurrence-set
   */
  set masterItem(masterItem) {
    this._masterItem = masterItem;
  }

  /**
   * Gets an iterator over all registered recurrence exceptions of this calendar-document
   */
  *getRecurrenceExceptionIterator() {
    yield* this._recurrenceExceptionItems.values();
  }

  /**
   * Gets a list of all registered recurrence-exceptions of this calendar-document
   *
   * @return {AbstractRecurringComponent[]}
   */
  getRecurrenceExceptionList() {
    return Array.from(this.getRecurrenceExceptionIterator());
  }

  /**
   * Checks if there is a recurrence Exception for a given recurrenceId
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to check
   * @return {boolean}
   */
  hasRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    return this._recurrenceExceptionItems.has(recurrenceId);
  }

  /**
   * Gets the recurrence exception for a given recurrence Id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getRecurrenceException(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    return this._recurrenceExceptionItems.get(recurrenceId) || null;
  }

  /**
   * Check if there is a recurrence-exception with a range for a given recurrence-id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to check
   * @return {boolean}
   */
  hasRangeRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    if (this._rangeRecurrenceExceptionItemsIndex.length === 0) {
      return false;
    }
    return this._rangeRecurrenceExceptionItemsIndex[0] < recurrenceId;
  }

  /**
   * Get recurrence-exception with range that's affecting the given recurrence-id
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getRangeRecurrenceExceptionForId(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    const index = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(this._rangeRecurrenceExceptionItemsIndex, recurrenceId, (a, b) => a - b);
    if (index === 0) {
      return null;
    }
    const key = this._rangeRecurrenceExceptionItemsIndex[index - 1];
    return this._rangeRecurrenceExceptionItems.get(key);
  }

  /**
   * Gets the difference between recurrence-id and start
   * Mostly needed to handle recurrence-exceptions with range
   *
   * @param {DateTimeValue | number} recurrenceId The recurrenceId to get
   * @return {DurationValue|null}
   */
  getRangeRecurrenceExceptionDiff(recurrenceId) {
    if (recurrenceId instanceof DateTimeValue) {
      recurrenceId = recurrenceId.unixTime;
    } else if (recurrenceId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)) {
      recurrenceId = recurrenceId.toUnixTime();
    }
    if (this._rangeRecurrenceExceptionItemsDiffCache.has(recurrenceId)) {
      return this._rangeRecurrenceExceptionItemsDiffCache.get(recurrenceId);
    }
    const recurrenceException = this.getRangeRecurrenceExceptionForId(recurrenceId);
    if (!recurrenceException) {
      return null;
    }
    const originalRecurrenceId = recurrenceException.recurrenceId;
    const originalModifiedStart = recurrenceException.startDate;
    const difference = originalModifiedStart.subtractDateWithTimezone(originalRecurrenceId);
    difference.lock();
    this._rangeRecurrenceExceptionItemsDiffCache.set(recurrenceId, difference);
    return difference;
  }

  /**
   * Adds a new recurrence-exception to this calendar-document
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem The recurrence-exception-item to relate to recurrence-set
   */
  relateRecurrenceException(recurrenceExceptionItem) {
    this._modify();
    const key = this._getRecurrenceIdKey(recurrenceExceptionItem);
    this._recurrenceExceptionItems.set(key, recurrenceExceptionItem);
    if (recurrenceExceptionItem.modifiesFuture()) {
      this._rangeRecurrenceExceptionItems.set(key, recurrenceExceptionItem);
      const index = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(this._rangeRecurrenceExceptionItemsIndex, key, (a, b) => a - b);
      this._rangeRecurrenceExceptionItemsIndex.splice(index, 0, key);
    }
    recurrenceExceptionItem.recurrenceManager = this;
  }

  /**
   * Removes a recurrence exception by the item itself
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem The recurrence-exception remove
   */
  removeRecurrenceException(recurrenceExceptionItem) {
    const key = this._getRecurrenceIdKey(recurrenceExceptionItem);
    this.removeRecurrenceExceptionByRecurrenceId(key);
  }

  /**
   * Removes a recurrence exception by it's unix-time
   *
   * @param {number} recurrenceId The recurrence-exception to remove
   */
  removeRecurrenceExceptionByRecurrenceId(recurrenceId) {
    this._modify();
    this._recurrenceExceptionItems.delete(recurrenceId);
    this._rangeRecurrenceExceptionItems.delete(recurrenceId);
    this._rangeRecurrenceExceptionItemsDiffCache.delete(recurrenceId);
    const index = this._rangeRecurrenceExceptionItemsIndex.indexOf(recurrenceId);
    if (index !== -1) {
      this._rangeRecurrenceExceptionItemsIndex.splice(index, 1);
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} recurrenceExceptionItem Object to get key from
   * @return {number}
   * @private
   */
  _getRecurrenceIdKey(recurrenceExceptionItem) {
    return recurrenceExceptionItem.recurrenceId.unixTime;
  }

  /**
   * Gets an iterator over all recurrence rules
   */
  *getRecurrenceRuleIterator() {
    for (const property of this._masterItem.getPropertyIterator('RRULE')) {
      yield property.getFirstValue();
    }
  }

  /**
   * Gets a list of all recurrence rules
   *
   * @return {RecurValue[]}
   */
  getRecurrenceRuleList() {
    return Array.from(this.getRecurrenceRuleIterator());
  }

  /**
   * Adds a new recurrence rule
   *
   * @param {RecurValue} recurrenceRule The RRULE to add
   */
  addRecurrenceRule(recurrenceRule) {
    this._modify();
    this.resetCache();
    const property = new Property('RRULE', recurrenceRule);
    this._masterItem.addProperty(property);
  }

  /**
   * Removes a recurrence rule
   *
   * @param {RecurValue} recurrenceRule The RRULE to remove
   */
  removeRecurrenceRule(recurrenceRule) {
    this._modify();
    this.resetCache();
    for (const property of this._masterItem.getPropertyIterator('RRULE')) {
      if (property.getFirstValue() === recurrenceRule) {
        this._masterItem.deleteProperty(property);
      }
    }
  }

  /**
   * Removes all recurrence rules
   */
  clearAllRecurrenceRules() {
    this._modify();
    this.resetCache();
    this._masterItem.deleteAllProperties('RRULE');
  }

  /**
   * Gets an iterator over all recurrence
   *
   * @param {boolean} isNegative Whether or not to get EXDATES
   * @param {string} valueType Limit type of EXDATES
   */
  *getRecurrenceDateIterator(isNegative = false, valueType = null) {
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      yield* property.getValueIterator();
    }
  }

  /**
   *
   * @param {boolean} isNegative Whether or not to get EXDATES
   * @param {string} valueType Limit type of EXDATES
   * @return {(DateTimeValue|PeriodValue)[]}
   */
  listAllRecurrenceDates(isNegative = false, valueType = null) {
    return Array.from(this.getRecurrenceDateIterator(isNegative, valueType));
  }

  /**
   * This adds a new recurrence-date value.
   * It automatically adds it to the first property of the same value-type
   * or creates a new one if necessary
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue|PeriodValue} value EXDATE to add
   */
  addRecurrenceDate(isNegative = false, value) {
    this._modify();
    this.resetCache();

    // Only add DateTime Value if its of the same timezone
    let timezoneId = null;
    if (value instanceof DateTimeValue && !value.isDate) {
      timezoneId = value.timezoneId;
    }
    const valueType = this._getValueTypeByValue(value);
    const iterator = this._getPropertiesForRecurrenceDate(isNegative, valueType, timezoneId);
    const first = iterator.next.value;
    if (first instanceof Property) {
      const propertyValue = first.value;
      propertyValue.push(value);
      this.masterItem.markPropertyAsDirty(isNegative ? 'EXDATE' : 'RDATE');
    } else {
      const propertyName = this._getPropertyNameByIsNegative(isNegative);
      const property = new Property(propertyName, value);
      this._masterItem.addProperty(property);
    }
  }

  /**
   * Checks if a recurrenceID is an RDATE or EXDATE
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue} recurrenceId Recurrence-Id to check
   * @return {boolean}
   */
  hasRecurrenceDate(isNegative = false, recurrenceId) {
    for (let value of this.getRecurrenceDateIterator(isNegative)) {
      if (value instanceof PeriodValue) {
        value = value.start;
      }
      if (value.compare(recurrenceId) === 0) {
        return true;
      }
    }
    return false;
  }

  /**
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue} recurrenceId Recurrence-Id to get
   * @return {null|DateTimeValue|PeriodValue}
   */
  getRecurrenceDate(isNegative = false, recurrenceId) {
    for (const value of this.getRecurrenceDateIterator(isNegative)) {
      let valueToCheck = value;
      if (valueToCheck instanceof PeriodValue) {
        valueToCheck = valueToCheck.start;
      }
      if (valueToCheck.compare(recurrenceId) === 0) {
        return value;
      }
    }
    return null;
  }

  /**
   * This deletes a recurrence-date value from this recurrence-set
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {DateTimeValue|PeriodValue} value The EXDATE/RDATE to remove
   */
  removeRecurrenceDate(isNegative = false, value) {
    this._modify();
    this.resetCache();
    const valueType = this._getValueTypeByValue(value);
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      for (const valueToCheck of property.getValueIterator()) {
        if (value === valueToCheck) {
          const allValues = property.value;
          if (allValues.length === 1) {
            this.masterItem.deleteProperty(property);
            continue;
          }
          const index = allValues.indexOf(value);
          allValues.splice(index, 1);
          this.masterItem.markPropertyAsDirty(isNegative ? 'EXDATE' : 'RDATE');
        }
      }
    }
  }

  /**
   * Clears all recurrence-date information
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {string} valueType The type of RDATEs/EXDATEs to remove
   */
  clearAllRecurrenceDates(isNegative = false, valueType = null) {
    this._modify();
    this.resetCache();
    for (const property of this._getPropertiesForRecurrenceDate(isNegative, valueType)) {
      this._masterItem.deleteProperty(property);
    }
  }

  /**
   * Gets the property name for recurrence dates based on the isNegative boolean
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @return {string}
   * @private
   */
  _getPropertyNameByIsNegative(isNegative) {
    return isNegative ? 'EXDATE' : 'RDATE';
  }

  /**
   * Gets the value type based on the provided value
   *
   * @param {PeriodValue|DateTimeValue} value The value to get type of property from
   * @return {string}
   * @private
   */
  _getValueTypeByValue(value) {
    if (value instanceof PeriodValue) {
      return 'PERIOD';
    } else if (value.isDate) {
      return 'DATE';
    } else {
      return 'DATETIME';
    }
  }

  /**
   *
   * @param {boolean} isNegative Whether we are dealing with an EXDATE or RDATE
   * @param {string | null} valueType The type of values to get
   * @param {ICAL.Timezone=} timezoneId Filter by timezone
   * @private
   */
  *_getPropertiesForRecurrenceDate(isNegative, valueType, timezoneId = null) {
    const propertyName = this._getPropertyNameByIsNegative(isNegative);
    for (const property of this._masterItem.getPropertyIterator(propertyName)) {
      if (valueType === null) {
        yield property;
      } else if (uc(valueType) === 'PERIOD' && property.getFirstValue() instanceof PeriodValue) {
        yield property;
      } else if (uc(valueType) === 'DATE' && property.getFirstValue().isDate) {
        yield property;
      } else if (uc(valueType) === 'DATETIME' && !property.getFirstValue().isDate) {
        if (timezoneId === null || property.getFirstValue().timezoneId === timezoneId) {
          yield property;
        }
      }
    }
  }

  /**
   * Checks if the entire set of recurrence rules is finite
   *
   * @return {boolean}
   */
  isFinite() {
    return this.getRecurrenceRuleList().every(rule => rule.isFinite());
  }

  /**
   * @return {boolean}
   */
  isEmptyRecurrenceSet() {
    return this._getRecurExpansionObject().next() === undefined;
  }

  /**
   * Gets the occurrence at the exact given recurrenceId
   *
   * @param {DateTimeValue} recurrenceId RecurrenceId to get
   * @return {AbstractRecurringComponent|null}
   */
  getOccurrenceAtExactly(recurrenceId) {
    if (!this.masterItem.isRecurring()) {
      if (this.masterItem.getReferenceRecurrenceId().compare(recurrenceId) === 0) {
        return this.masterItem;
      }
      return null;
    }
    const iterator = this._getRecurExpansionObject();
    const icalRecurrenceId = recurrenceId.toICALJs();
    let next;
    while (next = iterator.next()) {
      if (next.compare(icalRecurrenceId) === 0) {
        // It's a match 🔥
        return this._getOccurrenceAtRecurrenceId(DateTimeValue.fromICALJs(next));
      }
      if (next.compare(icalRecurrenceId) === 1) {
        // We hit an occurrence in the future, return null
        return null;
      }
    }
    return null;
  }

  /**
   * Gets the closest occurrence to the given recurrenceId.
   * That's either the closest in the future, or in case the
   * recurrence-set ends before recurrenceId, the last one
   *
   * This function works solely on the basis of recurrence-ids.
   * It ignores the actual date of recurrence-exceptions.
   * Ideally we should fix it and provide a similar implementation
   * like getAllOccurrencesBetweenIterator, but for now it's the
   * accepted behavior.
   *
   * @param {DateTimeValue} recurrenceId RecurrenceId to get
   * @return {AbstractRecurringComponent}
   */
  getClosestOccurrence(recurrenceId) {
    if (!this.masterItem.isRecurring()) {
      return this.masterItem;
    }
    const iterator = this._getRecurExpansionObject();
    recurrenceId = recurrenceId.toICALJs();
    let previous = null;
    let next;
    while (next = iterator.next()) {
      if (next.compare(recurrenceId) === -1) {
        previous = next;
      } else {
        // This is the case when it's either equal or in the future
        const dateTimeValue = DateTimeValue.fromICALJs(next);
        return this._getOccurrenceAtRecurrenceId(dateTimeValue);
      }
    }
    const dateTimeValue = DateTimeValue.fromICALJs(previous);
    return this._getOccurrenceAtRecurrenceId(dateTimeValue);
  }

  /**
   * Counts all occurrences in the given time-range.
   * This function works solely on the basis of recurrence-ids.
   * Start and end are inclusive.
   *
   * @param {DateTimeValue} queriedTimeRangeStart Start of time-range
   * @param {DateTimeValue} queriedTimeRangeEnd End of time-range
   * @return {number} Count of occurrences in the given time-range
   */
  countAllOccurrencesBetween(queriedTimeRangeStart, queriedTimeRangeEnd) {
    if (!this.masterItem.isRecurring()) {
      if (typeof this.masterItem.isInTimeFrame === 'function' && !this.masterItem.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        return 0;
      }
      return 1;
    }
    const iterator = this._getRecurExpansionObject();
    const queriedICALJsTimeRangeStart = queriedTimeRangeStart.toICALJs();
    const queriedICALJsTimeRangeEnd = queriedTimeRangeEnd.toICALJs();
    let count = 0;
    let next;
    while (next = iterator.next()) {
      if (next.compare(queriedICALJsTimeRangeStart) === -1) {
        continue;
      }
      if (next.compare(queriedICALJsTimeRangeEnd) === 1) {
        break;
      }
      count += 1;
    }
    return count;
  }

  /**
   * Get all occurrences between start and end
   * Start and End are inclusive
   *
   * @param {DateTimeValue} queriedTimeRangeStart Start of time-range
   * @param {DateTimeValue} queriedTimeRangeEnd End of time-range
   */
  *getAllOccurrencesBetweenIterator(queriedTimeRangeStart, queriedTimeRangeEnd) {
    if (!this.masterItem.isRecurring()) {
      if (typeof this.masterItem.isInTimeFrame !== 'function') {
        yield this.masterItem;
      }
      if (this.masterItem.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        yield this.masterItem;
      }
      return;
    }
    const iterator = this._getRecurExpansionObject();
    const queriedICALJsTimeRangeStart = queriedTimeRangeStart.toICALJs();
    const queriedICALJsTimeRangeEnd = queriedTimeRangeEnd.toICALJs();
    const recurrenceIdKeys = Array.from(this._recurrenceExceptionItems.keys());
    const maximumRecurrenceId = Math.max.apply(Math, recurrenceIdKeys);
    let next;
    while (next = iterator.next()) {
      // We have to get the real occurrence to resolve RECURRENCE-IDs
      const dateTimeValue = DateTimeValue.fromICALJs(next);
      const occurrence = this._getOccurrenceAtRecurrenceId(dateTimeValue);

      // Check what type of recurrence object we are dealing with
      // Depending on that, the time to compare to changes
      // If we are dealing events, we have to compare to the end-date
      // If we are dealing with tasks, we will have to compare to the due-date
      // etc.
      // For now we are only implementing events, other components will come later
      let compareDate = null;
      switch (uc(occurrence.name)) {
        case 'VEVENT':
        case 'VTODO':
          compareDate = occurrence.endDate.toICALJs();
          break;
        case 'VJOURNAL':
        default:
          compareDate = next;
          break;
      }

      // If the date we are comparing to is before our time-range,
      // we don't want to yield this event
      if (compareDate.compare(queriedICALJsTimeRangeStart) === -1) {
        continue;
      }

      // If we have an object that is:
      // 1. either
      // 1.1 - no recurrence exception
      //     or
      // 1.2 - a recurrence-exception that modifies the future
      // and
      // 2. starts after the queried time-range ends, then we stop expanding
      const startDate = occurrence.startDate.toICALJs();
      if ((!occurrence.isRecurrenceException() || occurrence.modifiesFuture()) && startDate.compare(queriedICALJsTimeRangeEnd) === 1) {
        // Just break if there are no recurrence-exceptions
        if (this._recurrenceExceptionItems.size === 0) {
          break;
        }

        // Keep iterating until our currently checked recurrenceId
        // is bigger than the maximum recurrence-id that we have.
        if (next.toUnixTime() > maximumRecurrenceId) {
          break;
        } else {
          continue;
        }
      }
      if (typeof occurrence.isInTimeFrame !== 'function') {
        yield occurrence;
      }
      if (occurrence.isInTimeFrame(queriedTimeRangeStart, queriedTimeRangeEnd)) {
        yield occurrence;
      }
    }
  }

  /**
   * Get all occurrences between start and end
   *
   * @param {DateTimeValue} start Start of time-range
   * @param {DateTimeValue} end End of time-range
   * @return {(*|null)[]}
   */
  getAllOccurrencesBetween(start, end) {
    return Array.from(this.getAllOccurrencesBetweenIterator(start, end));
  }

  /**
   * Update the UID of all components in the recurrence set
   *
   * @param {string} newUID The new UID of the calendar-document
   */
  updateUID(newUID) {
    this._masterItem.updatePropertyWithValue('UID', newUID);
    for (const recurrenceExceptionItem of this.getRecurrenceExceptionIterator()) {
      recurrenceExceptionItem.updatePropertyWithValue('UID', newUID);
    }
  }

  /**
   * Updates the recurrence-information accordingly,
   * whenever the start-date of the master-item changes
   *
   * @param {DateTimeValue} newStartDate The new start-date
   * @param {DateTimeValue} oldStartDate The old start-date
   */
  updateStartDateOfMasterItem(newStartDate, oldStartDate) {
    const difference = newStartDate.subtractDateWithTimezone(oldStartDate);

    // update EXDATE
    for (const exdate of this.getRecurrenceDateIterator(true)) {
      // If this EXDATE matches an RDATE, don't update, because we don't update RDATEs
      if (this.hasRecurrenceDate(false, exdate)) {
        continue;
      }

      // EXDATE are always either DATE or DATETIME,
      // no need to check for PERIOD
      exdate.addDuration(difference);
    }
    for (const recurrenceException of this.getRecurrenceExceptionIterator()) {
      // We don't edit RDATES, so don't update recurrence-ids if they
      // are based on an RDATE
      if (this.hasRecurrenceDate(false, recurrenceException.recurrenceId)) {
        continue;
      }
      this.removeRecurrenceException(recurrenceException);
      recurrenceException.recurrenceId.addDuration(difference);
      this.relateRecurrenceException(recurrenceException);
    }

    // update UNTIL of recurrence-rules
    for (const rrule of this.getRecurrenceRuleIterator()) {
      if (rrule.until) {
        rrule.until.addDuration(difference);
      }
    }
  }

  /**
   * Gets an object for the given recurrenceId
   * It does not verify that the given recurrenceId
   * is actually a valid recurrence of this calendar-document
   *
   * @param {DateTimeValue} recurrenceId Recurrence-Id to get
   * @return {AbstractRecurringComponent}
   * @private
   */
  _getOccurrenceAtRecurrenceId(recurrenceId) {
    if (this.hasRecurrenceExceptionForId(recurrenceId)) {
      const recurrenceException = this.getRecurrenceException(recurrenceId);
      if (!recurrenceException.canCreateRecurrenceExceptions()) {
        return recurrenceException;
      }
      return recurrenceException.forkItem(recurrenceId);
    } else if (this.hasRangeRecurrenceExceptionForId(recurrenceId)) {
      const rangeRecurrenceException = this.getRangeRecurrenceExceptionForId(recurrenceId);
      const difference = this.getRangeRecurrenceExceptionDiff(recurrenceId);
      return rangeRecurrenceException.forkItem(recurrenceId, difference);
    } else if (recurrenceId.compare(this._masterItem.startDate) === 0) {
      if (!this._masterItem.canCreateRecurrenceExceptions()) {
        return this._masterItem;
      }
      return this._masterItem.forkItem(recurrenceId);
    } else {
      return this._masterItem.forkItem(recurrenceId);
    }
  }

  /**
   * Resets the internal recur-expansion object.
   * This is necessary after each modification of the
   * recurrence-information
   */
  resetCache() {
    // TODO - implement me
  }

  /**
   * Gets a new ICAL.RecurExpansion object
   *
   * Inspired by how ICAL.JS RecurExpansion
   * serialises and unserialises its state
   *
   * @return {ICAL.RecurExpansion}
   * @private
   */
  _getRecurExpansionObject() {
    if (this._masterItem.startDate === null) {
      throw new RecurringWithoutDtStartError();
    }
    const dtstart = this._masterItem.startDate.toICALJs();
    let last = dtstart.clone();
    const ruleIterators = [];
    let ruleDateInc;
    const ruleDates = [];
    let ruleDate = null;
    const exDates = [];
    const complete = false;
    for (const ruleValue of this.getRecurrenceRuleIterator()) {
      ruleIterators.push(ruleValue.toICALJs().iterator(dtstart));
      ruleIterators[ruleIterators.length - 1].next();
    }
    for (let rDateValue of this.getRecurrenceDateIterator()) {
      if (rDateValue instanceof PeriodValue) {
        rDateValue = rDateValue.start;
      }
      rDateValue = rDateValue.toICALJs();
      const index = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(ruleDates, rDateValue, (a, b) => a.compare(b));
      ruleDates.splice(index, 0, rDateValue);
    }

    // Is the first RDATE prior to our current DTSTART?
    if (ruleDates.length > 0 && ruleDates[0].compare(dtstart) === -1) {
      ruleDateInc = 0;
      last = ruleDates[0].clone();
    } else {
      ruleDateInc = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(ruleDates, dtstart, (a, b) => a.compare(b));
      ruleDate = exDates[ruleDateInc];
    }
    for (let exDateValue of this.getRecurrenceDateIterator(true)) {
      exDateValue = exDateValue.toICALJs();
      const index = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(exDates, exDateValue, (a, b) => a.compare(b));
      exDates.splice(index, 0, exDateValue);
    }
    const exDateInc = ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.binsearchInsert(exDates, dtstart, (a, b) => a.compare(b));
    const exDate = exDates[exDateInc];
    return new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().RecurExpansion)({
      dtstart,
      last,
      ruleIterators,
      ruleDateInc,
      exDateInc,
      ruleDates,
      ruleDate,
      exDates,
      exDate,
      complete
    });
  }

  /**
   * @private
   */
  _modify() {
    if (this._masterItem.isLocked()) {
      throw new ModificationNotAllowedError();
    }
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
 * @class Timezone
 */
class Timezone {
  /**
   * Constructor
   *
   * @param {string | ICAL.Timezone | ICAL.Component} timezoneId Id of the timezone
   * @param {string?} ics The iCalendar timezone definition
   */
  constructor(timezoneId, ics) {
    /**
     * Id of the timezone, used before initialising
     *
     * @type {string}
     * @private
     */
    this._timezoneId = null;

    /**
     * ICS representation of the timezone, used before initialising
     *
     * @type {string}
     * @private
     */
    this._ics = null;

    /**
     * @type {ICAL.Timezone|null}
     */
    this._innerValue = null;

    /**
     *
     * @type {boolean}
     * @private
     */
    this._initialized = false;

    // If the first parameter is already
    // an instance of ICAL.Timezone,
    // skip lazy loading
    if (timezoneId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone)) {
      this._innerValue = timezoneId;
      this._initialized = true;
    } else if (timezoneId instanceof (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Component)) {
      this._innerValue = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone)(timezoneId);
      this._initialized = true;
    } else {
      this._timezoneId = timezoneId;
      this._ics = ics;
    }
  }

  /**
   * Gets the timezone id
   *
   * @return {string}
   */
  get timezoneId() {
    if (this._initialized) {
      return this._innerValue.tzid;
    }
    return this._timezoneId;
  }

  /**
   * Gets the UTC Offset for a given date in this timezone
   *
   * @param {number} year Year of the date
   * @param {number} month Month of the date (1-based)
   * @param {number} day Day of the date
   * @param {number} hour Hour of the date
   * @param {number} minute Minute of the date
   * @param {number} second Second of the date
   * @return {number}
   */
  offsetForArray(year, month, day, hour, minute, second) {
    this._initialize();
    const time = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time)({
      year,
      month,
      day,
      hour,
      minute,
      second,
      isDate: false
    });
    return this._innerValue.utcOffset(time);
  }

  /**
   * Converts a timestamp to an array of year, month, day, hour, minute, second.
   *
   * @param {number} ms Timestamp in milliseconds
   * @return {number[]}
   */
  timestampToArray(ms) {
    this._initialize();

    // just create a dummy object because fromUnixTime is not exposed on ICAL.Time
    const time = ical_js__WEBPACK_IMPORTED_MODULE_0___default().Time.fromData({
      year: 1970,
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0
    });
    time.fromUnixTime(Math.floor(ms / 1000));
    const local = time.convertToZone(this._innerValue);
    return [local.year, local.month,
    // THIS is 1-based !
    local.day, local.hour, local.minute, local.second];
  }

  /**
   * Returns
   *
   * @return {ICAL.Timezone}
   */
  toICALTimezone() {
    this._initialize();
    return this._innerValue;
  }

  /**
   * Returns the corresponding ICAL.
   *
   * @return {ICAL.Component}
   */
  toICALJs() {
    this._initialize();
    return this._innerValue.component;
  }

  /**
   * Initialises the inner ICAL.Timezone component
   *
   * @private
   */
  _initialize() {
    if (!this._initialized) {
      const jCal = ical_js__WEBPACK_IMPORTED_MODULE_0___default().parse(this._ics);
      const icalComp = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Component)(jCal);
      this._innerValue = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone)(icalComp);
      this._initialized = true;
    }
  }
}
Timezone.utc = new Timezone((ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone).utcTimezone);
Timezone.floating = new Timezone((ical_js__WEBPACK_IMPORTED_MODULE_0___default().Timezone).localTimezone);

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AlarmComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.6
 */
class AlarmComponent extends AbstractComponent {
  /**
   * Adds a new attendee based on their name and email-address
   *
   * @param {string} name - Name of the attendee
   * @param {string} email - E-Mail address of the attendee
   * @return {boolean}
   */
  addAttendeeFromNameAndEMail(name, email) {
    const attendeeProperty = AttendeeProperty.fromNameAndEMail(name, email);
    return this.addProperty(attendeeProperty);
  }

  /**
   * Gets the trigger property
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.3
   *
   * @return {TriggerProperty}
   */
  get trigger() {
    return this.getFirstProperty('TRIGGER');
  }

  /**
   * Sets an absolute alarm
   *
   * @param {DateTimeValue} alarmTime - Absolute time for the trigger
   */
  setTriggerFromAbsolute(alarmTime) {
    const triggerProperty = TriggerProperty.fromAbsolute(alarmTime);
    this.deleteAllProperties('TRIGGER');
    this.addProperty(triggerProperty);
  }

  /**
   * Sets a relative trigger
   *
   * @param {DurationValue} alarmOffset - Relative time of the trigger, either related to start or end
   * @param {boolean=} relatedToStart - Related to Start or end?
   */
  setTriggerFromRelative(alarmOffset, relatedToStart = true) {
    const triggerProperty = TriggerProperty.fromRelativeAndRelated(alarmOffset, relatedToStart);
    this.deleteAllProperties('TRIGGER');
    this.addProperty(triggerProperty);
  }
}

/**
 * Action to be taken when this Alarm is due
 * Possible values:
 * - AUDIO
 * - DISPLAY
 * - EMAIL
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.1
 *
 * @name AlarmComponent#action
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'action');

/**
 * Description for this alarm
 * Can only be used in combination with action DISPLAY and EMAIL
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name AlarmComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'description');

/**
 * Summary for this alarm
 * Can only be used in combination with action EMAIL
 * Will be used as the EMAIL's subject
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.12
 *
 * @name AlarmComponent#summary
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'summary');

/**
 * The duration specifies the delay period between repeated alarms.
 * This property must be specified along with the repeat property
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.5
 *
 * @name AlarmComponent#duration
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'duration');

/**
 * The number of times an alarm should be repeated.
 * This property must be specified along with the duration property
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.6.2
 *
 * @name AlarmComponent#repeat
 * @type {number}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, 'repeat');

/**
 * This attachment points to a sound file, can only be used in combination
 * with ACTION AUDIO
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.1
 *
 * @name AlarmComponent#attachment
 * @type {AttachmentProperty}
 */
advertiseSingleOccurrenceProperty(AlarmComponent.prototype, {
  name: 'attachment',
  iCalendarName: 'ATTACH'
});

/**
 * Get an iterator over all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Get a list of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#getAttendeeList
 * @function
 * @return {AttendeeProperty[]}
 */

/**
 * Adds a new attendee to this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#addAttendee
 * @function
 * @param {AttendeeProperty} attendee - The attendee object to add
 */

/**
 * Removes an attendee from this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee - The attendee object to remove
 */

/**
 * Removes all attendees from this alarm-component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name AlarmComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(AlarmComponent.prototype, 'attendee');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets the constructor for a component name
 * This will only return a constructor for components,
 * that can be nested inside other ones
 *
 * @param {string} compName - Component name to get default constructor for
 * @return {AlarmComponent|AbstractComponent}
 */
function getConstructorForComponentName$1(compName) {
  switch (uc(compName)) {
    case 'VALARM':
      return AlarmComponent;
    default:
      return AbstractComponent;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractRecurringComponent
 * @classdesc AbstractRecurringComponent is the basis for
 * EventComponent, JournalComponent and TodoComponent.
 *
 * It contains all the logic for recurrence-expansion and
 * recurrence-management plus all management for all
 * properties and all subcomponents that the three
 * components mentioned before have in common
 */
class AbstractRecurringComponent extends AbstractComponent {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * In case this object is virtual, primary item refers to the master object
     * that this object was forked from.
     *
     * Otherwise primary item is null
     *
     * @type {AbstractRecurringComponent}
     * @private
     */
    this._primaryItem = null;

    /**
     * Indicator whether this is a direct fork of a primary item, representing
     * the very same recurrence id
     *
     * @type {boolean}
     * @private
     */
    this._isExactForkOfPrimary = false;

    /**
     * The original recurrence-id of this occurrence.
     * Mostly needed for range exceptions with a range
     *
     * @type {DateTimeValue|null}
     * @private
     */
    this._originalRecurrenceId = null;

    /**
     * Instance of the recurrence manager.
     * This object is shared among all instances
     * of a recurrence-set
     *
     * @type {RecurrenceManager}
     * @private
     */
    this._recurrenceManager = null;

    /**
     * Indicator whether this component was modified
     * In case it was, the last-modified property
     * needs to be updated before saving the event
     *
     * @type {boolean}
     * @private
     */
    this._dirty = false;

    /**
     * Indicator whether there have been significant changes
     * In case the changes are considered significant,
     * the sequence needs to be incremented
     *
     * @type {boolean}
     * @private
     */
    this._significantChange = false;

    /**
     * Id of this AbstractRecurringComponent
     *
     * @type {string | null}
     * @private
     */
    this._cachedId = null;
  }

  /**
   * Gets the primary-item of this recurring item
   *
   * @return {AbstractRecurringComponent}
   */
  get primaryItem() {
    return this._primaryItem;
  }

  /**
   * Sets the primary-item of this recurring item
   *
   * @param {AbstractRecurringComponent} primaryItem The new primary-item
   */
  set primaryItem(primaryItem) {
    this._modify();
    this._primaryItem = primaryItem;
  }

  /**
   * Gets whether or not this is a fork of the primary item
   * for the same recurrence-id
   *
   * @return {boolean}
   */
  get isExactForkOfPrimary() {
    return this._isExactForkOfPrimary;
  }

  /**
   * Sets the isExactForkOfPrimary indicator, see getter for description
   *
   * @param {boolean} isExactForkOfPrimary Whether or not this is an exact fork
   */
  set isExactForkOfPrimary(isExactForkOfPrimary) {
    this._isExactForkOfPrimary = isExactForkOfPrimary;
  }

  /**
   * Gets the original recurrence-id
   *
   * @return {DateTimeValue}
   */
  get originalRecurrenceId() {
    return this._originalRecurrenceId;
  }

  /**
   * Sets the original recurrence-id
   *
   * @param {DateTimeValue} originalRecurrenceId The new original recurrence-id
   */
  set originalRecurrenceId(originalRecurrenceId) {
    this._originalRecurrenceId = originalRecurrenceId;
  }

  /**
   * Gets the recurrence-manager of this recurrence-set
   *
   * @return {RecurrenceManager}
   */
  get recurrenceManager() {
    return this._recurrenceManager;
  }

  /**
   * Sets the recurrence-manager of this recurrence-set
   *
   * @param {RecurrenceManager} recurrenceManager The new recurrence-manager
   */
  set recurrenceManager(recurrenceManager) {
    this._recurrenceManager = recurrenceManager;
  }

  /**
   * Gets the master-item of this recurring item
   *
   * @return {AbstractRecurringComponent}
   */
  get masterItem() {
    return this.recurrenceManager.masterItem;
  }

  /**
   * Returns whether this item is the master item
   *
   * @return {boolean}
   */
  isMasterItem() {
    return this.masterItem === this;
  }

  /**
   * Gets a unique ID for this occurrence of the event
   *
   * Please note that if the same event occurs in multiple calendars,
   * this id will not be unique. Software using this library will have to
   * manually mix in the calendar id into this id
   *
   * @return {string}
   */
  get id() {
    if (this._cachedId) {
      return this._cachedId;
    }
    if (this.startDate === null) {
      this._cachedId = encodeURIComponent(this.uid);
      return this._cachedId;
    }
    this._cachedId = [encodeURIComponent(this.uid), encodeURIComponent(this.getReferenceRecurrenceId().unixTime.toString())].join('###');
    return this._cachedId;
  }

  /**
   * Gets the UID property
   *
   * @return {string | null}
   */
  get uid() {
    return this.getFirstPropertyFirstValue('UID');
  }

  /**
   * Sets the UID property and the UID property of all related exceptions
   *
   * @param {string} uid The new UID
   */
  set uid(uid) {
    this._recurrenceManager.updateUID(uid);
  }

  /**
   * Gets the start date of the event
   *
   * @return {DateTimeValue}
   */
  get startDate() {
    return this.getFirstPropertyFirstValue('dtstart');
  }

  /**
   * Sets the start date of the event
   *
   * @param {DateTimeValue} start The new start-date to set
   */
  set startDate(start) {
    const oldStartDate = this.startDate;
    this.updatePropertyWithValue('dtstart', start);
    if (this.isMasterItem()) {
      this._recurrenceManager.updateStartDateOfMasterItem(start, oldStartDate);
    }
  }

  /**
   * Checks whether this item is part of a recurring set
   *
   * @return {boolean}
   */
  isPartOfRecurrenceSet() {
    return this.masterItem.isRecurring();
  }

  /**
   * Checks whether this component is recurring
   *
   * @return {boolean}
   */
  isRecurring() {
    return this.hasProperty('RRULE') || this.hasProperty('RDATE');
  }

  /**
   * Checks whether this component is a recurrence-exception
   *
   * @return {boolean}
   */
  isRecurrenceException() {
    return this.hasProperty('RECURRENCE-ID');
  }

  /**
   * Checks wether this component is a recurrence-exception
   * and whether it's modifying the future
   *
   * @return {boolean}
   */
  modifiesFuture() {
    if (!this.isRecurrenceException()) {
      return false;
    }
    const property = this.getFirstProperty('RECURRENCE-ID');
    return property.getParameterFirstValue('RANGE') === 'THISANDFUTURE';
  }

  /**
   * Creates an occurrence at the given time
   *
   * This is an internal function for calendar-js, used by the recurrence-manager
   * Do not call from outside
   *
   * @param {DateTimeValue} recurrenceId The recurrence-Id of the forked item
   * @param {DurationValue=} startDiff to be used when The start-diff (used for RECURRENCE-ID;RANGE=THISANDFUTURE)
   * @return {AbstractRecurringComponent}
   */
  forkItem(recurrenceId, startDiff = null) {
    const occurrence = this.clone();
    occurrence.recurrenceManager = this.recurrenceManager;
    occurrence.primaryItem = this;

    // Exact match for master item or recurrence-exception
    if (occurrence.getReferenceRecurrenceId().compare(recurrenceId) === 0) {
      occurrence.isExactForkOfPrimary = true;
    }
    if (!occurrence.hasProperty('DTSTART')) {
      throw new TypeError('Can\'t fork item without a DTSTART');
    }

    // Adjust RRULE COUNT if present
    const rrule = occurrence.getFirstPropertyFirstValue('RRULE');
    if (rrule?.count) {
      let index = occurrence.recurrenceManager.countAllOccurrencesBetween(occurrence.getReferenceRecurrenceId(), recurrenceId);
      index -= 1; // Don't count the forked occurrence
      rrule.count -= index;
      if (rrule.count < 1) {
        rrule.count = 1;
      }
    }
    if (occurrence.getFirstPropertyFirstValue('DTSTART').timezoneId !== recurrenceId.timezoneId) {
      const originalTimezone = occurrence.getFirstPropertyFirstValue('DTSTART').getICALTimezone();
      recurrenceId = recurrenceId.getInICALTimezone(originalTimezone);
    }
    occurrence.originalRecurrenceId = recurrenceId.clone();
    const dtStartValue = occurrence.getFirstPropertyFirstValue('DTSTART');
    let period = null;
    if (this._recurrenceManager.hasRecurrenceDate(false, recurrenceId)) {
      const recurrenceDate = this._recurrenceManager.getRecurrenceDate(false, recurrenceId);
      if (recurrenceDate instanceof PeriodValue) {
        period = recurrenceDate;
      }
    }
    let duration;
    if (occurrence.hasProperty('DTEND')) {
      const dtEndValue = occurrence.getFirstPropertyFirstValue('DTEND');
      duration = dtEndValue.subtractDateWithTimezone(dtStartValue);
    } else if (occurrence.hasProperty('DUE')) {
      const dueValue = occurrence.getFirstPropertyFirstValue('DUE');
      duration = dueValue.subtractDateWithTimezone(dtStartValue);
    }
    if (!(occurrence.isRecurrenceException() && occurrence.isExactForkOfPrimary)) {
      occurrence.updatePropertyWithValue('DTSTART', recurrenceId.clone());
      if (startDiff) {
        occurrence.startDate.addDuration(startDiff);
      }
      if (occurrence.hasProperty('DTEND')) {
        const dtEnd = occurrence.startDate.clone();
        dtEnd.addDuration(duration);
        occurrence.updatePropertyWithValue('DTEND', dtEnd);
      } else if (occurrence.hasProperty('DUE')) {
        const due = occurrence.startDate.clone();
        due.addDuration(duration);
        occurrence.updatePropertyWithValue('DUE', due);
      }
      if (period) {
        occurrence.deleteAllProperties('DTEND');
        occurrence.deleteAllProperties('DURATION');
        occurrence.updatePropertyWithValue('DTEND', period.end.clone());
      }
    }
    occurrence.resetDirty();
    return occurrence;
  }

  /**
   * Checks whether it's possible to create a recurrence exception for this event
   * It is possible
   *
   * @return {boolean}
   */
  canCreateRecurrenceExceptions() {
    let primaryIsRecurring = false;
    if (this.primaryItem && this.primaryItem.isRecurring()) {
      primaryIsRecurring = true;
    }
    return this.isRecurring() || this.modifiesFuture() || !this.isRecurring() && primaryIsRecurring;
  }

  /**
   * creates a recurrence exception based on this event
   * If the parameter thisAndAllFuture is set to true,
   * it will apply changes to this and all future occurrences
   *
   * @param {boolean} thisAndAllFuture Whether to create an exception for this and all future
   * @return {AbstractRecurringComponent[]} the AbstractRecurringComponent of the future events.
   * In case you set `thisAndAllFuture` to true, this will be an
   * AbstractRecurringComponent inside a entirely new calendar component
   */
  createRecurrenceException(thisAndAllFuture = false) {
    if (!this.canCreateRecurrenceExceptions()) {
      throw new Error('Can\'t create recurrence-exceptions for non-recurring items');
    }
    const previousPrimaryItem = this.primaryItem;

    /**
     * The overall support for RANGE=THISANDFUTURE is really bad.
     * Instead, we have to create a new event/journal/task and
     * set an until date on the old one.
     *
     * Also see:
     * - https://github.com/nextcloud/calendar/issues/7#issuecomment-292574813
     * - https://github.com/nextcloud/calendar/issues/7#issuecomment-299169143
     *
     * Right now, this replaces all future occurrence modifications,
     * including recurrence-exceptions, RDATES and EXDATES.
     * This is also how other CUAs handle it, but i would be happy
     * to put that up for discussion.
     *
     * Keeping future RDates + their recurrence-exceptions would be rather easy.
     * Updating recurrence-exceptions, that are based off normal recurrence rules,
     * could be very expensive.
     */
    if (thisAndAllFuture) {
      if (this.isExactForkOfPrimary) {
        // master item
        if (this.primaryItem.isMasterItem()) {
          this._overridePrimaryItem();
          return [this, this];
        }
      }
      this.removeThisOccurrence(true);
      this.recurrenceManager = new RecurrenceManager(this);
      this._originalRecurrenceId = null;
      this.primaryItem = this;
      this.updatePropertyWithValue('UID', (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])());
      this._cachedId = null;
      this.addRelation('SIBLING', previousPrimaryItem.uid);
      previousPrimaryItem.addRelation('SIBLING', this.uid);

      // delete to make sure all parameters are gone
      this.deleteAllProperties('RECURRENCE-ID');
      this.deleteAllProperties('RDATE');
      this.deleteAllProperties('EXDATE');
      this.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('SEQUENCE', 0);
      this._significantChange = false;
      this._dirty = false;
      this.root = this.root.constructor.fromEmpty();
      this.root.addComponent(this);
      this.parent = this.root;

      // this is a completely new event, we should set the RSVP of all attendees to true,
      // so that they receive an invitation to the new event, not only the cancellation of the old one
      for (const attendee of this.getAttendeeIterator()) {
        attendee.rsvp = true;
      }
    } else {
      // delete to make sure all parameters are gone
      this.deleteAllProperties('RECURRENCE-ID');
      this.recurrenceId = this.getReferenceRecurrenceId().clone();
      this.root.addComponent(this);
      this.recurrenceManager.relateRecurrenceException(this);
      this.primaryItem = this;
      this.deleteAllProperties('RDATE');
      this.deleteAllProperties('RRULE');
      this.deleteAllProperties('EXDATE');
      this.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
      this.updatePropertyWithValue('SEQUENCE', 0);
      if (this.recurrenceManager.hasRecurrenceDate(false, this.getReferenceRecurrenceId())) {
        const recurDate = this.recurrenceManager.getRecurrenceDate(false, this.getReferenceRecurrenceId());
        if (recurDate instanceof PeriodValue) {
          const valueDateTimeRecurDate = recurDate.start;
          this.recurrenceManager.removeRecurrenceDate(false, recurDate);
          this.recurrenceManager.addRecurrenceDate(false, valueDateTimeRecurDate);
        }
      }
      this.originalRecurrenceId = null;
    }
    return [previousPrimaryItem, this];
  }

  /**
   * Deletes this occurrence from the series of recurring events
   * If the parameter thisAndAllFuture is set to true,
   * it will remove this and all future occurrences
   *
   * @param {boolean} thisAndAllFuture Whether to create an exception for this and all future
   * @throws EmptyRecurrenceSetError Thrown, when deleting an occurrence results in no more events
   * @return {boolean} true if this deleted the last occurrence in set, false if there are occurrences left
   */
  removeThisOccurrence(thisAndAllFuture = false) {
    if (!this.isPartOfRecurrenceSet()) {
      // When deleting an object, that's not part of a recurring set,
      // the calendar-document would be empty.
      return true;
    }
    if (thisAndAllFuture) {
      // To get the UNTIL date, just deduct one second.
      // That's also how macOS does it, so this should be fairly
      // well supported among all clients
      const recurrenceId = this.getReferenceRecurrenceId().clone();
      const until = recurrenceId.getInTimezone(Timezone.utc);
      until.addDuration(DurationValue.fromSeconds(-1));
      for (const recurValue of this.recurrenceManager.getRecurrenceRuleIterator()) {
        recurValue.until = until.clone();
      }
      for (const recurDate of this.recurrenceManager.getRecurrenceDateIterator()) {
        let valueToCheck = recurDate;
        if (recurDate instanceof PeriodValue) {
          valueToCheck = valueToCheck.start;
        }
        if (recurrenceId.compare(valueToCheck) <= 0) {
          this.recurrenceManager.removeRecurrenceDate(false, recurDate);
        }
      }
      for (const exceptionDate of this.recurrenceManager.getRecurrenceDateIterator(true)) {
        if (recurrenceId.compare(exceptionDate) <= 0) {
          this.recurrenceManager.removeRecurrenceDate(true, exceptionDate);
        }
      }
      for (const exception of this.recurrenceManager.getRecurrenceExceptionList()) {
        if (recurrenceId.compare(exception.recurrenceId) <= 0) {
          this.root.deleteComponent(exception);
          this.recurrenceManager.removeRecurrenceException(exception);
        }
      }
    } else {
      // Make sure we don't leave orphaned recurrence-exceptions
      if (this.isRecurrenceException() && !this.modifiesFuture()) {
        this.root.deleteComponent(this);
        this.recurrenceManager.removeRecurrenceException(this);
      }

      // If this is based on a recurrence-date, simply delete it
      // otherwise add an exception-date
      if (this.recurrenceManager.hasRecurrenceDate(false, this.getReferenceRecurrenceId())) {
        const recurDate = this.recurrenceManager.getRecurrenceDate(false, this.getReferenceRecurrenceId());
        this.recurrenceManager.removeRecurrenceDate(false, recurDate);
      } else {
        this.recurrenceManager.addRecurrenceDate(true, this.getReferenceRecurrenceId().clone());
      }
    }
    return this.recurrenceManager.isEmptyRecurrenceSet();
  }

  /**
   * @inheritDoc
   */
  clone() {
    const comp = super.clone();
    comp.resetDirty();
    return comp;
  }

  /**
   * Adds a new attendee
   *
   * @param {AttendeeProperty} attendee The attendee property to add
   * @private
   * @return {boolean}
   */
  _addAttendee(attendee) {
    // Check for different Attendee objects with the same uri
    for (const a of this.getAttendeeIterator()) {
      if (a.email === attendee.email) {
        return false;
      }
    }
    this.addProperty(attendee);
    return true;
  }

  /**
   * Adds a new attendee based on their name and email-address
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   * @return {boolean}
   */
  addAttendeeFromNameAndEMail(name, email) {
    const attendeeProperty = AttendeeProperty.fromNameAndEMail(name, email);
    return this._addAttendee(attendeeProperty);
  }

  /**
   * Adds a new attendee based on their properties
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   * @param {string} role The role of the attendee to add
   * @param {string} userType The type of attendee to add
   * @param {boolean} rsvp Whether or not to request a response from the attendee
   * @return {boolean}
   */
  addAttendeeFromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp) {
    const attendeeProperty = AttendeeProperty.fromNameEMailRoleUserTypeAndRSVP(name, email, role, userType, rsvp, false);
    return this._addAttendee(attendeeProperty);
  }

  /**
   * Sets the organiser property from common-name and email address
   *
   * @param {string} name The name of the organizer
   * @param {string} email The email-address of the organizer
   */
  setOrganizerFromNameAndEMail(name, email) {
    this.deleteAllProperties('ORGANIZER');
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email, true));
  }

  /**
   * Adds a new attachment from raw data
   *
   * @param {string} data The data of the attachment
   * @param {string} formatType The mime-type of the attachment
   */
  addAttachmentFromData(data, formatType = null) {
    this.addProperty(AttachmentProperty.fromData(data, formatType));
  }

  /**
   * Adds a new attachment from a link
   *
   * @param {string} uri The URI of the attachment
   * @param {string} formatType The mime-type of the attachment
   */
  addAttachmentFromLink(uri, formatType = null) {
    this.addProperty(AttachmentProperty.fromLink(uri, formatType));
  }

  /**
   * Adds a new contact
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.2
   *
   * @param {string} contact The textual contact description to add
   */
  addContact(contact) {
    this.addProperty(new TextProperty('CONTACT', contact));
  }

  /**
   * Adds a new comment
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.4
   *
   * @param {string} comment The comment to add
   */
  addComment(comment) {
    this.addProperty(new TextProperty('COMMENT', comment));
  }

  /**
   * Adds a new image from raw data
   *
   * @param {string} data Data of the image to add
   * @param {string=} display What display-type the image is optimized for
   * @param {string=} formatType The mime-type of the image
   */
  addImageFromData(data, display = null, formatType = null) {
    this.addProperty(ImageProperty.fromData(data, display, formatType));
  }

  /**
   * Adds a new image from a link
   *
   * @param {string} uri The URI of the image to add
   * @param {string=} display What display-type the image is optimized for
   * @param {string=} formatType The mime-type of the image
   */
  addImageFromLink(uri, display = null, formatType = null) {
    this.addProperty(ImageProperty.fromLink(uri, display, formatType));
  }

  /**
   * Creates a new RELATED-TO property based on a relation-type and id
   * and adds it to this object
   *
   * @param {string} relType The type of relation to add
   * @param {string} relId The id of the related calendar-document
   */
  addRelation(relType, relId) {
    this.addProperty(RelationProperty.fromRelTypeAndId(relType, relId));
  }

  /**
   * Creates a new REQUEST-STATUS property based on code and message
   * and adds it to this object
   *
   * @param {number} code The status-code of the request status
   * @param {string} message The message of the request status
   */
  addRequestStatus(code, message) {
    this.addProperty(RequestStatusProperty.fromCodeAndMessage(code, message));
  }

  /**
   * Adds a new absolute alarm based on action and trigger time
   *
   * @param {string} action The type of alarm Action
   * @param {DateTimeValue} alarmTime The trigger time of the alarm
   * @return {AlarmComponent}
   */
  addAbsoluteAlarm(action, alarmTime) {
    const alarmComp = new AlarmComponent('VALARM', [['action', action], TriggerProperty.fromAbsolute(alarmTime)]);
    this.addComponent(alarmComp);
    return alarmComp;
  }

  /**
   * Adds a new relative alarm based on action, trigger time and relativeTo parameter
   *
   * @param {string} action The type of alarm Action
   * @param {DurationValue} alarmOffset The trigger time of the alarm
   * @param {boolean=} relatedToStart Whether or not the alarm is related to the event's start
   * @return {AlarmComponent}
   */
  addRelativeAlarm(action, alarmOffset, relatedToStart = true) {
    const alarmComp = new AlarmComponent('VALARM', [['action', action], TriggerProperty.fromRelativeAndRelated(alarmOffset, relatedToStart)]);
    this.addComponent(alarmComp);
    return alarmComp;
  }

  /**
   * Marks a certain property as edited
   *
   * @param {string} propertyName The name of the property
   */
  markPropertyAsDirty(propertyName) {
    this.markDirty();

    // Properties that must be considered a significant change
    // according to RFC 5546 Section 2.1.4
    const props = ['DTSTART', 'DTEND', 'DURATION', 'RRULE', 'RDATE', 'EXDATE', 'STATUS', ...getConfig('property-list-significant-change', [])];
    if (props.includes(uc(propertyName))) {
      this.markChangesAsSignificant();
    }
  }

  /**
   * Marks a certain component as edited
   *
   * @param {string} componentName The name of the component
   */
  markSubComponentAsDirty(componentName) {
    this.markDirty();
    if (getConfig('component-list-significant-change', []).includes(componentName)) {
      this.markChangesAsSignificant();
    }
  }

  /**
   * Returns whether or not this component is dirty
   *
   * @return {boolean}
   */
  isDirty() {
    return this._dirty || this._significantChange;
  }

  /**
   * Marks this object as dirty
   */
  markDirty() {
    this._dirty = true;
  }

  /**
   * Marks changes as significant. Can be called by the program using this lib
   */
  markChangesAsSignificant() {
    this._significantChange = true;
  }

  /**
   * Updates the event after modifications.
   *
   * @return {boolean} true if last-modified was updated
   */
  undirtify() {
    if (!this.isDirty()) {
      return false;
    }
    if (!this.hasProperty('SEQUENCE')) {
      this.sequence = 0;
    }
    this.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
    this.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
    if (this._significantChange) {
      this.sequence++;
    }
    this.resetDirty();
    return true;
  }

  /**
   * Resets the dirty indicators without updating DTSTAMP or LAST-MODIFIED
   */
  resetDirty() {
    this._dirty = false;
    this._significantChange = false;
  }

  /**
   * @inheritDoc
   */
  updatePropertyWithValue(propertyName, value) {
    super.updatePropertyWithValue(propertyName, value);
    if (uc(propertyName) === 'UID') {
      this._cachedId = null;
    }
    this.markPropertyAsDirty(propertyName);
  }

  /**
   * @inheritDoc
   */
  addProperty(property) {
    this.markPropertyAsDirty(property.name);
    property.subscribe(() => this.markPropertyAsDirty(property.name));
    return super.addProperty(property);
  }

  /**
   * @inheritDoc
   */
  deleteProperty(property) {
    this.markPropertyAsDirty(property.name);
    return super.deleteProperty(property);
  }

  /**
   * @inheritDoc
   */
  deleteAllProperties(propertyName) {
    this.markPropertyAsDirty(propertyName);
    return super.deleteAllProperties(propertyName);
  }

  /**
   * @inheritDoc
   */
  addComponent(component) {
    this.markSubComponentAsDirty(component.name);
    component.subscribe(() => this.markSubComponentAsDirty(component.name));
    return super.addComponent(component);
  }

  /**
   * @inheritDoc
   */
  deleteComponent(component) {
    this.markSubComponentAsDirty(component.name);
    return super.deleteComponent(component);
  }

  /**
   * @inheritDoc
   */
  deleteAllComponents(componentName) {
    this.markSubComponentAsDirty(componentName);
    return super.deleteAllComponents(componentName);
  }

  /**
   * Gets a recurrence-id that has to be used to refer to this event.
   * This is used for recurrence-management
   *
   * @return {DateTimeValue|null}
   */
  getReferenceRecurrenceId() {
    if (this.originalRecurrenceId) {
      return this.originalRecurrenceId;
    } else if (this.recurrenceId) {
      return this.recurrenceId;
    } else if (this.startDate) {
      return this.startDate;
    }
    return null;
  }

  /**
   * Overrides the master item with this one
   *
   * @private
   */
  _overridePrimaryItem() {
    const oldStartDate = this.primaryItem.startDate;
    for (const property of this.primaryItem.getPropertyIterator()) {
      this.primaryItem.deleteProperty(property);
    }
    for (const property of this.getPropertyIterator()) {
      this.primaryItem.addProperty(property);
    }
    this.recurrenceManager.resetCache();
    if (this.startDate.compare(oldStartDate) !== 0) {
      this.recurrenceManager.updateStartDateOfMasterItem(this.startDate, oldStartDate);
    }
  }

  /**
   * @inheritDoc
   */
  static _getConstructorForComponentName(componentName) {
    return getConstructorForComponentName$1(componentName);
  }

  /**
   * @inheritDoc
   */
  static fromICALJs(...args) {
    const comp = super.fromICALJs(...args);
    comp.resetDirty();
    return comp;
  }
}

/**
 * Date-Time stamp of this object.
 * It has different meaning, based on whether or not a method is defined
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.2
 *
 * @name EventComponent#stampTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'stampTime',
  iCalendarName: 'DTSTAMP'
});

/**
 * Recurrence-ID of this object, used for recurrence-exceptions
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.4
 *
 * @name EventComponent#recurrenceId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'recurrenceId',
  iCalendarName: 'RECURRENCE-ID'
});

/**
 * Special color for this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.9
 *
 * @name EventComponent#color
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'color');

/**
 * Creation Time of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.1
 *
 * @name EventComponent#creationTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'creationTime',
  iCalendarName: 'CREATED'
});

/**
 * The time this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.3
 *
 * @name EventComponent#modificationTime
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'modificationTime',
  iCalendarName: 'LAST-MODIFIED'
});

/**
 * Organizer of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
 *
 * @name EventComponent#organizer
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'organizer');

/**
 * Revision of this this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.7.4
 *
 * @name EventComponent#sequence
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'sequence');

/**
 * Status of this event / journal / task
 * This indicates whether an event is tentative / confirmed / cancelled
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.11
 *
 * @name EventComponent#status
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'status');

/**
 * URL of a more dynamic rendition of this event / journal / task
 * DO NOT use this to simply point to a website merely related.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.6
 *
 * @name EventComponent#url
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, 'url');

/**
 * Title of this event / journal / task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.12
 *
 * @name EventComponent#title
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'title',
  iCalendarName: 'SUMMARY'
});

/**
 * Access class of this event / journal / task
 * This determines what other users can see when sharing
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.3
 *
 * @name EventComponent#accessClass
 * @type {string}
 */
advertiseSingleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'accessClass',
  iCalendarName: 'class',
  allowedValues: ['PUBLIC', 'PRIVATE', 'CONFIDENTIAL'],
  defaultValue: 'PUBLIC',
  unknownValue: 'PRIVATE'
});

/**
 * Returns an iterator over all categories
 * If the parameter lang is given, it will only
 * return an iterator for Categories matching that language
 *
 * @name AbstractRecurringComponent#getCategoryIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all categories
 * If the parameter lang is given, it will only
 * return an iterator for Categories matching that language
 *
 * @name AbstractRecurringComponent#getCategoryList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a new category
 *
 * @name AbstractRecurringComponent#addCategory
 * @function
 * @param {string} category
 * @param {string=} lang
 */

/**
 * Removes a category
 *
 * @name AbstractRecurringComponent#removeCategory
 * @function
 * @param {string} category
 * @param {string=} lang
 */

/**
 * Clear all categories of a given language
 *
 * @name AbstractRecurringComponent#clearAllCategories
 * @function
 */
advertiseMultiValueStringPropertySeparatedByLang(AbstractRecurringComponent.prototype, {
  name: 'category',
  pluralName: 'categories',
  iCalendarName: 'CATEGORIES'
});

/**
 * Returns an iterator over all attendees
 *
 * @name AbstractRecurringComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Gets a list of all attendees
 *
 * @name AbstractRecurringComponent#getAttendeeList
 * @function
 * @return {AttachmentProperty[]}
 */

/**
 * Removes an attendee from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee
 */

/**
 * Removes all attendees from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'attendee'
});

/**
 * Returns an iterator over all attachments
 *
 * @name AbstractRecurringComponent#getAttachmentIterator
 * @function
 * @return {IterableIterator<AttachmentProperty>}
 */

/**
 * Gets a list of all attachments
 *
 * @name AbstractRecurringComponent#getAttachmentList
 * @function
 * @return {AttachmentProperty[]}
 */

/**
 * Removes one attachment from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAttachment
 * @function
 * @param {AttachmentProperty} attachment
 */

/**
 * Removes all attachments from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAttachments
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'attachment',
  iCalendarName: 'ATTACH'
});

/**
 * Returns an iterator over all relation properties
 *
 * @name AbstractRecurringComponent#getRelationIterator
 * @function
 * @return {IterableIterator<RelationProperty>}
 */

/**
 * Returns a list of all relation properties
 *
 * @name AbstractRecurringComponent#getRelationList
 * @function
 * @return {RelationProperty[]}
 */

/**
 * Removes a relation from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeRelation
 * @function
 * @param {RelationProperty} relation
 */

/**
 * Removes all relations from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllRelations
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'relation',
  iCalendarName: 'RELATED-TO'
});

/**
 * Returns an iterator over all comments in this event / journal / task
 *
 * @name AbstractRecurringComponent#getCommentIterator
 * @function
 * @return {IterableIterator<TextProperty>}
 */

/**
 * Returns a list of all comments in this event / journal / task
 *
 * @name AbstractRecurringComponent#getCommentList
 * @function
 * @return {TextProperty[]}
 */

/**
 * Removes a comment from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeComment
 * @function
 * @param {TextProperty} comment
 */

/**
 * Removes all comments from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllComments
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'comment');

/**
 * Returns an iterator over all contacts referenced in this event / journal / task
 *
 * @name AbstractRecurringComponent#getContactIterator
 * @function
 * @return {IterableIterator<TextProperty>}
 */

/**
 * Returns a list of all contacts referenced in this event / journal / task
 *
 * @name AbstractRecurringComponent#getContactList
 * @function
 * @return {TextProperty[]}
 */

/**
 * Removes one contact from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeContact
 * @function
 * @param {TextProperty} contact
 */

/**
 * Removes all contacts from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllContacts
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'contact');

/**
 * Returns an iterator over all image properties
 *
 * @name AbstractRecurringComponent#getImageIterator
 * @function
 * @return {IterableIterator<ImageProperty>}
 */

/**
 * Returns a list of all image properties
 *
 * @name AbstractRecurringComponent#getImageList
 * @function
 * @return {ImageProperty[]}
 */

/**
 * Removes one image from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeImage
 * @function
 * @param {ImageProperty} image
 */

/**
 * Removes all images from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllImages
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, 'image');

/**
 * Returns an iterator over all request status
 *
 * @name AbstractRecurringComponent#getRequestStatusIterator
 * @function
 * @return {IterableIterator<RequestStatusProperty>}
 */

/**
 * Returns a list of all request status
 *
 * @name AbstractRecurringComponent#getRequestStatusList
 * @function
 * @return {RequestStatusProperty[]}
 */

/**
 * Removes one request status from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeRequestStatus
 * @function
 * @param {RequestStatusProperty} requestStatus
 */

/**
 * Removes all request status from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllRequestStatus
 * @function
 */
advertiseMultipleOccurrenceProperty(AbstractRecurringComponent.prototype, {
  name: 'requestStatus',
  pluralName: 'requestStatus',
  iCalendarName: 'REQUEST-STATUS'
});

/**
 * Returns an iterator of all alarms
 *
 * @name AbstractRecurringComponent#getAlarmIterator
 * @function
 * @return {IterableIterator<AlarmComponent>}
 */

/**
 * Returns a list of all alarms
 *
 * @name AbstractRecurringComponent#getAlarmList
 * @function
 * @return {AlarmComponent[]}
 */

/**
 * Removes an alarm from this event / journal / task
 *
 * @name AbstractRecurringComponent#removeAlarm
 * @function
 * @param {AlarmComponent} alarm
 */

/**
 * Removes all alarms from this event / journal / task
 *
 * @name AbstractRecurringComponent#clearAllAlarms
 * @function
 */
advertiseComponent(AbstractRecurringComponent.prototype, 'alarm');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets kind of birthday event
 * returns "BDAY", "DEATHDATE", "ANNIVERSARY"
 * or null if this is not a birthday event
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @return {null|string}
 */
function getTypeOfBirthdayEvent(eventComponent) {
  return eventComponent.getFirstPropertyFirstValue('X-NEXTCLOUD-BC-FIELD-TYPE');
}

/**
 * Gets icon for the birthday type
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @return {string|null}
 */
function getIconForBirthday(eventComponent) {
  const birthdayType = getTypeOfBirthdayEvent(eventComponent);
  switch (birthdayType) {
    case 'BDAY':
      return '🎂';
    case 'DEATHDATE':
      return '⚰️';
    case 'ANNIVERSARY':
      return '💍';
    default:
      return null;
  }
}

/**
 * Returns the age of the birthday person or null of no birth-year given
 *
 * @param {EventComponent} eventComponent The eventComponent of the birthday event
 * @param {number} yearOfOccurrence The year to calculate the age for
 * @return {null|number}
 */
function getAgeOfBirthday(eventComponent, yearOfOccurrence) {
  if (!eventComponent.hasProperty('X-NEXTCLOUD-BC-YEAR')) {
    return null;
  }
  const yearOfBirth = eventComponent.getFirstPropertyFirstValue('X-NEXTCLOUD-BC-YEAR');
  return parseInt(yearOfOccurrence, 10) - parseInt(yearOfBirth, 10);
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class EventComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.1
 */
class EventComponent extends AbstractRecurringComponent {
  /**
   * Returns whether this event is an all-day event
   *
   * @return {boolean}
   */
  isAllDay() {
    return this.startDate.isDate && this.endDate.isDate;
  }

  /**
   * Checks whether it's possible to switch from date-time to date or vise-versa
   *
   * @return {boolean}
   */
  canModifyAllDay() {
    return !this.recurrenceManager.masterItem.isRecurring();
  }

  /**
   * Gets the calculated end-date of the event
   *
   * Quote from RFC 5545 3.6.1:
   * The "DTSTART" property for a "VEVENT" specifies the inclusive
   * start of the event.  For recurring events, it also specifies the
   * very first instance in the recurrence set.  The "DTEND" property
   * for a "VEVENT" calendar component specifies the non-inclusive end
   * of the event.  For cases where a "VEVENT" calendar component
   * specifies a "DTSTART" property with a DATE value type but no
   * "DTEND" nor "DURATION" property, the event's duration is taken to
   * be one day.  For cases where a "VEVENT" calendar component
   * specifies a "DTSTART" property with a DATE-TIME value type but no
   * "DTEND" property, the event ends on the same calendar date and
   * time of day specified by the "DTSTART" property.
   *
   * @return {DateTimeValue}
   */
  get endDate() {
    if (this.hasProperty('dtend')) {
      return this.getFirstPropertyFirstValue('dtend');
    }
    const dtend = this.startDate.clone();
    if (this.hasProperty('duration')) {
      dtend.addDuration(this.getFirstPropertyFirstValue('duration'));
    } else if (this.startDate.isDate) {
      dtend.addDuration(DurationValue.fromSeconds(60 * 60 * 24));
    } // There is nothing to do when this event is not allday

    return dtend;
  }

  /**
   * Sets the end time of the event
   *
   * @param {DateTimeValue} end The end of the event
   */
  set endDate(end) {
    this.deleteAllProperties('duration');
    this.updatePropertyWithValue('dtend', end);
  }

  /**
   * Gets the calculated duration of the event
   *
   * @return {DurationValue}
   */
  get duration() {
    if (this.hasProperty('duration')) {
      return this.getFirstPropertyFirstValue('duration');
    }
    return this.startDate.subtractDateWithTimezone(this.endDate);
  }

  /**
   * Sets the calculated duration of the event
   *
   * @param {DurationValue} duration The duration of the event
   */
  set duration(duration) {
    this.deleteAllProperties('dtend');
    this.updatePropertyWithValue('duration', duration);
  }

  /**
   * Sets the geographical position based on latitude and longitude
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
   *
   * @param {number} lat - latitude
   * @param {number} long - longitude
   */
  setGeographicalPositionFromLatitudeAndLongitude(lat, long) {
    this.deleteAllProperties('GEO');
    this.addProperty(GeoProperty.fromPosition(lat, long));
  }

  /**
   * Adds a new conference property based on URI, label and features
   *
   * @url https://tools.ietf.org/html/rfc7986#section-5.11
   *
   * @param {string} uri The URI of the conference system
   * @param {string=} label The label for the conference system
   * @param {string[]=} features The features of the conference system
   */
  addConference(uri, label = null, features = null) {
    this._modify();
    this.addProperty(ConferenceProperty.fromURILabelAndFeatures(uri, label, features));
  }

  /**
   * Adds a duration to the start of the event
   *
   * @param {DurationValue} duration The duration to add
   */
  addDurationToStart(duration) {
    this.startDate.addDuration(duration);
  }

  /**
   * Adds a duration to the end of the event
   *
   * @param {DurationValue} duration The duration to add
   */
  addDurationToEnd(duration) {
    const endDate = this.endDate;
    endDate.addDuration(duration);
    this.endDate = endDate;
  }

  /**
   * Shifts the entire event by the given duration
   *
   * @param {DurationValue} delta The duration to shift event by
   * @param {boolean} allDay Whether the updated event should be all-day or not
   * @param {Timezone} defaultTimezone The default timezone if moving from all-day to timed event
   * @param {DurationValue} defaultAllDayDuration The default all-day duration if moving from timed to all-day
   * @param {DurationValue} defaultTimedDuration The default timed duration if moving from all-day to timed
   */
  shiftByDuration(delta, allDay, defaultTimezone, defaultAllDayDuration, defaultTimedDuration) {
    const currentAllDay = this.isAllDay();
    if (currentAllDay !== allDay && !this.canModifyAllDay()) {
      throw new TypeError('Can\'t modify all-day of this event');
    }
    this.startDate.isDate = allDay;
    this.startDate.addDuration(delta);

    // If this event was moved from the all-day area into the time-grid,
    // then we have to add a timezone and the default duration
    if (currentAllDay && !allDay) {
      this.startDate.replaceTimezone(defaultTimezone);
      this.endDate = this.startDate.clone();
      this.endDate.addDuration(defaultTimedDuration);
    }

    // If this event was moved from the time-grid into the all-day area,
    // then we have to change the default duration
    if (!currentAllDay && allDay) {
      this.endDate = this.startDate.clone();
      this.endDate.addDuration(defaultAllDayDuration);
    }

    // If this event was only moved inside the time-grid or only inside
    // the all-day area, then we only have to adjust the end-date
    if (currentAllDay === allDay) {
      const endDate = this.endDate;
      endDate.addDuration(delta);
      this.endDate = endDate;
    }
  }

  /**
   * Checks if this is a birthday event
   *
   * @return {boolean}
   */
  isBirthdayEvent() {
    return getTypeOfBirthdayEvent(this) === 'BDAY';
  }

  /**
   * Gets the icon to the birthday event
   *
   * @return {string}
   */
  getIconForBirthdayEvent() {
    return getIconForBirthday(this);
  }

  /**
   * Calculates the age of the birthday
   *
   * @return {number}
   */
  getAgeForBirthdayEvent() {
    return getAgeOfBirthday(this, this.startDate.year);
  }

  /**
   * Serializes the entire series to ICS
   *
   * @return {string}
   */
  toICSEntireSeries() {
    return this.root.toICS();
  }

  /**
   * Serializes exactly this recurrence to ICS
   * It removes all recurrence information
   *
   * @return {string}
   */
  toICSThisOccurrence() {
    const clone = this.clone();
    clone.deleteAllProperties('RRULE');
    clone.deleteAllProperties('EXRULE');
    clone.deleteAllProperties('RDATE');
    clone.deleteAllProperties('EXDATE');
    clone.deleteAllProperties('RECURRENCE-ID');
    clone.root = clone.root.constructor.fromEmpty();
    clone.parent = clone.root;
    clone.root.addComponent(clone);
    return clone.root.toICS();
  }

  /**
   * Checks if this event is in a given time-frame
   *
   * @param {DateTimeValue} start Start of time-range to check
   * @param {DateTimeValue} end End of time-range to check
   * @return {boolean}
   */
  isInTimeFrame(start, end) {
    return start.compare(this.endDate) <= 0 && end.compare(this.startDate) >= 0;
  }
}

/**
 * Time-transparency of this event.
 * If set to TRANSPARENT, this event will be ignored for FREE/BUSY calculations.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.7
 *
 * @name EventComponent#timeTransparency
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'timeTransparency',
  iCalendarName: 'TRANSP',
  allowedValues: ['OPAQUE', 'TRANSPARENT'],
  defaultValue: 'OPAQUE'
});

/**
 * Description of this event.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name EventComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, 'description');

/**
 * Geographical position of this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
 *
 * @name EventComponent#geographicalPosition
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'geographicalPosition',
  iCalendarName: 'GEO'
});

/**
 * Location that this event takes place in
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.7
 *
 * @name EventComponent#location
 * @type {string}
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, 'location');

/**
 * Priority of this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.9
 *
 * @name EventComponent#priority
 * @type Number
 */
advertiseSingleOccurrenceProperty(EventComponent.prototype, {
  name: 'priority',
  allowedValues: Array(9).keys(),
  defaultValue: 0,
  unknownValue: 0
});

/**
 * Returns an iterator over all resources
 * If the parameter lang is given, it will only
 * return an iterator for Resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#getResourceIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all resources
 * If the parameter lang is given, it will only
 * return an iterator for resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#getResourceList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#addResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#removeResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes all resources from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name EventComponent#clearAllResources
 * @function
 * @param {string=} lang
 */
advertiseMultiValueStringPropertySeparatedByLang(EventComponent.prototype, {
  name: 'resource',
  iCalendarName: 'RESOURCES'
});

/**
 * Gets an iterator over all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#getConferenceIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#getConferenceList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a conference from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#removeConference
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all conferences from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name EventComponent#clearAllConferences
 * @function
 */
advertiseMultipleOccurrenceProperty(EventComponent.prototype, 'conference');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class FreeBusyComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.4
 */
class FreeBusyComponent extends AbstractComponent {
  /**
   * Gets the start-date of the FreeBusy component
   *
   * @return {DateTimeValue}
   */
  get startDate() {
    return this.getFirstPropertyFirstValue('DTSTART');
  }

  /**
   * Sets the start-date of the FreeBusy component
   *
   * @param {DateTimeValue} startDate The start of the queried time-range
   */
  set startDate(startDate) {
    this._modify();
    this.updatePropertyWithValue('DTSTART', startDate.getInTimezone(Timezone.utc));
  }

  /**
   * Gets the end-date of the FreeBusy component
   *
   * @return {DateTimeValue}
   */
  get endDate() {
    return this.getFirstPropertyFirstValue('DTEND');
  }

  /**
   * Sets the start-date of the FreeBusy component
   *
   * @param {DateTimeValue} endDate The end of the queried time-range
   */
  set endDate(endDate) {
    this._modify();
    this.updatePropertyWithValue('DTEND', endDate.getInTimezone(Timezone.utc));
  }

  /**
   * Gets an iterator over all FreeBusyProperties
   */
  *getFreeBusyIterator() {
    yield* this.getPropertyIterator('FREEBUSY');
  }

  /**
   * Adds a new attendee based on their name and email-address
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
   *
   * @param {string} name The name of the attendee to add
   * @param {string} email The email-address of the attendee to add
   */
  addAttendeeFromNameAndEMail(name, email) {
    this._modify();
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email));
  }

  /**
   * Sets the organiser property from common-name and email address
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
   *
   * @param {string} name The name of the organizer
   * @param {string} email The email-address of the organizer
   */
  setOrganizerFromNameAndEMail(name, email) {
    this._modify();
    this.deleteAllProperties('ORGANIZER');
    this.addProperty(AttendeeProperty.fromNameAndEMail(name, email, true));
  }
}

/**
 * The organizer of this FreeBusy component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.3
 *
 * @name FreeBusyComponent#organizer
 * @type {AttendeeProperty}
 */
advertiseSingleOccurrenceProperty(FreeBusyComponent.prototype, 'organizer');

/**
 * The UID of this FreeBusy component
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.7
 *
 * @name FreeBusyComponent#organizer
 * @type {AttendeeProperty}
 */
advertiseSingleOccurrenceProperty(FreeBusyComponent.prototype, 'uid');

/**
 * Returns an iterator of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#getAttendeeIterator
 * @function
 * @return {IterableIterator<AttendeeProperty>}
 */

/**
 * Returns a list of all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#getAttendeeList
 * @function
 * @return {AttendeeProperty[]}
 */

/**
 * Removes an attendee
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#removeAttendee
 * @function
 * @param {AttendeeProperty} attendee
 */

/**
 * Removes all attendees
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.4.1
 *
 * @name FreeBusyComponent#clearAllAttendees
 * @function
 */
advertiseMultipleOccurrenceProperty(FreeBusyComponent.prototype, 'attendee');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class JournalComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.3
 */
class JournalComponent extends AbstractRecurringComponent {
  /**
   * Adds a new description property
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
   *
   * @param {string} description The description text
   */
  addDescription(description) {
    this.addProperty(new TextProperty('DESCRIPTION', description));
  }
}

/**
 * Gets an iterator over all description properties
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#getDescriptionIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all description properties
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#getDescriptionList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a description from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#removeDescription
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all descriptions from this event
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name JournalComponent#clearAllDescriptions
 * @function
 */
advertiseMultipleOccurrenceProperty(JournalComponent.prototype, 'description');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneComponent
 * @classdesc
 *
 * There are no advertised properties / components for the TimezoneComponent,
 * since we don't care about it.
 * Editing / accessing the timezone information directly is not a use-case
 * All the timezone-handling is done by the underlying ICAL.JS
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.5
 */
class TimezoneComponent extends AbstractComponent {
  /**
   * Returns a calendar-js Timezone object
   *
   * @return {Timezone}
   */
  toTimezone() {
    return new Timezone(this.toICALJs());
  }
}

/**
 * The timezoneId of this timezone-component
 *
 * @name TimezoneComponent#timezoneId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(TimezoneComponent.prototype, {
  name: 'timezoneId',
  iCalendarName: 'tzid'
});

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ToDoComponent
 * @classdesc
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.6.2
 */
class ToDoComponent extends AbstractRecurringComponent {
  /**
   * Returns whether this event is an all-day event
   *
   * @return {boolean}
   */
  isAllDay() {
    const propertiesToCheck = ['DTSTART', 'DUE'];
    for (const propertyToCheck of propertiesToCheck) {
      if (this.hasProperty(propertyToCheck)) {
        return this.getFirstPropertyFirstValue(propertyToCheck).isDate;
      }
    }

    // If a task is not associated with any date, it is defined to
    // occur on any successive date until it is completed.
    // We are treating it as all-day in that case.
    return true;
  }

  /**
   * Checks whether it's possible to switch from date-time to date or vise-versa
   *
   * @return {boolean}
   */
  canModifyAllDay() {
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      return false;
    }
    return !this.recurrenceManager.masterItem.isRecurring();
  }

  /**
   * Gets the calculated end-date of the task
   *
   * If there is a due-date, we will just return that.
   * If there is a start-date and a duration, we will
   * calculate the end-date based on that.
   *
   * If there is neither a due-date nor a combination
   * of start-date and duration, we just return null
   *
   * @return {DateTimeValue|null}
   */
  get endDate() {
    if (this.hasProperty('due')) {
      return this.getFirstPropertyFirstValue('due');
    }
    if (!this.hasProperty('dtstart') || !this.hasProperty('duration')) {
      return null;
    }
    const endDate = this.startDate.clone();
    endDate.addDuration(this.getFirstPropertyFirstValue('duration'));
    return endDate;
  }

  /**
   * Shifts the entire task by the given duration
   *
   * @param {DurationValue} delta The duration to shift event by
   * @param {boolean} allDay Whether the updated event should be all-day or not
   * @param {Timezone} defaultTimezone The default timezone if moving from all-day to timed event
   * @param {DurationValue} defaultAllDayDuration The default all-day duration if moving from timed to all-day
   * @param {DurationValue} defaultTimedDuration The default timed duration if moving from all-day to timed
   */
  shiftByDuration(delta, allDay, defaultTimezone, defaultAllDayDuration, defaultTimedDuration) {
    const currentAllDay = this.isAllDay();
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      throw new TypeError('This task does not have a start-date nor due-date');
    }
    if (currentAllDay !== allDay && !this.canModifyAllDay()) {
      throw new TypeError('Can\'t modify all-day of this todo');
    }

    // If this task has a start-date, update it
    // This is especially important, if you shift
    // the task by a negative duration, because
    // dtstart always has to be prior to the due date
    if (this.hasProperty('dtstart')) {
      this.startDate.isDate = allDay;
      this.startDate.addDuration(delta);
      if (currentAllDay && !allDay) {
        this.startDate.replaceTimezone(defaultTimezone);
      }
    }
    if (this.hasProperty('due')) {
      this.dueTime.isDate = allDay;
      this.dueTime.addDuration(delta);
      if (currentAllDay && !allDay) {
        this.dueTime.replaceTimezone(defaultTimezone);
      }
    }
  }

  /**
   * Checks if this event is in a given time-frame
   *
   * @param {DateTimeValue} start Start of time-range to check
   * @param {DateTimeValue} end End of time-range to check
   * @return {boolean}
   */
  isInTimeFrame(start, end) {
    if (!this.hasProperty('dtstart') && !this.hasProperty('due')) {
      return true;
    }
    if (!this.hasProperty('dtstart') && this.hasProperty('due')) {
      return start.compare(this.endDate) <= 0;
    }
    return start.compare(this.endDate) <= 0 && end.compare(this.startDate) >= 0;
  }

  /**
   * Gets the geographical position property
   *
   * @return {GeoProperty}
   */
  get geographicalPosition() {
    return this.getFirstProperty('GEO');
  }

  /**
   * Sets the geographical position based on latitude and longitude
   *
   * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.6
   *
   * @param {number} lat - latitude
   * @param {number} long - longitude
   */
  setGeographicalPositionFromLatitudeAndLongitude(lat, long) {
    this.deleteAllProperties('GEO');
    this.addProperty(GeoProperty.fromPosition(lat, long));
  }

  /**
   * Adds a new conference property based on URI, label and features
   *
   * @url https://tools.ietf.org/html/rfc7986#section-5.11
   *
   * @param {string} uri The URI of the conference
   * @param {string=} label The label of the conference
   * @param {string[]=} features Supported features of conference-system
   */
  addConference(uri, label = null, features = null) {
    this.addProperty(ConferenceProperty.fromURILabelAndFeatures(uri, label, features));
  }

  /**
   * Gets a recurrence-id that has to be used to refer to this task.
   * This is used for recurrence-management.
   *
   * Gracefully handles the case where a task has no start-date, but a due-date.
   *
   * @return {DateTimeValue|null}
   */
  getReferenceRecurrenceId() {
    return super.getReferenceRecurrenceId() ?? this.endDate;
  }
}

/**
 * The time when a task was completed
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.1
 *
 * @name ToDoComponent#completedTime
 * @type {DateTimeValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'completedTime',
  iCalendarName: 'COMPLETED'
});

/**
 * The time when a task is due
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.3
 *
 * @name ToDoComponent#dueTime
 * @type {DateTimeValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'dueTime',
  iCalendarName: 'DUE'
});

/**
 * The time when a task was completed
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.2.5
 *
 * @name ToDoComponent#duration
 * @type {DurationValue}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'duration'
});

/**
 * The percentage a task was already fulfilled
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.8
 *
 * @name ToDoComponent#percent
 * @type {number}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'percent',
  iCalendarName: 'PERCENT-COMPLETE'
});

/**
 * Description of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.5
 *
 * @name ToDoComponent#description
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, 'description');

/**
 * Location of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.7
 *
 * @name ToDoComponent#location
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, 'location');

/**
 * Priority of this task.
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.9
 *
 * @name ToDoComponent#priority
 * @type {string}
 */
advertiseSingleOccurrenceProperty(ToDoComponent.prototype, {
  name: 'priority',
  allowedValues: Array.from(Array(10).keys()),
  defaultValue: 0,
  unknownValue: 0
});

/**
 * Returns an iterator over all resources
 * If the parameter lang is given, it will only
 * return an iterator for Resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#getResourceIterator
 * @function
 * @param {string=} lang
 * @return {IterableIterator<string>}
 */

/**
 * Returns a list of all resources
 * If the parameter lang is given, it will only
 * return an iterator for resources matching that language
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#getResourceList
 * @function
 * @param {string=} lang
 * @return {string[]}
 */

/**
 * Adds a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#addResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes a resource
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#removeResource
 * @function
 * @param {string} resource
 * @param {string=} lang
 */

/**
 * Removes all resources from this task
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.8.1.10
 *
 * @name ToDoComponent#clearAllResources
 * @function
 * @param {string=} lang
 */
advertiseMultiValueStringPropertySeparatedByLang(ToDoComponent.prototype, {
  name: 'resource',
  iCalendarName: 'RESOURCES'
});

/**
 * Gets an iterator over all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#getConferenceIterator
 * @function
 * @return {IterableIterator<ConferenceProperty>}
 */

/**
 * Gets a list of all conference properties
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#getConferenceList
 * @function
 * @return {ConferenceProperty[]}
 */

/**
 * Removes a conference from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#removeConference
 * @function
 * @param {ConferenceProperty} conference
 */

/**
 * Removes all conferences from this event
 *
 * @url https://tools.ietf.org/html/rfc7986#section-5.11
 *
 * @name ToDoComponent#clearAllConferences
 * @function
 */
advertiseMultipleOccurrenceProperty(ToDoComponent.prototype, 'conference');

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Gets the constructor for a component name
 * This will only return a constructor for components,
 * that can be used in the root of a calendar-document
 *
 * @param {string} compName Name of the component to get constructor for
 * @return {AbstractComponent|ToDoComponent|JournalComponent|FreeBusyComponent|TimezoneComponent|EventComponent}
 */
function getConstructorForComponentName(compName) {
  switch (uc(compName)) {
    case 'VEVENT':
      return EventComponent;
    case 'VFREEBUSY':
      return FreeBusyComponent;
    case 'VJOURNAL':
      return JournalComponent;
    case 'VTIMEZONE':
      return TimezoneComponent;
    case 'VTODO':
      return ToDoComponent;
    default:
      return AbstractComponent;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * This class represents one VCALENDAR block
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.4
 */
class CalendarComponent extends AbstractComponent {
  /**
   * Constructor
   *
   * @inheritDoc
   */
  constructor(name = 'VCALENDAR', properties = [], components = []) {
    super(name, properties, components);
    this.root = this;
    this.parent = null;
  }

  /**
   * Gets an iterator over all VTIMEZONE components
   */
  *getTimezoneIterator() {
    yield* this.getComponentIterator('vtimezone');
  }

  /**
   * Gets an iterator over all VObject components
   */
  *getVObjectIterator() {
    yield* this.getEventIterator();
    yield* this.getJournalIterator();
    yield* this.getTodoIterator();
  }

  /**
   * Gets an iterator over all VEVENT components
   */
  *getEventIterator() {
    yield* this.getComponentIterator('vevent');
  }

  /**
   * Gets an iterator over all VFREEBUSY components
   */
  *getFreebusyIterator() {
    yield* this.getComponentIterator('vfreebusy');
  }

  /**
   * Gets an iterator over all VJOURNAL components
   */
  *getJournalIterator() {
    yield* this.getComponentIterator('vjournal');
  }

  /**
   * Gets an iterator over all VTODO components
   */
  *getTodoIterator() {
    yield* this.getComponentIterator('vtodo');
  }

  /**
   * @inheritDoc
   */
  static _getConstructorForComponentName(componentName) {
    return getConstructorForComponentName(componentName);
  }

  /**
   * Converts this calendar component into text/calendar
   *
   * @param {boolean} cleanUpTimezones Whether or not to clean up timezone data
   * @return {string}
   */
  toICS(cleanUpTimezones = true) {
    for (const vObject of this.getVObjectIterator()) {
      vObject.undirtify();
    }
    const icalRoot = this.toICALJs();
    if (cleanUpTimezones) {
      ical_js__WEBPACK_IMPORTED_MODULE_0___default().helpers.updateTimezones(icalRoot);
    }
    return icalRoot.toString();
  }

  /**
   * Creates a new empty calendar-component
   *
   * @param {[string][]=} additionalProps Additional props to add to empty calendar-document
   * @return {CalendarComponent}
   */
  static fromEmpty(additionalProps = []) {
    return new this('VCALENDAR', [['prodid', getConfig('PRODID', '-//IDN georgehrke.com//calendar-js//EN')], ['calscale', 'GREGORIAN'], ['version', '2.0']].concat(additionalProps));
  }

  /**
   * Creates a new calendar-component with a method
   *
   * @param {string} method The method for the calendar-document
   * @return {CalendarComponent}
   */
  static fromMethod(method) {
    return this.fromEmpty([['method', method]]);
  }

  /**
   * @inheritDoc
   */
  static fromICALJs(icalValue) {
    const comp = super.fromICALJs(icalValue);
    comp.root = comp;
    return comp;
  }
}

/**
 * ProductId representing the software that created this calendar-document
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.3
 *
 * @name CalendarComponent#productId
 * @type {string}
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'productId',
  iCalendarName: 'PRODID'
});

/**
 * iCalendar version of this calendar-document
 * minver and maxver parameters are not supported, since they
 * are virtually used by no calendaring-software
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.4
 *
 * @name CalendarComponent#version
 * @type {string}
 */

advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'version'
});

/**
 * Calendar-scale used in this calendar-document
 * The default and only supported calendar-scale is GREGORIAN.
 * There is an iCalendar-extension about non-gregorian RRULES,
 * but that is not supported by calendar-js at the moment
 *
 * @see https://tools.ietf.org/html/rfc7529
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.1
 *
 * @name CalendarComponent#calendarScale
 * @type {string}
 * @default "GREGORIAN"
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'calendarScale',
  iCalendarName: 'CALSCALE',
  defaultValue: 'GREGORIAN'
});

/**
 * Method of this calendar-document when being used in an iTIP message
 * Please see https://tools.ietf.org/html/rfc5546#section-3.2 for more information
 *
 * @url https://tools.ietf.org/html/rfc5545#section-3.7.2
 *
 * @name CalendarComponent#method
 * @type {string}
 */
advertiseSingleOccurrenceProperty(CalendarComponent.prototype, {
  name: 'method'
});

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class AbstractRepairStep
 * @classdesc A repair step is used to fix calendar-data before it is parsed
 */
class AbstractRepairStep {
  /**
   * @class
   */
  constructor() {
    if (new.target === AbstractRepairStep) {
      throw new TypeError('Cannot instantiate abstract class AbstractRepairStep');
    }
  }

  /**
   * @param {string} input String representation of the data to repair
   */
  repair(input) {
    throw new TypeError('Abstract method not implemented by subclass');
  }

  /**
   * @return {number}
   */
  static priority() {
    return 0;
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingUIDRepairStep
 */
class ICalendarAddMissingUIDRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^BEGIN:(VEVENT|VTODO|VJOURNAL)$(((?!^END:(VEVENT|VTODO|VJOURNAL)$)(?!^UID.*$)(.|\n))*)^END:(VEVENT|VTODO|VJOURNAL)$\n/gm, (match, vobjectName, vObjectBlock) => {
      return 'BEGIN:' + vobjectName + '\r\n' + 'UID:' + (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])() + vObjectBlock + 'END:' + vobjectName + '\r\n';
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingValueDateDoubleColonRepairStep
 */
class ICalendarAddMissingValueDateDoubleColonRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^(DTSTART|DTEND)(.*):([0-9]{8})T(::)$/gm, (match, propName, parameters, date) => {
      return propName + ';VALUE=DATE:' + date;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarAddMissingValueDateRepairStep
 */
class ICalendarAddMissingValueDateRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^(DTSTART|DTEND|EXDATE)(((?!VALUE=DATE).)*):([0-9]{8})$/gm, (match, propName, parameters, _, date) => {
      return propName + parameters + ';VALUE=DATE:' + date;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarEmptyTriggerRepairStep
 * @classdesc This repair step fixes malformed TRIGGER properties
 */
class ICalendarEmptyTriggerRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^TRIGGER:P$/gm, 'TRIGGER:P0D').replace(/^TRIGGER:-P$/gm, 'TRIGGER:P0D');
  }
}

/**
 * @copyright Copyright (c) 2020 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
class ICalendarIllegalCreatedRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/^CREATED:00001231T000000Z$/gm, 'CREATED:19700101T000000Z');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarMultipleVCalendarBlocksRepairStep
 * @classdesc This repair step merges multiple BEGIN:VCALENDAR...END:VCALENDAR blocks
 */
class ICalendarMultipleVCalendarBlocksRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    let containsProdId = false;
    let containsVersion = false;
    let containsCalscale = false;
    const includedTimezones = new Set();
    return ics.replace(/^END:VCALENDAR$(((?!^BEGIN:)(.|\n))*)^BEGIN:VCALENDAR$\n/gm, '').replace(/^PRODID:(.*)$\n/gm, match => {
      if (containsProdId) {
        return '';
      }
      containsProdId = true;
      return match;
    }).replace(/^VERSION:(.*)$\n/gm, match => {
      if (containsVersion) {
        return '';
      }
      containsVersion = true;
      return match;
    }).replace(/^CALSCALE:(.*)$\n/gm, match => {
      if (containsCalscale) {
        return '';
      }
      containsCalscale = true;
      return match;
    }).replace(/^BEGIN:VTIMEZONE$(((?!^END:VTIMEZONE$)(.|\n))*)^END:VTIMEZONE$\n/gm, match => {
      const tzidMatcher = match.match(/^TZID:(.*)$/gm);

      // If this Timezone definition contains no TZID for some reason,
      // just remove it, because we can't use it anyway
      if (tzidMatcher === null) {
        return '';
      }
      const tzid = uc(tzidMatcher[0].slice(5));
      if (includedTimezones.has(tzid)) {
        // If we already included this timezone, just skip
        return '';
      }
      includedTimezones.add(tzid);
      return match;
    });
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarRemoveXNCGroupIdRepairStep
 * @classdesc This repair step removes the X-NC-GroupID parameter used in previous versions of Nextcloud
 */
class ICalendarRemoveXNCGroupIdRepairStep extends AbstractRepairStep {
  /**
   * Please see the corresponding test file for an example of broken calendar-data
   *
   * @inheritDoc
   */
  repair(ics) {
    return ics.replace(/(^.*)(;X-NC-GROUP-ID=\d+)(:.*$)/gm, '$1$3');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Get an iterator over all repair steps for iCalendar documents
 */
function* getRepairSteps() {
  yield ICalendarAddMissingUIDRepairStep;
  yield ICalendarAddMissingValueDateDoubleColonRepairStep;
  yield ICalendarAddMissingValueDateRepairStep;
  yield ICalendarEmptyTriggerRepairStep;
  yield ICalendarIllegalCreatedRepairStep;
  yield ICalendarMultipleVCalendarBlocksRepairStep;
  yield ICalendarRemoveXNCGroupIdRepairStep;
}

var version = "2.2023c";
var aliases = {
	"AUS Central Standard Time": {
		aliasTo: "Australia/Darwin"
	},
	"AUS Eastern Standard Time": {
		aliasTo: "Australia/Sydney"
	},
	"Afghanistan Standard Time": {
		aliasTo: "Asia/Kabul"
	},
	"Africa/Asmera": {
		aliasTo: "Africa/Asmara"
	},
	"Africa/Timbuktu": {
		aliasTo: "Africa/Bamako"
	},
	"Alaskan Standard Time": {
		aliasTo: "America/Anchorage"
	},
	"America/Argentina/ComodRivadavia": {
		aliasTo: "America/Argentina/Catamarca"
	},
	"America/Buenos_Aires": {
		aliasTo: "America/Argentina/Buenos_Aires"
	},
	"America/Louisville": {
		aliasTo: "America/Kentucky/Louisville"
	},
	"America/Montreal": {
		aliasTo: "America/Toronto"
	},
	"America/Santa_Isabel": {
		aliasTo: "America/Tijuana"
	},
	"Arab Standard Time": {
		aliasTo: "Asia/Riyadh"
	},
	"Arabian Standard Time": {
		aliasTo: "Asia/Dubai"
	},
	"Arabic Standard Time": {
		aliasTo: "Asia/Baghdad"
	},
	"Argentina Standard Time": {
		aliasTo: "America/Argentina/Buenos_Aires"
	},
	"Asia/Calcutta": {
		aliasTo: "Asia/Kolkata"
	},
	"Asia/Katmandu": {
		aliasTo: "Asia/Kathmandu"
	},
	"Asia/Rangoon": {
		aliasTo: "Asia/Yangon"
	},
	"Asia/Saigon": {
		aliasTo: "Asia/Ho_Chi_Minh"
	},
	"Atlantic Standard Time": {
		aliasTo: "America/Halifax"
	},
	"Atlantic/Faeroe": {
		aliasTo: "Atlantic/Faroe"
	},
	"Atlantic/Jan_Mayen": {
		aliasTo: "Europe/Oslo"
	},
	"Azerbaijan Standard Time": {
		aliasTo: "Asia/Baku"
	},
	"Azores Standard Time": {
		aliasTo: "Atlantic/Azores"
	},
	"Bahia Standard Time": {
		aliasTo: "America/Bahia"
	},
	"Bangladesh Standard Time": {
		aliasTo: "Asia/Dhaka"
	},
	"Belarus Standard Time": {
		aliasTo: "Europe/Minsk"
	},
	"Canada Central Standard Time": {
		aliasTo: "America/Regina"
	},
	"Cape Verde Standard Time": {
		aliasTo: "Atlantic/Cape_Verde"
	},
	"Caucasus Standard Time": {
		aliasTo: "Asia/Yerevan"
	},
	"Cen. Australia Standard Time": {
		aliasTo: "Australia/Adelaide"
	},
	"Central America Standard Time": {
		aliasTo: "America/Guatemala"
	},
	"Central Asia Standard Time": {
		aliasTo: "Asia/Almaty"
	},
	"Central Brazilian Standard Time": {
		aliasTo: "America/Cuiaba"
	},
	"Central Europe Standard Time": {
		aliasTo: "Europe/Budapest"
	},
	"Central European Standard Time": {
		aliasTo: "Europe/Warsaw"
	},
	"Central Pacific Standard Time": {
		aliasTo: "Pacific/Guadalcanal"
	},
	"Central Standard Time": {
		aliasTo: "America/Chicago"
	},
	"Central Standard Time (Mexico)": {
		aliasTo: "America/Mexico_City"
	},
	"China Standard Time": {
		aliasTo: "Asia/Shanghai"
	},
	"E. Africa Standard Time": {
		aliasTo: "Africa/Nairobi"
	},
	"E. Australia Standard Time": {
		aliasTo: "Australia/Brisbane"
	},
	"E. South America Standard Time": {
		aliasTo: "America/Sao_Paulo"
	},
	"Eastern Standard Time": {
		aliasTo: "America/New_York"
	},
	"Egypt Standard Time": {
		aliasTo: "Africa/Cairo"
	},
	"Ekaterinburg Standard Time": {
		aliasTo: "Asia/Yekaterinburg"
	},
	"Etc/GMT": {
		aliasTo: "UTC"
	},
	"Etc/GMT+0": {
		aliasTo: "UTC"
	},
	"Etc/UCT": {
		aliasTo: "UTC"
	},
	"Etc/UTC": {
		aliasTo: "UTC"
	},
	"Etc/Unversal": {
		aliasTo: "UTC"
	},
	"Etc/Zulu": {
		aliasTo: "UTC"
	},
	"Europe/Belfast": {
		aliasTo: "Europe/London"
	},
	"FLE Standard Time": {
		aliasTo: "Europe/Kiev"
	},
	"Fiji Standard Time": {
		aliasTo: "Pacific/Fiji"
	},
	GMT: {
		aliasTo: "UTC"
	},
	"GMT Standard Time": {
		aliasTo: "Europe/London"
	},
	"GMT+0": {
		aliasTo: "UTC"
	},
	GMT0: {
		aliasTo: "UTC"
	},
	"GTB Standard Time": {
		aliasTo: "Europe/Bucharest"
	},
	"Georgian Standard Time": {
		aliasTo: "Asia/Tbilisi"
	},
	"Greenland Standard Time": {
		aliasTo: "America/Godthab"
	},
	Greenwich: {
		aliasTo: "UTC"
	},
	"Greenwich Standard Time": {
		aliasTo: "Atlantic/Reykjavik"
	},
	"Hawaiian Standard Time": {
		aliasTo: "Pacific/Honolulu"
	},
	"India Standard Time": {
		aliasTo: "Asia/Calcutta"
	},
	"Iran Standard Time": {
		aliasTo: "Asia/Tehran"
	},
	"Israel Standard Time": {
		aliasTo: "Asia/Jerusalem"
	},
	"Jordan Standard Time": {
		aliasTo: "Asia/Amman"
	},
	"Kaliningrad Standard Time": {
		aliasTo: "Europe/Kaliningrad"
	},
	"Korea Standard Time": {
		aliasTo: "Asia/Seoul"
	},
	"Libya Standard Time": {
		aliasTo: "Africa/Tripoli"
	},
	"Line Islands Standard Time": {
		aliasTo: "Pacific/Kiritimati"
	},
	"Magadan Standard Time": {
		aliasTo: "Asia/Magadan"
	},
	"Mauritius Standard Time": {
		aliasTo: "Indian/Mauritius"
	},
	"Middle East Standard Time": {
		aliasTo: "Asia/Beirut"
	},
	"Montevideo Standard Time": {
		aliasTo: "America/Montevideo"
	},
	"Morocco Standard Time": {
		aliasTo: "Africa/Casablanca"
	},
	"Mountain Standard Time": {
		aliasTo: "America/Denver"
	},
	"Mountain Standard Time (Mexico)": {
		aliasTo: "America/Chihuahua"
	},
	"Myanmar Standard Time": {
		aliasTo: "Asia/Rangoon"
	},
	"N. Central Asia Standard Time": {
		aliasTo: "Asia/Novosibirsk"
	},
	"Namibia Standard Time": {
		aliasTo: "Africa/Windhoek"
	},
	"Nepal Standard Time": {
		aliasTo: "Asia/Katmandu"
	},
	"New Zealand Standard Time": {
		aliasTo: "Pacific/Auckland"
	},
	"Newfoundland Standard Time": {
		aliasTo: "America/St_Johns"
	},
	"North Asia East Standard Time": {
		aliasTo: "Asia/Irkutsk"
	},
	"North Asia Standard Time": {
		aliasTo: "Asia/Krasnoyarsk"
	},
	"Pacific SA Standard Time": {
		aliasTo: "America/Santiago"
	},
	"Pacific Standard Time": {
		aliasTo: "America/Los_Angeles"
	},
	"Pacific Standard Time (Mexico)": {
		aliasTo: "America/Santa_Isabel"
	},
	"Pacific/Johnston": {
		aliasTo: "Pacific/Honolulu"
	},
	"Pakistan Standard Time": {
		aliasTo: "Asia/Karachi"
	},
	"Paraguay Standard Time": {
		aliasTo: "America/Asuncion"
	},
	"Romance Standard Time": {
		aliasTo: "Europe/Paris"
	},
	"Russia Time Zone 10": {
		aliasTo: "Asia/Srednekolymsk"
	},
	"Russia Time Zone 11": {
		aliasTo: "Asia/Kamchatka"
	},
	"Russia Time Zone 3": {
		aliasTo: "Europe/Samara"
	},
	"Russian Standard Time": {
		aliasTo: "Europe/Moscow"
	},
	"SA Eastern Standard Time": {
		aliasTo: "America/Cayenne"
	},
	"SA Pacific Standard Time": {
		aliasTo: "America/Bogota"
	},
	"SA Western Standard Time": {
		aliasTo: "America/La_Paz"
	},
	"SE Asia Standard Time": {
		aliasTo: "Asia/Bangkok"
	},
	"Samoa Standard Time": {
		aliasTo: "Pacific/Apia"
	},
	"Singapore Standard Time": {
		aliasTo: "Asia/Singapore"
	},
	"South Africa Standard Time": {
		aliasTo: "Africa/Johannesburg"
	},
	"Sri Lanka Standard Time": {
		aliasTo: "Asia/Colombo"
	},
	"Syria Standard Time": {
		aliasTo: "Asia/Damascus"
	},
	"Taipei Standard Time": {
		aliasTo: "Asia/Taipei"
	},
	"Tasmania Standard Time": {
		aliasTo: "Australia/Hobart"
	},
	"Tokyo Standard Time": {
		aliasTo: "Asia/Tokyo"
	},
	"Tonga Standard Time": {
		aliasTo: "Pacific/Tongatapu"
	},
	"Turkey Standard Time": {
		aliasTo: "Europe/Istanbul"
	},
	UCT: {
		aliasTo: "UTC"
	},
	"US Eastern Standard Time": {
		aliasTo: "America/Indiana/Indianapolis"
	},
	"US Mountain Standard Time": {
		aliasTo: "America/Phoenix"
	},
	"US/Central": {
		aliasTo: "America/Chicago"
	},
	"US/Eastern": {
		aliasTo: "America/New_York"
	},
	"US/Mountain": {
		aliasTo: "America/Denver"
	},
	"US/Pacific": {
		aliasTo: "America/Los_Angeles"
	},
	"US/Pacific-New": {
		aliasTo: "America/Los_Angeles"
	},
	"Ulaanbaatar Standard Time": {
		aliasTo: "Asia/Ulaanbaatar"
	},
	Universal: {
		aliasTo: "UTC"
	},
	"Venezuela Standard Time": {
		aliasTo: "America/Caracas"
	},
	"Vladivostok Standard Time": {
		aliasTo: "Asia/Vladivostok"
	},
	"W. Australia Standard Time": {
		aliasTo: "Australia/Perth"
	},
	"W. Central Africa Standard Time": {
		aliasTo: "Africa/Lagos"
	},
	"W. Europe Standard Time": {
		aliasTo: "Europe/Berlin"
	},
	"West Asia Standard Time": {
		aliasTo: "Asia/Tashkent"
	},
	"West Pacific Standard Time": {
		aliasTo: "Pacific/Port_Moresby"
	},
	"Yakutsk Standard Time": {
		aliasTo: "Asia/Yakutsk"
	},
	Z: {
		aliasTo: "UTC"
	},
	Zulu: {
		aliasTo: "UTC"
	},
	utc: {
		aliasTo: "UTC"
	}
};
var zones = {
	"Africa/Abidjan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0051900",
		longitude: "-0040200"
	},
	"Africa/Accra": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Addis_Ababa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Algiers": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0364700",
		longitude: "+0030300"
	},
	"Africa/Asmara": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Asmera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bamako": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bangui": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Banjul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bissau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0115100",
		longitude: "-0153500"
	},
	"Africa/Blantyre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Brazzaville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Bujumbura": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Cairo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700424T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD"
		],
		latitude: "+0300300",
		longitude: "+0311500"
	},
	"Africa/Casablanca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0333900",
		longitude: "-0073500"
	},
	"Africa/Ceuta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0355300",
		longitude: "-0051900"
	},
	"Africa/Conakry": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Dakar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Dar_es_Salaam": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Djibouti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Douala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/El_Aaiun": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0270900",
		longitude: "-0131200"
	},
	"Africa/Freetown": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Gaborone": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Harare": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Johannesburg": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0261500",
		longitude: "+0280000"
	},
	"Africa/Juba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0045100",
		longitude: "+0313700"
	},
	"Africa/Kampala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Khartoum": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0153600",
		longitude: "+0323200"
	},
	"Africa/Kigali": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Kinshasa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0062700",
		longitude: "+0032400"
	},
	"Africa/Libreville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lome": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Luanda": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lubumbashi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Lusaka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Malabo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Maputo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0255800",
		longitude: "+0323500"
	},
	"Africa/Maseru": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Mbabane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Mogadishu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Monrovia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0061800",
		longitude: "-0104700"
	},
	"Africa/Nairobi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0011700",
		longitude: "+0364900"
	},
	"Africa/Ndjamena": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0120700",
		longitude: "+0150300"
	},
	"Africa/Niamey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Nouakchott": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Ouagadougou": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Porto-Novo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Sao_Tome": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0002000",
		longitude: "+0064400"
	},
	"Africa/Timbuktu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Africa/Tripoli": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0325400",
		longitude: "+0131100"
	},
	"Africa/Tunis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0364800",
		longitude: "+0101100"
	},
	"Africa/Windhoek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0223400",
		longitude: "+0170600"
	},
	"America/Adak": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0515248",
		longitude: "-1763929"
	},
	"America/Anchorage": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0611305",
		longitude: "-1495401"
	},
	"America/Anguilla": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Antigua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Araguaina": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0071200",
		longitude: "-0481200"
	},
	"America/Argentina/Buenos_Aires": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0343600",
		longitude: "-0582700"
	},
	"America/Argentina/Catamarca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0282800",
		longitude: "-0654700"
	},
	"America/Argentina/ComodRivadavia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Argentina/Cordoba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0312400",
		longitude: "-0641100"
	},
	"America/Argentina/Jujuy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0241100",
		longitude: "-0651800"
	},
	"America/Argentina/La_Rioja": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0292600",
		longitude: "-0665100"
	},
	"America/Argentina/Mendoza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0325300",
		longitude: "-0684900"
	},
	"America/Argentina/Rio_Gallegos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0513800",
		longitude: "-0691300"
	},
	"America/Argentina/Salta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0244700",
		longitude: "-0652500"
	},
	"America/Argentina/San_Juan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0313200",
		longitude: "-0683100"
	},
	"America/Argentina/San_Luis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0331900",
		longitude: "-0662100"
	},
	"America/Argentina/Tucuman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0264900",
		longitude: "-0651300"
	},
	"America/Argentina/Ushuaia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0544800",
		longitude: "-0681800"
	},
	"America/Aruba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Asuncion": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701004T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700322T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\r\nEND:STANDARD"
		],
		latitude: "-0251600",
		longitude: "-0574000"
	},
	"America/Atikokan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Atka": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Bahia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0125900",
		longitude: "-0383100"
	},
	"America/Bahia_Banderas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0204800",
		longitude: "-1051500"
	},
	"America/Barbados": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0130600",
		longitude: "-0593700"
	},
	"America/Belem": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0012700",
		longitude: "-0482900"
	},
	"America/Belize": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0173000",
		longitude: "-0881200"
	},
	"America/Blanc-Sablon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Boa_Vista": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0024900",
		longitude: "-0604000"
	},
	"America/Bogota": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0043600",
		longitude: "-0740500"
	},
	"America/Boise": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0433649",
		longitude: "-1161209"
	},
	"America/Buenos_Aires": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cambridge_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0690650",
		longitude: "-1050310"
	},
	"America/Campo_Grande": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0202700",
		longitude: "-0543700"
	},
	"America/Cancun": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0210500",
		longitude: "-0864600"
	},
	"America/Caracas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0103000",
		longitude: "-0665600"
	},
	"America/Catamarca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cayenne": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0045600",
		longitude: "-0522000"
	},
	"America/Cayman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Chicago": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0415100",
		longitude: "-0873900"
	},
	"America/Chihuahua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0283800",
		longitude: "-1060500"
	},
	"America/Ciudad_Juarez": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0314400",
		longitude: "-1062900"
	},
	"America/Coral_Harbour": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cordoba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Costa_Rica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0095600",
		longitude: "-0840500"
	},
	"America/Creston": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Cuiaba": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0153500",
		longitude: "-0560500"
	},
	"America/Curacao": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Danmarkshavn": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0764600",
		longitude: "-0184000"
	},
	"America/Dawson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0640400",
		longitude: "-1392500"
	},
	"America/Dawson_Creek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0554600",
		longitude: "-1201400"
	},
	"America/Denver": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0394421",
		longitude: "-1045903"
	},
	"America/Detroit": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0421953",
		longitude: "-0830245"
	},
	"America/Dominica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Edmonton": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0533300",
		longitude: "-1132800"
	},
	"America/Eirunepe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0064000",
		longitude: "-0695200"
	},
	"America/El_Salvador": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0134200",
		longitude: "-0891200"
	},
	"America/Ensenada": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Fort_Nelson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0584800",
		longitude: "-1224200"
	},
	"America/Fort_Wayne": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Fortaleza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0034300",
		longitude: "-0383000"
	},
	"America/Glace_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0461200",
		longitude: "-0595700"
	},
	"America/Godthab": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"America/Goose_Bay": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0532000",
		longitude: "-0602500"
	},
	"America/Grand_Turk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0212800",
		longitude: "-0710800"
	},
	"America/Grenada": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Guadeloupe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Guatemala": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143800",
		longitude: "-0903100"
	},
	"America/Guayaquil": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0021000",
		longitude: "-0795000"
	},
	"America/Guyana": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0064800",
		longitude: "-0581000"
	},
	"America/Halifax": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0443900",
		longitude: "-0633600"
	},
	"America/Havana": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:CST\r\nDTSTART:19701101T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:CDT\r\nDTSTART:19700308T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0230800",
		longitude: "-0822200"
	},
	"America/Hermosillo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0290400",
		longitude: "-1105800"
	},
	"America/Indiana/Indianapolis": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0394606",
		longitude: "-0860929"
	},
	"America/Indiana/Knox": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0411745",
		longitude: "-0863730"
	},
	"America/Indiana/Marengo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0382232",
		longitude: "-0862041"
	},
	"America/Indiana/Petersburg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0382931",
		longitude: "-0871643"
	},
	"America/Indiana/Tell_City": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0375711",
		longitude: "-0864541"
	},
	"America/Indiana/Vevay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0384452",
		longitude: "-0850402"
	},
	"America/Indiana/Vincennes": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0384038",
		longitude: "-0873143"
	},
	"America/Indiana/Winamac": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0410305",
		longitude: "-0863611"
	},
	"America/Indianapolis": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Inuvik": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0682059",
		longitude: "-1334300"
	},
	"America/Iqaluit": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0634400",
		longitude: "-0682800"
	},
	"America/Jamaica": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0175805",
		longitude: "-0764736"
	},
	"America/Jujuy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Juneau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0581807",
		longitude: "-1342511"
	},
	"America/Kentucky/Louisville": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0381515",
		longitude: "-0854534"
	},
	"America/Kentucky/Monticello": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0364947",
		longitude: "-0845057"
	},
	"America/Knox_IN": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Kralendijk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/La_Paz": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0163000",
		longitude: "-0680900"
	},
	"America/Lima": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0120300",
		longitude: "-0770300"
	},
	"America/Los_Angeles": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0340308",
		longitude: "-1181434"
	},
	"America/Louisville": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Lower_Princes": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Maceio": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0094000",
		longitude: "-0354300"
	},
	"America/Managua": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0120900",
		longitude: "-0861700"
	},
	"America/Manaus": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0030800",
		longitude: "-0600100"
	},
	"America/Marigot": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Martinique": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143600",
		longitude: "-0610500"
	},
	"America/Matamoros": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0255000",
		longitude: "-0973000"
	},
	"America/Mazatlan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0231300",
		longitude: "-1062500"
	},
	"America/Mendoza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Menominee": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0450628",
		longitude: "-0873651"
	},
	"America/Merida": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0205800",
		longitude: "-0893700"
	},
	"America/Metlakatla": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0550737",
		longitude: "-1313435"
	},
	"America/Mexico_City": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0192400",
		longitude: "-0990900"
	},
	"America/Miquelon": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0470300",
		longitude: "-0562000"
	},
	"America/Moncton": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0460600",
		longitude: "-0644700"
	},
	"America/Monterrey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0254000",
		longitude: "-1001900"
	},
	"America/Montevideo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0345433",
		longitude: "-0561245"
	},
	"America/Montreal": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Montserrat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Nassau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/New_York": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0404251",
		longitude: "-0740023"
	},
	"America/Nipigon": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Nome": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0643004",
		longitude: "-1652423"
	},
	"America/Noronha": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0035100",
		longitude: "-0322500"
	},
	"America/North_Dakota/Beulah": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0471551",
		longitude: "-1014640"
	},
	"America/North_Dakota/Center": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0470659",
		longitude: "-1011757"
	},
	"America/North_Dakota/New_Salem": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0465042",
		longitude: "-1012439"
	},
	"America/Nuuk": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0641100",
		longitude: "-0514400"
	},
	"America/Ojinaga": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0293400",
		longitude: "-1042500"
	},
	"America/Panama": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0085800",
		longitude: "-0793200"
	},
	"America/Pangnirtung": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Paramaribo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0055000",
		longitude: "-0551000"
	},
	"America/Phoenix": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0332654",
		longitude: "-1120424"
	},
	"America/Port-au-Prince": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0183200",
		longitude: "-0722000"
	},
	"America/Port_of_Spain": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Porto_Acre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Porto_Velho": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0084600",
		longitude: "-0635400"
	},
	"America/Puerto_Rico": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0182806",
		longitude: "-0660622"
	},
	"America/Punta_Arenas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0530900",
		longitude: "-0705500"
	},
	"America/Rainy_River": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Rankin_Inlet": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0624900",
		longitude: "-0920459"
	},
	"America/Recife": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0080300",
		longitude: "-0345400"
	},
	"America/Regina": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0502400",
		longitude: "-1043900"
	},
	"America/Resolute": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0744144",
		longitude: "-0944945"
	},
	"America/Rio_Branco": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0095800",
		longitude: "-0674800"
	},
	"America/Rosario": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Santa_Isabel": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Santarem": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0022600",
		longitude: "-0545200"
	},
	"America/Santiago": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0332700",
		longitude: "-0704000"
	},
	"America/Santo_Domingo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0182800",
		longitude: "-0695400"
	},
	"America/Sao_Paulo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0233200",
		longitude: "-0463700"
	},
	"America/Scoresbysund": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0702900",
		longitude: "-0215800"
	},
	"America/Shiprock": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Sitka": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0571035",
		longitude: "-1351807"
	},
	"America/St_Barthelemy": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Johns": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0473400",
		longitude: "-0524300"
	},
	"America/St_Kitts": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Lucia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Thomas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/St_Vincent": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Swift_Current": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0501700",
		longitude: "-1075000"
	},
	"America/Tegucigalpa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0140600",
		longitude: "-0871300"
	},
	"America/Thule": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0763400",
		longitude: "-0684700"
	},
	"America/Thunder_Bay": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"America/Tijuana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0323200",
		longitude: "-1170100"
	},
	"America/Toronto": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0433900",
		longitude: "-0792300"
	},
	"America/Tortola": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Vancouver": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0491600",
		longitude: "-1230700"
	},
	"America/Virgin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"America/Whitehorse": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0604300",
		longitude: "-1350300"
	},
	"America/Winnipeg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0495300",
		longitude: "-0970900"
	},
	"America/Yakutat": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0593249",
		longitude: "-1394338"
	},
	"America/Yellowknife": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Casey": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0661700",
		longitude: "+1103100"
	},
	"Antarctica/Davis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0683500",
		longitude: "+0775800"
	},
	"Antarctica/DumontDUrville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Antarctica/Macquarie": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0543000",
		longitude: "+1585700"
	},
	"Antarctica/Mawson": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0673600",
		longitude: "+0625300"
	},
	"Antarctica/McMurdo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Palmer": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0644800",
		longitude: "-0640600"
	},
	"Antarctica/Rothera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0673400",
		longitude: "-0680800"
	},
	"Antarctica/South_Pole": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Antarctica/Syowa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Antarctica/Troll": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0200\r\nTZNAME:+02\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "-0720041",
		longitude: "+0023206"
	},
	"Antarctica/Vostok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Arctic/Longyearbyen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Asia/Aden": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Almaty": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0431500",
		longitude: "+0765700"
	},
	"Asia/Amman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0315700",
		longitude: "+0355600"
	},
	"Asia/Anadyr": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0644500",
		longitude: "+1772900"
	},
	"Asia/Aqtau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0443100",
		longitude: "+0501600"
	},
	"Asia/Aqtobe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0501700",
		longitude: "+0571000"
	},
	"Asia/Ashgabat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0375700",
		longitude: "+0582300"
	},
	"Asia/Ashkhabad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Atyrau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0470700",
		longitude: "+0515600"
	},
	"Asia/Baghdad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0332100",
		longitude: "+0442500"
	},
	"Asia/Bahrain": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Baku": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0402300",
		longitude: "+0495100"
	},
	"Asia/Bangkok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0134500",
		longitude: "+1003100"
	},
	"Asia/Barnaul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0532200",
		longitude: "+0834500"
	},
	"Asia/Beirut": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0335300",
		longitude: "+0353000"
	},
	"Asia/Bishkek": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0425400",
		longitude: "+0743600"
	},
	"Asia/Brunei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Calcutta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Chita": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0520300",
		longitude: "+1132800"
	},
	"Asia/Choibalsan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0480400",
		longitude: "+1143000"
	},
	"Asia/Chongqing": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Chungking": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Colombo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:+0530\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0065600",
		longitude: "+0795100"
	},
	"Asia/Dacca": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Damascus": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0333000",
		longitude: "+0361800"
	},
	"Asia/Dhaka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0234300",
		longitude: "+0902500"
	},
	"Asia/Dili": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0083300",
		longitude: "+1253500"
	},
	"Asia/Dubai": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0251800",
		longitude: "+0551800"
	},
	"Asia/Dushanbe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0383500",
		longitude: "+0684800"
	},
	"Asia/Famagusta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0350700",
		longitude: "+0335700"
	},
	"Asia/Gaza": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT"
		],
		latitude: "+0313000",
		longitude: "+0342800"
	},
	"Asia/Harbin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Hebron": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT"
		],
		latitude: "+0313200",
		longitude: "+0350542"
	},
	"Asia/Ho_Chi_Minh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0104500",
		longitude: "+1064000"
	},
	"Asia/Hong_Kong": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:HKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0221700",
		longitude: "+1140900"
	},
	"Asia/Hovd": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0480100",
		longitude: "+0913900"
	},
	"Asia/Irkutsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0521600",
		longitude: "+1042000"
	},
	"Asia/Istanbul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Jakarta": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0061000",
		longitude: "+1064800"
	},
	"Asia/Jayapura": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:WIT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0023200",
		longitude: "+1404200"
	},
	"Asia/Jerusalem": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0314650",
		longitude: "+0351326"
	},
	"Asia/Kabul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0343100",
		longitude: "+0691200"
	},
	"Asia/Kamchatka": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0530100",
		longitude: "+1583900"
	},
	"Asia/Karachi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:PKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0245200",
		longitude: "+0670300"
	},
	"Asia/Kashgar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Kathmandu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0274300",
		longitude: "+0851900"
	},
	"Asia/Katmandu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Khandyga": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0623923",
		longitude: "+1353314"
	},
	"Asia/Kolkata": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0223200",
		longitude: "+0882200"
	},
	"Asia/Krasnoyarsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0560100",
		longitude: "+0925000"
	},
	"Asia/Kuala_Lumpur": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Kuching": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0013300",
		longitude: "+1102000"
	},
	"Asia/Kuwait": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Macao": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Macau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0221150",
		longitude: "+1133230"
	},
	"Asia/Magadan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0593400",
		longitude: "+1504800"
	},
	"Asia/Makassar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0050700",
		longitude: "+1192400"
	},
	"Asia/Manila": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0143500",
		longitude: "+1210000"
	},
	"Asia/Muscat": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Nicosia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0351000",
		longitude: "+0332200"
	},
	"Asia/Novokuznetsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0534500",
		longitude: "+0870700"
	},
	"Asia/Novosibirsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0550200",
		longitude: "+0825500"
	},
	"Asia/Omsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0550000",
		longitude: "+0732400"
	},
	"Asia/Oral": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0511300",
		longitude: "+0512100"
	},
	"Asia/Phnom_Penh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Pontianak": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0000200",
		longitude: "+1092000"
	},
	"Asia/Pyongyang": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0390100",
		longitude: "+1254500"
	},
	"Asia/Qatar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0251700",
		longitude: "+0513200"
	},
	"Asia/Qostanay": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0531200",
		longitude: "+0633700"
	},
	"Asia/Qyzylorda": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0444800",
		longitude: "+0652800"
	},
	"Asia/Rangoon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Riyadh": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0243800",
		longitude: "+0464300"
	},
	"Asia/Saigon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Sakhalin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0465800",
		longitude: "+1424200"
	},
	"Asia/Samarkand": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0394000",
		longitude: "+0664800"
	},
	"Asia/Seoul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0373300",
		longitude: "+1265800"
	},
	"Asia/Shanghai": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0311400",
		longitude: "+1212800"
	},
	"Asia/Singapore": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0011700",
		longitude: "+1035100"
	},
	"Asia/Srednekolymsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0672800",
		longitude: "+1534300"
	},
	"Asia/Taipei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0250300",
		longitude: "+1213000"
	},
	"Asia/Tashkent": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0412000",
		longitude: "+0691800"
	},
	"Asia/Tbilisi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0414300",
		longitude: "+0444900"
	},
	"Asia/Tehran": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0330\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0354000",
		longitude: "+0512600"
	},
	"Asia/Tel_Aviv": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Asia/Thimbu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Thimphu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0272800",
		longitude: "+0893900"
	},
	"Asia/Tokyo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:JST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0353916",
		longitude: "+1394441"
	},
	"Asia/Tomsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0563000",
		longitude: "+0845800"
	},
	"Asia/Ujung_Pandang": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Ulaanbaatar": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0475500",
		longitude: "+1065300"
	},
	"Asia/Ulan_Bator": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Urumqi": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0434800",
		longitude: "+0873500"
	},
	"Asia/Ust-Nera": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0643337",
		longitude: "+1431336"
	},
	"Asia/Vientiane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Asia/Vladivostok": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0431000",
		longitude: "+1315600"
	},
	"Asia/Yakutsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0620000",
		longitude: "+1294000"
	},
	"Asia/Yangon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0164700",
		longitude: "+0961000"
	},
	"Asia/Yekaterinburg": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0565100",
		longitude: "+0603600"
	},
	"Asia/Yerevan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0401100",
		longitude: "+0443000"
	},
	"Atlantic/Azores": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0374400",
		longitude: "-0254000"
	},
	"Atlantic/Bermuda": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "+0321700",
		longitude: "-0644600"
	},
	"Atlantic/Canary": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0280600",
		longitude: "-0152400"
	},
	"Atlantic/Cape_Verde": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0145500",
		longitude: "-0233100"
	},
	"Atlantic/Faeroe": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Atlantic/Faroe": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0620100",
		longitude: "-0064600"
	},
	"Atlantic/Jan_Mayen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Atlantic/Madeira": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0323800",
		longitude: "-0165400"
	},
	"Atlantic/Reykjavik": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Atlantic/South_Georgia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0541600",
		longitude: "-0363200"
	},
	"Atlantic/St_Helena": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Atlantic/Stanley": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0514200",
		longitude: "-0575100"
	},
	"Australia/ACT": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Adelaide": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0345500",
		longitude: "+1383500"
	},
	"Australia/Brisbane": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0272800",
		longitude: "+1530200"
	},
	"Australia/Broken_Hill": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0315700",
		longitude: "+1412700"
	},
	"Australia/Canberra": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Currie": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Australia/Darwin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0122800",
		longitude: "+1305000"
	},
	"Australia/Eucla": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0845\r\nTZOFFSETTO:+0845\r\nTZNAME:+0845\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0314300",
		longitude: "+1285200"
	},
	"Australia/Hobart": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0425300",
		longitude: "+1471900"
	},
	"Australia/LHI": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Lindeman": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0201600",
		longitude: "+1490000"
	},
	"Australia/Lord_Howe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0313300",
		longitude: "+1590500"
	},
	"Australia/Melbourne": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0374900",
		longitude: "+1445800"
	},
	"Australia/NSW": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/North": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/Perth": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0315700",
		longitude: "+1155100"
	},
	"Australia/Queensland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/South": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/Sydney": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		],
		latitude: "-0335200",
		longitude: "+1511300"
	},
	"Australia/Tasmania": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Australia/Victoria": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Australia/West": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Australia/Yancowinna": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Brazil/Acre": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/DeNoronha": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/East": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Brazil/West": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Canada/Atlantic": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Central": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Eastern": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Mountain": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Newfoundland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
		]
	},
	"Canada/Pacific": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Canada/Saskatchewan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Canada/Yukon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Chile/Continental": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
		]
	},
	"Chile/EasterIsland": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Amsterdam": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Andorra": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0423000",
		longitude: "+0013100"
	},
	"Europe/Astrakhan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0462100",
		longitude: "+0480300"
	},
	"Europe/Athens": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0375800",
		longitude: "+0234300"
	},
	"Europe/Belfast": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Belgrade": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0445000",
		longitude: "+0203000"
	},
	"Europe/Berlin": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0523000",
		longitude: "+0132200"
	},
	"Europe/Bratislava": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Brussels": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0505000",
		longitude: "+0042000"
	},
	"Europe/Bucharest": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0442600",
		longitude: "+0260600"
	},
	"Europe/Budapest": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0473000",
		longitude: "+0190500"
	},
	"Europe/Busingen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Chisinau": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0470000",
		longitude: "+0285000"
	},
	"Europe/Copenhagen": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Dublin": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:IST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0532000",
		longitude: "-0061500"
	},
	"Europe/Gibraltar": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0360800",
		longitude: "-0052100"
	},
	"Europe/Guernsey": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Helsinki": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0601000",
		longitude: "+0245800"
	},
	"Europe/Isle_of_Man": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Istanbul": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0410100",
		longitude: "+0285800"
	},
	"Europe/Jersey": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Kaliningrad": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0544300",
		longitude: "+0203000"
	},
	"Europe/Kiev": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Kirov": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0583600",
		longitude: "+0493900"
	},
	"Europe/Kyiv": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0502600",
		longitude: "+0303100"
	},
	"Europe/Lisbon": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		],
		latitude: "+0384300",
		longitude: "-0090800"
	},
	"Europe/Ljubljana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/London": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0513030",
		longitude: "+0000731"
	},
	"Europe/Luxembourg": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Madrid": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0402400",
		longitude: "-0034100"
	},
	"Europe/Malta": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0355400",
		longitude: "+0143100"
	},
	"Europe/Mariehamn": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Minsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0535400",
		longitude: "+0273400"
	},
	"Europe/Monaco": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Moscow": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0554521",
		longitude: "+0373704"
	},
	"Europe/Nicosia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Oslo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Paris": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0485200",
		longitude: "+0022000"
	},
	"Europe/Podgorica": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Prague": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0500500",
		longitude: "+0142600"
	},
	"Europe/Riga": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0565700",
		longitude: "+0240600"
	},
	"Europe/Rome": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0415400",
		longitude: "+0122900"
	},
	"Europe/Samara": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0531200",
		longitude: "+0500900"
	},
	"Europe/San_Marino": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Sarajevo": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Saratov": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0513400",
		longitude: "+0460200"
	},
	"Europe/Simferopol": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0445700",
		longitude: "+0340600"
	},
	"Europe/Skopje": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Sofia": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0424100",
		longitude: "+0231900"
	},
	"Europe/Stockholm": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Tallinn": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0592500",
		longitude: "+0244500"
	},
	"Europe/Tirane": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0412000",
		longitude: "+0195000"
	},
	"Europe/Tiraspol": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Ulyanovsk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0542000",
		longitude: "+0482400"
	},
	"Europe/Uzhgorod": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Vaduz": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Vatican": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Vienna": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0481300",
		longitude: "+0162000"
	},
	"Europe/Vilnius": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0544100",
		longitude: "+0251900"
	},
	"Europe/Volgograd": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0484400",
		longitude: "+0442500"
	},
	"Europe/Warsaw": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0521500",
		longitude: "+0210000"
	},
	"Europe/Zagreb": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		]
	},
	"Europe/Zaporozhye": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
		]
	},
	"Europe/Zurich": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
		],
		latitude: "+0472300",
		longitude: "+0083200"
	},
	"Indian/Antananarivo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Chagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0072000",
		longitude: "+0722500"
	},
	"Indian/Christmas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Cocos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Comoro": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Kerguelen": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Mahe": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Maldives": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0041000",
		longitude: "+0733000"
	},
	"Indian/Mauritius": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0201000",
		longitude: "+0573000"
	},
	"Indian/Mayotte": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Indian/Reunion": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Mexico/BajaNorte": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"Mexico/BajaSur": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Mexico/General": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Apia": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0135000",
		longitude: "-1714400"
	},
	"Pacific/Auckland": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0365200",
		longitude: "+1744600"
	},
	"Pacific/Bougainville": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0061300",
		longitude: "+1553400"
	},
	"Pacific/Chatham": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1245\r\nTZOFFSETTO:+1345\r\nTZNAME:+1345\r\nDTSTART:19700927T024500\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1345\r\nTZOFFSETTO:+1245\r\nTZNAME:+1245\r\nDTSTART:19700405T034500\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0435700",
		longitude: "-1763300"
	},
	"Pacific/Chuuk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Easter": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
		],
		latitude: "-0270900",
		longitude: "-1092600"
	},
	"Pacific/Efate": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0174000",
		longitude: "+1682500"
	},
	"Pacific/Enderbury": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Fakaofo": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0092200",
		longitude: "-1711400"
	},
	"Pacific/Fiji": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0180800",
		longitude: "+1782500"
	},
	"Pacific/Funafuti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Galapagos": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0005400",
		longitude: "-0893600"
	},
	"Pacific/Gambier": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0900\r\nTZNAME:-09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0230800",
		longitude: "-1345700"
	},
	"Pacific/Guadalcanal": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0093200",
		longitude: "+1601200"
	},
	"Pacific/Guam": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0132800",
		longitude: "+1444500"
	},
	"Pacific/Honolulu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0211825",
		longitude: "-1575130"
	},
	"Pacific/Johnston": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Kanton": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0024700",
		longitude: "-1714300"
	},
	"Pacific/Kiritimati": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0015200",
		longitude: "-1572000"
	},
	"Pacific/Kosrae": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0051900",
		longitude: "+1625900"
	},
	"Pacific/Kwajalein": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0090500",
		longitude: "+1672000"
	},
	"Pacific/Majuro": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Marquesas": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0930\r\nTZOFFSETTO:-0930\r\nTZNAME:-0930\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0090000",
		longitude: "-1393000"
	},
	"Pacific/Midway": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Nauru": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0003100",
		longitude: "+1665500"
	},
	"Pacific/Niue": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:-11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0190100",
		longitude: "-1695500"
	},
	"Pacific/Norfolk": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
		],
		latitude: "-0290300",
		longitude: "+1675800"
	},
	"Pacific/Noumea": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0221600",
		longitude: "+1662700"
	},
	"Pacific/Pago_Pago": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0141600",
		longitude: "-1704200"
	},
	"Pacific/Palau": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0072000",
		longitude: "+1342900"
	},
	"Pacific/Pitcairn": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:-08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0250400",
		longitude: "-1300500"
	},
	"Pacific/Pohnpei": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Ponape": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Port_Moresby": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0093000",
		longitude: "+1471000"
	},
	"Pacific/Rarotonga": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0211400",
		longitude: "-1594600"
	},
	"Pacific/Saipan": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Samoa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Tahiti": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0173200",
		longitude: "-1493400"
	},
	"Pacific/Tarawa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "+0012500",
		longitude: "+1730000"
	},
	"Pacific/Tongatapu": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		],
		latitude: "-0210800",
		longitude: "-1751200"
	},
	"Pacific/Truk": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Wake": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Wallis": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"Pacific/Yap": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Alaska": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Aleutian": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Arizona": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Central": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/East-Indiana": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Eastern": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Hawaii": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	},
	"US/Indiana-Starke": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Michigan": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Mountain": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Pacific": {
		ics: [
			"BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
		]
	},
	"US/Samoa": {
		ics: [
			"BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
		]
	}
};
var tzData = {
	version: version,
	aliases: aliases,
	zones: zones
};

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneManager
 */
class TimezoneManager {
  /**
   * Constructor
   */
  constructor() {
    /**
     * Map of aliases
     * Alias name => timezoneId
     *
     * @type {Map<string, string>}
     */
    this._aliases = new Map();

    /**
     * Map of Timezones
     * timezoneId => Timezone
     *
     * @type {Map<string, Timezone>}
     * @private
     */
    this._timezones = new Map();
  }

  /**
   * Gets a timezone for the given id
   *
   * @param {string} timezoneId The id of the timezone
   * @return {Timezone|null}
   */
  getTimezoneForId(timezoneId) {
    return this._getTimezoneForIdRec(timezoneId, 0);
  }
  _getTimezoneForIdRec(timezoneId, level) {
    if (this._timezones.has(timezoneId)) {
      return this._timezones.get(timezoneId);
    }
    if (level >= 20) {
      // too much recursion
      console.error('TimezoneManager.getTimezoneForIdRec() exceeds recursion limits');
      return null;
    }
    if (this._aliases.has(timezoneId)) {
      const resolvedTimezoneId = this._aliases.get(timezoneId);
      // can be a recursive alias:
      return this._getTimezoneForIdRec(resolvedTimezoneId, level + 1);
    }
    return null;
  }

  /**
   * Checks if there is a timezone for the given id stored in this manager
   *
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  hasTimezoneForId(timezoneId) {
    return this._timezones.has(timezoneId) || this._aliases.has(timezoneId);
  }

  /**
   * Checks if the given timezone id is an alias
   *
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  isAlias(timezoneId) {
    return !this._timezones.has(timezoneId) && this._aliases.has(timezoneId);
  }

  /**
   * Lists all timezones
   *
   * @param {boolean=} includeAliases Whether or not to include aliases
   * @return {string[]}
   */
  listAllTimezones(includeAliases = false) {
    const timezones = Array.from(this._timezones.keys());
    if (includeAliases) {
      return timezones.concat(Array.from(this._aliases.keys()));
    }
    return timezones;
  }

  /**
   * Registers a timezone
   *
   * @param {Timezone} timezone The timezone-object to register
   */
  registerTimezone(timezone) {
    this._timezones.set(timezone.timezoneId, timezone);
  }
  registerDefaultTimezones() {
    console.debug(`@nextcloud/calendar-js app is using version ${tzData.version} of the timezone database`);
    for (const tzid in tzData.zones) {
      if (Object.prototype.hasOwnProperty.call(tzData.zones, [tzid])) {
        const ics = ['BEGIN:VTIMEZONE', 'TZID:' + tzid, ...tzData.zones[tzid].ics, 'END:VTIMEZONE'].join('\r\n');
        this.registerTimezoneFromICS(tzid, ics);
      }
    }
    for (const tzid in tzData.aliases) {
      if (Object.prototype.hasOwnProperty.call(tzData.aliases, [tzid])) {
        this.registerAlias(tzid, tzData.aliases[tzid].aliasTo);
      }
    }
  }

  /**
   * Registers a timezone based on ics data
   *
   * @param {string} timezoneId The id of the timezone
   * @param {string} ics The iCalendar timezone definition
   */
  registerTimezoneFromICS(timezoneId, ics) {
    const timezone = new Timezone(timezoneId, ics);
    this.registerTimezone(timezone);
  }

  /**
   * Registers a new timezone-alias
   *
   * @param {string} aliasName The timezone-id of the alias
   * @param {string} timezoneId The timezone-id to resolve the alias to
   */
  registerAlias(aliasName, timezoneId) {
    this._aliases.set(aliasName, timezoneId);
  }

  /**
   * Unregisters a timezone
   *
   * @param {string} timezoneId Unregisters a timezone by Id
   */
  unregisterTimezones(timezoneId) {
    this._timezones.delete(timezoneId);
  }

  /**
   * Unregisters a timezone-alias
   *
   * @param {string} aliasName The alias to unregister
   */
  unregisterAlias(aliasName) {
    this._aliases.delete(aliasName);
  }

  /**
   * Clear all timezones
   */
  clearAllTimezones() {
    this._aliases = new Map();
    this._timezones = new Map();
    timezoneManager.registerTimezone(Timezone.utc);
    timezoneManager.registerTimezone(Timezone.floating);
    timezoneManager.registerAlias('GMT', Timezone.utc.timezoneId);
    timezoneManager.registerAlias('Z', Timezone.utc.timezoneId);
  }
}
const timezoneManager = new TimezoneManager();
timezoneManager.clearAllTimezones();

/**
 * Gets the default instance of the timezone manager
 *
 * @return {TimezoneManager}
 */
function getTimezoneManager() {
  return timezoneManager;
}

/**
 *
 * @param {string} tzName Name of the timezone to check
 * @return {boolean}
 */
function isOlsonTimezone(tzName) {
  const hasSlash = tzName.indexOf('/') !== -1;
  const hasSpace = tzName.indexOf(' ') !== -1;
  const startsWithETC = tzName.startsWith('Etc');
  const startsWithUS = tzName.startsWith('US/');
  return hasSlash && !hasSpace && !startsWithETC && !startsWithUS;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ICalendarParser
 * @classdesc
 */
class ICalendarParser extends AbstractParser {
  /**
   * @inheritDoc
   */
  constructor(...args) {
    super(...args);

    /**
     * The raw text/calendar data
     *
     * @type {string}
     * @protected
     */
    this._rawData = null;

    /**
     * The CalendarComponent representing the raw data
     *
     * @type {CalendarComponent}
     * @protected
     */
    this._calendarComponent = null;

    /**
     * A flag whether this calendar-data contains vevents
     *
     * @type {boolean}
     * @private
     */
    this._containsVEvents = false;

    /**
     * A flag whether this calendar-data contains vjournals
     *
     * @type {boolean}
     * @private
     */
    this._containsVJournals = false;

    /**
     * A flag whether this calendar-data contains vtodos
     *
     * @type {boolean}
     * @private
     */
    this._containsVTodos = false;

    /**
     * A flag whether this calendar-data contains vfreebusy
     *
     * @type {boolean}
     * @private
     */
    this._containsVFreeBusy = false;

    /**
     * A map containing all VObjects.
     * The key of this map is the UID
     * The value an array of all VObjects with that particular UID
     *
     * @type {Map<string, AbstractRecurringComponent[]>}
     * @private
     */
    this._items = new Map();

    /**
     * Items that are no recurrence-exceptions
     * The key of this map is the UID
     *
     * @type {Map<string, AbstractRecurringComponent>}
     * @private
     */
    this._masterItems = new Map();

    /**
     * Items that are recurrence exceptions
     *
     * @type {Map<string, AbstractRecurringComponent[]>}
     * @private
     */
    this._recurrenceExceptionItems = new Map();

    /**
     * Some recurrence-exceptions come without a master item
     * In that case we need to forge a master item
     *
     * @type {Map<string, AbstractRecurringComponent>}
     * @private
     */
    this._forgedMasterItems = new Map();

    /**
     * A list of timezone-components found in the calendar-data
     *
     * @type {Map<string, Timezone>}
     * @private
     */
    this._timezones = new Map();

    /**
     * A set of required timezones for each UID
     *
     * @type {Map<string, Set<string>>}
     * @private
     */
    this._requiredTimezones = new Map();

    /**
     * Instance of the default timezone-manager
     *
     * @type {TimezoneManager}
     * @private
     */
    this._defaultTimezoneManager = getTimezoneManager();
  }

  /**
   * Parses the actual calendar-data
   *
   * @param {string} ics The icalendar data to parse
   */
  parse(ics) {
    this._rawData = ics;
    this._applyRepairSteps();

    // If a timezone is not inside our TimezoneManager at the time of parsing
    // the internal zone will be marked as floating inside ICAL.Time
    // so before we start any actual parsing, we need to extract all timezones
    // and add them to the TimezoneManager
    this._extractTimezones();
    this._registerTimezones();
    this._createCalendarComponent();
    if (this._getOption('extractGlobalProperties', false)) {
      this._extractProperties();
    }
    this._processVObjects();
    if (this._getOption('processFreeBusy', false)) {
      this._processVFreeBusy();
    }
  }

  /**
   * @inheritDoc
   */
  *getItemIterator() {
    for (const itemList of this._items.values()) {
      const calendarComp = CalendarComponent.fromEmpty();
      if (this._getOption('includeTimezones', false)) {
        this._addRequiredTimezonesToCalendarComp(calendarComp, itemList[0].uid);
      }

      // Preserve the original product id, just in case we need special handling for certain clients later on ...
      if (this._calendarComponent.hasProperty('PRODID')) {
        calendarComp.deleteAllProperties('PRODID');
        calendarComp.addProperty(this._calendarComponent.getFirstProperty('PRODID').clone());
      }
      if (this._getOption('preserveMethod', false)) {
        if (this._calendarComponent.hasProperty('METHOD')) {
          calendarComp.deleteAllProperties('METHOD');
          calendarComp.addProperty(this._calendarComponent.getFirstProperty('METHOD').clone());
        }
      }
      for (const item of itemList) {
        calendarComp.addComponent(item);
      }
      yield calendarComp;
    }
  }

  /**
   * @inheritDoc
   */
  containsVEvents() {
    return this._containsVEvents;
  }

  /**
   * @inheritDoc
   */
  containsVJournals() {
    return this._containsVJournals;
  }

  /**
   * @inheritDoc
   */
  containsVTodos() {
    return this._containsVTodos;
  }

  /**
   * @inheritDoc
   */
  containsVFreeBusy() {
    return this._containsVFreeBusy;
  }

  /**
   * @inheritDoc
   */
  getItemCount() {
    return Array.from(this._items.keys()).length;
  }

  /**
   * Applies all registered repair steps
   *
   * @private
   */
  _applyRepairSteps() {
    for (const RepairStep of getRepairSteps()) {
      const step = new RepairStep();
      this._rawData = step.repair(this._rawData);
    }
  }

  /**
   * Creates a calendar component based upon the repaired data
   *
   * @private
   */
  _createCalendarComponent() {
    const jCal = ical_js__WEBPACK_IMPORTED_MODULE_0___default().parse(this._rawData);
    const icalComp = new (ical_js__WEBPACK_IMPORTED_MODULE_0___default().Component)(jCal);
    this._calendarComponent = CalendarComponent.fromICALJs(icalComp);
  }

  /**
   * extracts properties
   *
   * @protected
   */
  _extractProperties() {
    this._extractPropertyAndPutResultIntoVariable(['name', 'x-wr-calname'], '_name');
    this._extractPropertyAndPutResultIntoVariable(['color', 'x-apple-calendar-color'], '_color');
    this._extractPropertyAndPutResultIntoVariable(['source'], '_sourceURL');
    this._extractPropertyAndPutResultIntoVariable(['refresh-interval', 'x-published-ttl'], '_refreshInterval');
    this._extractPropertyAndPutResultIntoVariable(['x-wr-timezone'], '_calendarTimezone');
  }

  /**
   * Extract a property and writes it into a class property
   * names must be an array, it will use the value of the fist
   * propertyname it can find
   *
   * @param {string[]} names The names of the properties to check
   * @param {string} variableName The variable name to save it under
   * @private
   */
  _extractPropertyAndPutResultIntoVariable(names, variableName) {
    for (const name of names) {
      if (this._calendarComponent.hasProperty(name)) {
        this[variableName] = this._calendarComponent.getFirstPropertyFirstValue(name);
        return;
      }
    }
  }

  /**
   * Extracts timezones from the calendar component
   *
   * @protected
   */
  _extractTimezones() {
    const matches = this._rawData.match(/^BEGIN:VTIMEZONE$(((?!^END:VTIMEZONE$)(.|\n))*)^END:VTIMEZONE$\n/gm);
    if (!matches) {
      return;
    }
    for (const match of matches) {
      const tzidMatcher = match.match(/^TZID:(.*)$/gm);
      if (!tzidMatcher) {
        continue;
      }
      const tzid = tzidMatcher[0].slice(5);
      const timezone = new Timezone(tzid, match);
      this._timezones.set(tzid, timezone);
    }
  }

  /**
   * Registers unknown timezones into our timezone-manager
   *
   * @protected
   */
  _registerTimezones() {
    for (const [tzid, timezone] of this._timezones) {
      if (!this._defaultTimezoneManager.hasTimezoneForId(tzid)) {
        this._defaultTimezoneManager.registerTimezone(timezone);
      }
    }
  }

  /**
   * Processes the parsed vobjects
   *
   * @protected
   */
  _processVObjects() {
    for (const vObject of this._calendarComponent.getVObjectIterator()) {
      this._addItem(vObject);
      this._markCompTypeAsSeen(vObject.name);
      if (vObject.isRecurrenceException()) {
        this._addRecurrenceException(vObject);
      } else {
        vObject.recurrenceManager = new RecurrenceManager(vObject);
        this._masterItems.set(vObject.uid, vObject);
      }
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (value instanceof DateTimeValue && value.timezoneId) {
            this._addRequiredTimezone(vObject.uid, value.timezoneId);
          }
        }
      }

      // TRIGGER is supposed to be stored in UTC only,
      // but not all clients stick to this
      for (const alarm of vObject.getAlarmIterator()) {
        for (const propertyToCheck of alarm.getPropertyIterator()) {
          for (const value of propertyToCheck.getValueIterator()) {
            if (value instanceof DateTimeValue && value.timezoneId) {
              this._addRequiredTimezone(vObject.uid, value.timezoneId);
            }
          }
        }
      }
      if (this._getOption('removeRSVPForAttendees', false)) {
        for (const attendee of vObject.getAttendeeIterator()) {
          attendee.deleteParameter('RSVP');
        }
      }
    }
    for (const recurrenceExceptionList of this._recurrenceExceptionItems.values()) {
      for (const recurrenceException of recurrenceExceptionList) {
        // Check if there is a master item for this recurrence exception
        // otherwise we have to forge one
        if (!this._masterItems.has(recurrenceException.uid)) {
          const constructor = getConstructorForComponentName(recurrenceException.name);
          const forgedMaster = new constructor(recurrenceException.name, [['UID', recurrenceException.uid], ['DTSTAMP', recurrenceException.stampTime.clone()], ['DTSTART', recurrenceException.recurrenceId.clone()]]);
          forgedMaster.recurrenceManager = new RecurrenceManager(forgedMaster);
          this._forgedMasterItems.set(recurrenceException.uid, forgedMaster);
          this._masterItems.set(recurrenceException.uid, forgedMaster);
          this._addItem(forgedMaster);
        } else {
          const master = this._masterItems.get(recurrenceException.uid);

          // This should usually not be the case,
          // only if the calendar-data is seriously broken.
          // Let's try to handle it anyway by adding it to
          // forgedMasterItems, we will simply add RDATEs
          // in the next step to make it recur
          if (!master.isRecurring()) {
            this._forgedMasterItems.set(master.uid, master);
          }
        }
        if (this._forgedMasterItems.has(recurrenceException.uid)) {
          const forgedMaster = this._forgedMasterItems.get(recurrenceException.uid);
          forgedMaster.recurrenceManager.addRecurrenceDate(false, recurrenceException.recurrenceId.clone());
        }
        const masterItem = this._masterItems.get(recurrenceException.uid);
        masterItem.recurrenceManager.relateRecurrenceException(recurrenceException);
      }
    }
  }

  /**
   * Process FreeBusy components
   *
   * @private
   */
  _processVFreeBusy() {
    for (const vObject of this._calendarComponent.getFreebusyIterator()) {
      this._addItem(vObject);
      this._markCompTypeAsSeen(vObject.name);
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (value instanceof DateTimeValue && value.timezoneId) {
            this._addRequiredTimezone(vObject.uid, value.timezoneId);
          }
        }
      }
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} item The recurrence-item to register
   * @private
   */
  _addRecurrenceException(item) {
    if (this._recurrenceExceptionItems.has(item.uid)) {
      const arr = this._recurrenceExceptionItems.get(item.uid);
      arr.push(item);
    } else {
      this._recurrenceExceptionItems.set(item.uid, [item]);
    }
  }

  /**
   *
   * @param {AbstractRecurringComponent} item The item to register
   * @private
   */
  _addItem(item) {
    if (this._items.has(item.uid)) {
      const arr = this._items.get(item.uid);
      arr.push(item);
    } else {
      this._items.set(item.uid, [item]);
    }
  }

  /**
   *
   * @param {string} uid The uid of the calendar-object
   * @param {string} timezoneId The timezoneId required by the object
   * @private
   */
  _addRequiredTimezone(uid, timezoneId) {
    if (timezoneId === 'UTC' || timezoneId === 'floating' || timezoneId === 'GMT' || timezoneId === 'Z') {
      return;
    }
    if (this._requiredTimezones.has(uid)) {
      this._requiredTimezones.get(uid).add(timezoneId);
    } else {
      const set = new Set([timezoneId]);
      this._requiredTimezones.set(uid, set);
    }
  }

  /**
   *
   * @param {CalendarComponent} calendarComp The calendar-component to add timezones to
   * @param {string} uid The UID of the calendar-object
   * @private
   */
  _addRequiredTimezonesToCalendarComp(calendarComp, uid) {
    if (!this._requiredTimezones.has(uid)) {
      return;
    }
    for (const requiredTimezone of this._requiredTimezones.get(uid)) {
      if (!this._defaultTimezoneManager.hasTimezoneForId(requiredTimezone)) {
        return;
      }
      const timezone = this._defaultTimezoneManager.getTimezoneForId(requiredTimezone);
      // Is this an alias?
      if (timezone.timezoneId !== requiredTimezone) {
        this._replaceTimezoneWithAnotherOne(calendarComp, requiredTimezone, timezone.timezoneId);
      }
      const timezoneComponent = TimezoneComponent.fromICALJs(timezone.toICALJs());
      calendarComp.addComponent(timezoneComponent);
    }
  }

  /**
   * Replaces all occurrences of searchTimezone with replaceTimezone
   *
   * @param {CalendarComponent} calendarComponent The calendar-component to replace a timezone in
   * @param {string} searchTimezone The timezone to replace
   * @param {string} replaceTimezone The replacement timezone
   * @private
   */
  _replaceTimezoneWithAnotherOne(calendarComponent, searchTimezone, replaceTimezone) {
    for (const vObject of this._calendarComponent.getVObjectIterator()) {
      for (const propertyToCheck of vObject.getPropertyIterator()) {
        for (const value of propertyToCheck.getValueIterator()) {
          if (!(value instanceof DateTimeValue)) {
            continue;
          }
          if (value.timezoneId === searchTimezone) {
            value.silentlyReplaceTimezone(replaceTimezone);
          }
        }
      }

      // TRIGGER is supposed to be stored in UTC only,
      // but not all clients stick to this
      for (const alarm of vObject.getAlarmIterator()) {
        for (const propertyToCheck of alarm.getPropertyIterator()) {
          for (const value of propertyToCheck.getValueIterator()) {
            if (!(value instanceof DateTimeValue)) {
              continue;
            }
            if (value.timezoneId === searchTimezone) {
              value.silentlyReplaceTimezone(replaceTimezone);
            }
          }
        }
      }
    }
  }

  /**
   * Marks a certain component type as seen.
   * This is used for
   * containsVEvents()
   * containsVJournals()
   * containsVTodos()
   *
   * @param {string} compName The name of the visited component
   * @private
   */
  _markCompTypeAsSeen(compName) {
    switch (uc(compName)) {
      case 'VEVENT':
        this._containsVEvents = true;
        break;
      case 'VJOURNAL':
        this._containsVJournals = true;
        break;
      case 'VTODO':
        this._containsVTodos = true;
        break;
      case 'VFREEBUSY':
        this._containsVFreeBusy = true;
        break;
    }
  }

  /**
   * @inheritDoc
   */
  static getMimeTypes() {
    return ['text/calendar'];
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class ParserManager
 * @classdesc
 */
class ParserManager {
  /**
   * Constructor
   */
  constructor() {
    /**
     * List of supported parsers
     *
     * @type {Function[]}
     */
    this._parsers = [];
  }

  /**
   * Get a list of all supported file-types
   *
   * @return {string[]}
   */
  getAllSupportedFileTypes() {
    return this._parsers.reduce((allFileTypes, parser) => allFileTypes.concat(parser.getMimeTypes()), []);
  }

  /**
   * Get an instance of a parser for one specific file-type
   *
   * @param {string} fileType The mime-type to get a parser for
   * @param {object=} options Options destructuring object
   * @param {boolean=} options.extractGlobalProperties Whether or not to preserve properties from the VCALENDAR component (defaults to false)
   * @param {boolean=} options.removeRSVPForAttendees Whether or not to remove RSVP from attendees (defaults to false)
   * @param {boolean=} options.includeTimezones Whether or not to include timezones (defaults to false)
   * @param {boolean=} options.preserveMethod Whether or not to preserve the iCalendar method (defaults to false)
   * @param {boolean=} options.processFreeBusy Whether or not to process VFreeBusy components (defaults to false)
   *
   * @return {AbstractParser}
   */
  getParserForFileType(fileType, options) {
    const Parser = this._parsers.find(parser => parser.getMimeTypes().includes(fileType));
    if (!Parser) {
      throw new TypeError('Unknown file-type.');
    }
    return new Parser(options);
  }

  /**
   * Registers a parser
   *
   * @param {Function} parser The parser to register
   */
  registerParser(parser) {
    this._parsers.push(parser);
  }
}

/**
 * Gets an instance of the ParserManager with all default parsers
 *
 * @return {ParserManager}
 */
function getParserManager() {
  const parserManager = new ParserManager();

  // We only support iCalendar for now.
  // JSON calendar and CSV will be supported soon,
  // but require some more work

  parserManager.registerParser(ICalendarParser);
  // parserManager.registerParser(JCalendarParser)
  // parserManager.registerParser(CSVParser)

  return parserManager;
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @class TimezoneAdapter
 * @classdesc Connecting ICAL.TimezoneService with our TimezoneManager
 */
class TimezoneAdapter {
  /**
   * Constructor
   *
   * @param {TimezoneManager} timezoneManager The timezone-manager to wrap
   */
  constructor(timezoneManager) {
    /**
     * TimezoneManager object
     *
     * @type {TimezoneManager}
     * @private
     */
    this._timezoneManager = timezoneManager;
  }

  /**
   * @param {string} timezoneId The id of the timezone
   * @return {boolean}
   */
  has(timezoneId) {
    return this._timezoneManager.hasTimezoneForId(timezoneId);
  }

  /**
   * @param {string} timezoneId The id of the timezone
   * @return {ICAL.Timezone|undefined}
   */
  get(timezoneId) {
    const timezone = this._timezoneManager.getTimezoneForId(timezoneId);
    if (!timezone) {
      return undefined;
    }
    return timezone.toICALTimezone();
  }

  /**
   * @throws TypeError
   */
  register() {
    throw new TypeError('Not allowed to register new timezone');
  }

  /**
   * @throws TypeError
   */
  remove() {
    throw new TypeError('Not allowed to remove timezone');
  }

  /**
   * @throws TypeError
   */
  reset() {
    throw new TypeError('Not allowed to reset TimezoneService');
  }
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

class IllegalValueError extends Error {}

/**
 * @copyright Copyright (c) 2021 Christoph Wurst
 *
 * @author Christoph Wurst <christoph@winzerhof-wurst.at>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 *
 * @param {string[]} timezoneList List of Olsen timezones
 * @param {Array} additionalTimezones List of additional timezones
 * @param {string} globalTimezoneName The localized name of the "Global" timezones
 * @return {[]}
 */
function getSortedTimezoneList(timezoneList = [], additionalTimezones = [], globalTimezoneName = 'Global') {
  const sortedByContinent = {};
  const sortedList = [];
  for (const timezoneId of timezoneList) {
    const components = timezoneId.split('/');
    let [continent, name] = [components.shift(), components.join('/')];
    if (!name) {
      name = continent;
      continent = globalTimezoneName;
    }
    sortedByContinent[continent] = sortedByContinent[continent] || {
      continent,
      regions: []
    };
    sortedByContinent[continent].regions.push({
      label: getReadableTimezoneName(name),
      cities: [],
      timezoneId
    });
  }
  for (const additionalTimezone of additionalTimezones) {
    const {
      continent,
      label,
      timezoneId
    } = additionalTimezone;
    sortedByContinent[continent] = sortedByContinent[continent] || {
      continent,
      regions: []
    };
    sortedByContinent[continent].regions.push({
      label,
      cities: [],
      timezoneId
    });
  }
  for (const continent in sortedByContinent) {
    if (!Object.prototype.hasOwnProperty.call(sortedByContinent, continent)) {
      continue;
    }
    sortedByContinent[continent].regions.sort((a, b) => {
      if (a.label < b.label) {
        return -1;
      }
      return 1;
    });
    sortedList.push(sortedByContinent[continent]);
  }

  // Sort continents by name
  sortedList.sort((a, b) => {
    if (a.continent < b.continent) {
      return -1;
    }
    return 1;
  });
  return sortedList;
}

/**
 * Get human-readable name for timezoneId
 *
 * @param {string} timezoneId TimezoneId to turn human-readable
 * @return {string}
 */
function getReadableTimezoneName(timezoneId) {
  return timezoneId.split('_').join(' ').replace('St ', 'St. ').split('/').join(' - ');
}

/**
 * @copyright Copyright (c) 2019 Georg Ehrke
 *
 * @author Georg Ehrke <georg-nextcloud@ehrke.email>
 *
 * @author Richard Steinmetz <richard@steinmetz.cloud>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
if (!((ical_js__WEBPACK_IMPORTED_MODULE_0___default().TimezoneService) instanceof TimezoneAdapter)) {
  (ical_js__WEBPACK_IMPORTED_MODULE_0___default().TimezoneService) = new TimezoneAdapter(getTimezoneManager());
}

/**
 * parses a single ICS and returns an iterator over all occurrences
 * in a given timeframe
 *
 * @param {string} ics The calendar-data to parse
 * @param {DateTimeValue} start The start of the queried time-range
 * @param {DateTimeValue} end The end of the queried time-range
 */
function* parseICSAndGetAllOccurrencesBetween(ics, start, end) {
  const parserManager = getParserManager();
  const icsParser = parserManager.getParserForFileType('text/calendar');
  icsParser.parse(ics);
  const objectIterator = icsParser.getItemIterator();
  const calendarComp = objectIterator.next().value;
  if (calendarComp === undefined) {
    return;
  }
  const vObjectIterator = calendarComp.getVObjectIterator();
  const firstVObject = vObjectIterator.next().value;
  if (firstVObject === undefined) {
    return;
  }
  yield* firstVObject.recurrenceManager.getAllOccurrencesBetweenIterator(start, end);
}

/**
 * Creates a new event
 *
 * @param {DateTimeValue} start Start-time of the new event
 * @param {DateTimeValue} end End-time of the new event
 * @return {CalendarComponent}
 */
function createEvent(start, end) {
  const calendar = CalendarComponent.fromEmpty();
  const eventComponent = new EventComponent('VEVENT');
  eventComponent.updatePropertyWithValue('CREATED', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('LAST-MODIFIED', DateTimeValue.fromJSDate(dateFactory(), true));
  eventComponent.updatePropertyWithValue('SEQUENCE', 0);
  eventComponent.updatePropertyWithValue('UID', (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])());
  eventComponent.updatePropertyWithValue('DTSTART', start);
  eventComponent.updatePropertyWithValue('DTEND', end);
  calendar.addComponent(eventComponent);
  eventComponent.recurrenceManager = new RecurrenceManager(eventComponent);
  return calendar;
}

/**
 * Creates a FreeBusy Request to be used on the scheduling outbox
 *
 * @param {DateTimeValue} start The start of the queried time-range
 * @param {DateTimeValue} end The end of the queried time-range
 * @param {AttendeeProperty} organizer The organizer querying information
 * @param {AttendeeProperty[]}attendees The list of attendees to query information for
 * @return {CalendarComponent}
 */
function createFreeBusyRequest(start, end, organizer, attendees) {
  const calendar = CalendarComponent.fromMethod('REQUEST');
  const freeBusyComponent = new FreeBusyComponent('VFREEBUSY');
  freeBusyComponent.updatePropertyWithValue('DTSTAMP', DateTimeValue.fromJSDate(dateFactory(), true));
  freeBusyComponent.updatePropertyWithValue('UID', (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])());
  freeBusyComponent.updatePropertyWithValue('DTSTART', start.clone().getInUTC());
  freeBusyComponent.updatePropertyWithValue('DTEND', end.clone().getInUTC());
  freeBusyComponent.addProperty(organizer.clone());
  for (const attendee of attendees) {
    const clonedAttendee = attendee.clone();
    clonedAttendee.deleteParameter('ROLE');
    clonedAttendee.deleteParameter('CUTYPE');
    clonedAttendee.deleteParameter('RSVP');
    clonedAttendee.deleteParameter('PARTSTAT');
    clonedAttendee.deleteParameter('REQUEST-STATUS');
    clonedAttendee.deleteParameter('LANGUAGE');
    freeBusyComponent.addProperty(clonedAttendee);
  }
  calendar.addComponent(freeBusyComponent);
  return calendar;
}


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/date-format-parse/es/format.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-format-parse/es/format.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/date-format-parse/es/util.js");
/* harmony import */ var _locale_en__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale/en */ "./node_modules/date-format-parse/es/locale/en.js");


var REGEX_FORMAT = /\[([^\]]+)]|YYYY|YY?|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|Z{1,2}|S{1,3}|w{1,2}|x|X|a|A/g;

function pad(val) {
  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var output = "".concat(Math.abs(val));
  var sign = val < 0 ? '-' : '';

  while (output.length < len) {
    output = "0".concat(output);
  }

  return sign + output;
}

function getOffset(date) {
  return Math.round(date.getTimezoneOffset() / 15) * 15;
}

function formatTimezone(offset) {
  var delimeter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  return sign + pad(hours, 2) + delimeter + pad(minutes, 2);
}

var meridiem = function meridiem(h, _, isLowercase) {
  var word = h < 12 ? 'AM' : 'PM';
  return isLowercase ? word.toLocaleLowerCase() : word;
};

var formatFlags = {
  Y: function Y(date) {
    var y = date.getFullYear();
    return y <= 9999 ? "".concat(y) : "+".concat(y);
  },
  // Year: 00, 01, ..., 99
  YY: function YY(date) {
    return pad(date.getFullYear(), 4).substr(2);
  },
  // Year: 1900, 1901, ..., 2099
  YYYY: function YYYY(date) {
    return pad(date.getFullYear(), 4);
  },
  // Month: 1, 2, ..., 12
  M: function M(date) {
    return date.getMonth() + 1;
  },
  // Month: 01, 02, ..., 12
  MM: function MM(date) {
    return pad(date.getMonth() + 1, 2);
  },
  MMM: function MMM(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MMMM: function MMMM(date, locale) {
    return locale.months[date.getMonth()];
  },
  // Day of month: 1, 2, ..., 31
  D: function D(date) {
    return date.getDate();
  },
  // Day of month: 01, 02, ..., 31
  DD: function DD(date) {
    return pad(date.getDate(), 2);
  },
  // Hour: 0, 1, ... 23
  H: function H(date) {
    return date.getHours();
  },
  // Hour: 00, 01, ..., 23
  HH: function HH(date) {
    return pad(date.getHours(), 2);
  },
  // Hour: 1, 2, ..., 12
  h: function h(date) {
    var hours = date.getHours();

    if (hours === 0) {
      return 12;
    }

    if (hours > 12) {
      return hours % 12;
    }

    return hours;
  },
  // Hour: 01, 02, ..., 12
  hh: function hh() {
    var hours = formatFlags.h.apply(formatFlags, arguments);
    return pad(hours, 2);
  },
  // Minute: 0, 1, ..., 59
  m: function m(date) {
    return date.getMinutes();
  },
  // Minute: 00, 01, ..., 59
  mm: function mm(date) {
    return pad(date.getMinutes(), 2);
  },
  // Second: 0, 1, ..., 59
  s: function s(date) {
    return date.getSeconds();
  },
  // Second: 00, 01, ..., 59
  ss: function ss(date) {
    return pad(date.getSeconds(), 2);
  },
  // 1/10 of second: 0, 1, ..., 9
  S: function S(date) {
    return Math.floor(date.getMilliseconds() / 100);
  },
  // 1/100 of second: 00, 01, ..., 99
  SS: function SS(date) {
    return pad(Math.floor(date.getMilliseconds() / 10), 2);
  },
  // Millisecond: 000, 001, ..., 999
  SSS: function SSS(date) {
    return pad(date.getMilliseconds(), 3);
  },
  // Day of week: 0, 1, ..., 6
  d: function d(date) {
    return date.getDay();
  },
  // Day of week: 'Su', 'Mo', ..., 'Sa'
  dd: function dd(date, locale) {
    return locale.weekdaysMin[date.getDay()];
  },
  // Day of week: 'Sun', 'Mon',..., 'Sat'
  ddd: function ddd(date, locale) {
    return locale.weekdaysShort[date.getDay()];
  },
  // Day of week: 'Sunday', 'Monday', ...,'Saturday'
  dddd: function dddd(date, locale) {
    return locale.weekdays[date.getDay()];
  },
  // AM, PM
  A: function A(date, locale) {
    var meridiemFunc = locale.meridiem || meridiem;
    return meridiemFunc(date.getHours(), date.getMinutes(), false);
  },
  // am, pm
  a: function a(date, locale) {
    var meridiemFunc = locale.meridiem || meridiem;
    return meridiemFunc(date.getHours(), date.getMinutes(), true);
  },
  // Timezone: -01:00, +00:00, ... +12:00
  Z: function Z(date) {
    return formatTimezone(getOffset(date), ':');
  },
  // Timezone: -0100, +0000, ... +1200
  ZZ: function ZZ(date) {
    return formatTimezone(getOffset(date));
  },
  // Seconds timestamp: 512969520
  X: function X(date) {
    return Math.floor(date.getTime() / 1000);
  },
  // Milliseconds timestamp: 512969520900
  x: function x(date) {
    return date.getTime();
  },
  w: function w(date, locale) {
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.getWeek)(date, {
      firstDayOfWeek: locale.firstDayOfWeek,
      firstWeekContainsDate: locale.firstWeekContainsDate
    });
  },
  ww: function ww(date, locale) {
    return pad(formatFlags.w(date, locale), 2);
  }
};
function format(val, str) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var formatStr = str ? String(str) : 'YYYY-MM-DDTHH:mm:ss.SSSZ';
  var date = (0,_util__WEBPACK_IMPORTED_MODULE_0__.toDate)(val);

  if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isValidDate)(date)) {
    return 'Invalid Date';
  }

  var locale = options.locale || _locale_en__WEBPACK_IMPORTED_MODULE_1__["default"];
  return formatStr.replace(REGEX_FORMAT, function (match, p1) {
    if (p1) {
      return p1;
    }

    if (typeof formatFlags[match] === 'function') {
      return "".concat(formatFlags[match](date, locale));
    }

    return match;
  });
}

/***/ }),

/***/ "./node_modules/date-format-parse/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-format-parse/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_0__.format),
/* harmony export */   getWeek: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_2__.getWeek),
/* harmony export */   isDate: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_2__.isDate),
/* harmony export */   isValidDate: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_2__.isValidDate),
/* harmony export */   parse: () => (/* reexport safe */ _parse__WEBPACK_IMPORTED_MODULE_1__.parse),
/* harmony export */   toDate: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_2__.toDate)
/* harmony export */ });
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format */ "./node_modules/date-format-parse/es/format.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse */ "./node_modules/date-format-parse/es/parse.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/date-format-parse/es/util.js");




/***/ }),

/***/ "./node_modules/date-format-parse/es/locale/en.js":
/*!********************************************************!*\
  !*** ./node_modules/date-format-parse/es/locale/en.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var locale = {
  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  weekdaysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  firstDayOfWeek: 0,
  firstWeekContainsDate: 1
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),

/***/ "./node_modules/date-format-parse/es/parse.js":
/*!****************************************************!*\
  !*** ./node_modules/date-format-parse/es/parse.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _locale_en__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale/en */ "./node_modules/date-format-parse/es/locale/en.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/date-format-parse/es/util.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var formattingTokens = /(\[[^\[]*\])|(MM?M?M?|Do|DD?|ddd?d?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|S{1,3}|x|X|ZZ?|.)/g;
var match1 = /\d/; // 0 - 9

var match2 = /\d\d/; // 00 - 99

var match3 = /\d{3}/; // 000 - 999

var match4 = /\d{4}/; // 0000 - 9999

var match1to2 = /\d\d?/; // 0 - 99

var matchShortOffset = /[+-]\d\d:?\d\d/; // +00:00 -00:00 +0000 or -0000

var matchSigned = /[+-]?\d+/; // -inf - inf

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
// const matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i; // Word

var YEAR = 'year';
var MONTH = 'month';
var DAY = 'day';
var HOUR = 'hour';
var MINUTE = 'minute';
var SECOND = 'second';
var MILLISECOND = 'millisecond';
var parseFlags = {};

var addParseFlag = function addParseFlag(token, regex, callback) {
  var tokens = Array.isArray(token) ? token : [token];
  var func;

  if (typeof callback === 'string') {
    func = function func(input) {
      var value = parseInt(input, 10);
      return _defineProperty({}, callback, value);
    };
  } else {
    func = callback;
  }

  tokens.forEach(function (key) {
    parseFlags[key] = [regex, func];
  });
};

var escapeStringRegExp = function escapeStringRegExp(str) {
  return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
};

var matchWordRegExp = function matchWordRegExp(localeKey) {
  return function (locale) {
    var array = locale[localeKey];

    if (!Array.isArray(array)) {
      throw new Error("Locale[".concat(localeKey, "] need an array"));
    }

    return new RegExp(array.map(escapeStringRegExp).join('|'));
  };
};

var matchWordCallback = function matchWordCallback(localeKey, key) {
  return function (input, locale) {
    var array = locale[localeKey];

    if (!Array.isArray(array)) {
      throw new Error("Locale[".concat(localeKey, "] need an array"));
    }

    var index = array.indexOf(input);

    if (index < 0) {
      throw new Error('Invalid Word');
    }

    return _defineProperty({}, key, index);
  };
};

addParseFlag('Y', matchSigned, YEAR);
addParseFlag('YY', match2, function (input) {
  var year = new Date().getFullYear();
  var cent = Math.floor(year / 100);
  var value = parseInt(input, 10);
  value = (value > 68 ? cent - 1 : cent) * 100 + value;
  return _defineProperty({}, YEAR, value);
});
addParseFlag('YYYY', match4, YEAR);
addParseFlag('M', match1to2, function (input) {
  return _defineProperty({}, MONTH, parseInt(input, 10) - 1);
});
addParseFlag('MM', match2, function (input) {
  return _defineProperty({}, MONTH, parseInt(input, 10) - 1);
});
addParseFlag('MMM', matchWordRegExp('monthsShort'), matchWordCallback('monthsShort', MONTH));
addParseFlag('MMMM', matchWordRegExp('months'), matchWordCallback('months', MONTH));
addParseFlag('D', match1to2, DAY);
addParseFlag('DD', match2, DAY);
addParseFlag(['H', 'h'], match1to2, HOUR);
addParseFlag(['HH', 'hh'], match2, HOUR);
addParseFlag('m', match1to2, MINUTE);
addParseFlag('mm', match2, MINUTE);
addParseFlag('s', match1to2, SECOND);
addParseFlag('ss', match2, SECOND);
addParseFlag('S', match1, function (input) {
  return _defineProperty({}, MILLISECOND, parseInt(input, 10) * 100);
});
addParseFlag('SS', match2, function (input) {
  return _defineProperty({}, MILLISECOND, parseInt(input, 10) * 10);
});
addParseFlag('SSS', match3, MILLISECOND);

function matchMeridiem(locale) {
  return locale.meridiemParse || /[ap]\.?m?\.?/i;
}

function defaultIsPM(input) {
  return "".concat(input).toLowerCase().charAt(0) === 'p';
}

addParseFlag(['A', 'a'], matchMeridiem, function (input, locale) {
  var isPM = typeof locale.isPM === 'function' ? locale.isPM(input) : defaultIsPM(input);
  return {
    isPM: isPM
  };
});

function offsetFromString(str) {
  var _ref8 = str.match(/([+-]|\d\d)/g) || ['-', '0', '0'],
      _ref9 = _slicedToArray(_ref8, 3),
      symbol = _ref9[0],
      hour = _ref9[1],
      minute = _ref9[2];

  var minutes = parseInt(hour, 10) * 60 + parseInt(minute, 10);

  if (minutes === 0) {
    return 0;
  }

  return symbol === '+' ? -minutes : +minutes;
}

addParseFlag(['Z', 'ZZ'], matchShortOffset, function (input) {
  return {
    offset: offsetFromString(input)
  };
});
addParseFlag('x', matchSigned, function (input) {
  return {
    date: new Date(parseInt(input, 10))
  };
});
addParseFlag('X', matchTimestamp, function (input) {
  return {
    date: new Date(parseFloat(input) * 1000)
  };
});
addParseFlag('d', match1, 'weekday');
addParseFlag('dd', matchWordRegExp('weekdaysMin'), matchWordCallback('weekdaysMin', 'weekday'));
addParseFlag('ddd', matchWordRegExp('weekdaysShort'), matchWordCallback('weekdaysShort', 'weekday'));
addParseFlag('dddd', matchWordRegExp('weekdays'), matchWordCallback('weekdays', 'weekday'));
addParseFlag('w', match1to2, 'week');
addParseFlag('ww', match2, 'week');

function to24hour(hour, isPM) {
  if (hour !== undefined && isPM !== undefined) {
    if (isPM) {
      if (hour < 12) {
        return hour + 12;
      }
    } else if (hour === 12) {
      return 0;
    }
  }

  return hour;
}

function getFullInputArray(input) {
  var backupDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  var result = [0, 0, 1, 0, 0, 0, 0];
  var backupArr = [backupDate.getFullYear(), backupDate.getMonth(), backupDate.getDate(), backupDate.getHours(), backupDate.getMinutes(), backupDate.getSeconds(), backupDate.getMilliseconds()];
  var useBackup = true;

  for (var i = 0; i < 7; i++) {
    if (input[i] === undefined) {
      result[i] = useBackup ? backupArr[i] : result[i];
    } else {
      result[i] = input[i];
      useBackup = false;
    }
  }

  return result;
}

function createDate(y, m, d, h, M, s, ms) {
  var date;

  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);

    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }

  return date;
}

function createUTCDate() {
  var date;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var y = args[0];

  if (y < 100 && y >= 0) {
    args[0] += 400;
    date = new Date(Date.UTC.apply(Date, args)); // eslint-disable-next-line no-restricted-globals

    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(Date, args));
  }

  return date;
}

function makeParser(dateString, format, locale) {
  var tokens = format.match(formattingTokens);

  if (!tokens) {
    throw new Error();
  }

  var length = tokens.length;
  var mark = {};

  for (var i = 0; i < length; i += 1) {
    var token = tokens[i];
    var parseTo = parseFlags[token];

    if (!parseTo) {
      var word = token.replace(/^\[|\]$/g, '');

      if (dateString.indexOf(word) === 0) {
        dateString = dateString.substr(word.length);
      } else {
        throw new Error('not match');
      }
    } else {
      var regex = typeof parseTo[0] === 'function' ? parseTo[0](locale) : parseTo[0];
      var parser = parseTo[1];
      var value = (regex.exec(dateString) || [])[0];
      var obj = parser(value, locale);
      mark = _objectSpread({}, mark, {}, obj);
      dateString = dateString.replace(value, '');
    }
  }

  return mark;
}

function parse(str, format) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  try {
    var _options$locale = options.locale,
        _locale = _options$locale === void 0 ? _locale_en__WEBPACK_IMPORTED_MODULE_0__["default"] : _options$locale,
        _options$backupDate = options.backupDate,
        backupDate = _options$backupDate === void 0 ? new Date() : _options$backupDate;

    var parseResult = makeParser(str, format, _locale);
    var year = parseResult.year,
        month = parseResult.month,
        day = parseResult.day,
        hour = parseResult.hour,
        minute = parseResult.minute,
        second = parseResult.second,
        millisecond = parseResult.millisecond,
        isPM = parseResult.isPM,
        date = parseResult.date,
        offset = parseResult.offset,
        weekday = parseResult.weekday,
        week = parseResult.week;

    if (date) {
      return date;
    }

    var inputArray = [year, month, day, hour, minute, second, millisecond];
    inputArray[3] = to24hour(inputArray[3], isPM); // check week

    if (week !== undefined && month === undefined && day === undefined) {
      // new Date(year, 3) make sure in current year
      var firstDate = (0,_util__WEBPACK_IMPORTED_MODULE_1__.startOfWeekYear)(year === undefined ? backupDate : new Date(year, 3), {
        firstDayOfWeek: _locale.firstDayOfWeek,
        firstWeekContainsDate: _locale.firstWeekContainsDate
      });
      return new Date(firstDate.getTime() + (week - 1) * 7 * 24 * 3600 * 1000);
    }

    var parsedDate;
    var result = getFullInputArray(inputArray, backupDate);

    if (offset !== undefined) {
      result[6] += offset * 60 * 1000;
      parsedDate = createUTCDate.apply(void 0, _toConsumableArray(result));
    } else {
      parsedDate = createDate.apply(void 0, _toConsumableArray(result));
    } // check weekday


    if (weekday !== undefined && parsedDate.getDay() !== weekday) {
      return new Date(NaN);
    }

    return parsedDate;
  } catch (e) {
    return new Date(NaN);
  }
}

/***/ }),

/***/ "./node_modules/date-format-parse/es/util.js":
/*!***************************************************!*\
  !*** ./node_modules/date-format-parse/es/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWeek: () => (/* binding */ getWeek),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isValidDate: () => (/* binding */ isValidDate),
/* harmony export */   startOfWeek: () => (/* binding */ startOfWeek),
/* harmony export */   startOfWeekYear: () => (/* binding */ startOfWeekYear),
/* harmony export */   toDate: () => (/* binding */ toDate)
/* harmony export */ });
function isDate(value) {
  return value instanceof Date || Object.prototype.toString.call(value) === '[object Date]';
}
function toDate(value) {
  if (isDate(value)) {
    return new Date(value.getTime());
  }

  if (value == null) {
    return new Date(NaN);
  }

  return new Date(value);
}
function isValidDate(value) {
  return isDate(value) && !isNaN(value.getTime());
}
function startOfWeek(value) {
  var firstDayOfWeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!(firstDayOfWeek >= 0 && firstDayOfWeek <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6');
  }

  var date = toDate(value);
  var day = date.getDay();
  var diff = (day + 7 - firstDayOfWeek) % 7;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfWeekYear(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$firstDayOfWeek = _ref.firstDayOfWeek,
      firstDayOfWeek = _ref$firstDayOfWeek === void 0 ? 0 : _ref$firstDayOfWeek,
      _ref$firstWeekContain = _ref.firstWeekContainsDate,
      firstWeekContainsDate = _ref$firstWeekContain === void 0 ? 1 : _ref$firstWeekContain;

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7');
  }

  var date = toDate(value);
  var year = date.getFullYear();
  var firstDateOfFirstWeek = new Date(0);

  for (var i = year + 1; i >= year - 1; i--) {
    firstDateOfFirstWeek.setFullYear(i, 0, firstWeekContainsDate);
    firstDateOfFirstWeek.setHours(0, 0, 0, 0);
    firstDateOfFirstWeek = startOfWeek(firstDateOfFirstWeek, firstDayOfWeek);

    if (date.getTime() >= firstDateOfFirstWeek.getTime()) {
      break;
    }
  }

  return firstDateOfFirstWeek;
}
function getWeek(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$firstDayOfWeek = _ref2.firstDayOfWeek,
      firstDayOfWeek = _ref2$firstDayOfWeek === void 0 ? 0 : _ref2$firstDayOfWeek,
      _ref2$firstWeekContai = _ref2.firstWeekContainsDate,
      firstWeekContainsDate = _ref2$firstWeekContai === void 0 ? 1 : _ref2$firstWeekContai;

  var date = toDate(value);
  var firstDateOfThisWeek = startOfWeek(date, firstDayOfWeek);
  var firstDateOfFirstWeek = startOfWeekYear(date, {
    firstDayOfWeek: firstDayOfWeek,
    firstWeekContainsDate: firstWeekContainsDate
  });
  var diff = firstDateOfThisWeek.getTime() - firstDateOfFirstWeek.getTime();
  return Math.round(diff / (7 * 24 * 3600 * 1000)) + 1;
}

/***/ }),

/***/ "./node_modules/ical.js/build/ical.js":
/*!********************************************!*\
  !*** ./node_modules/ical.js/build/ical.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2021 */

/* jshint ignore:start */
var ICAL;
(function() {
  /* istanbul ignore next */
  if (true) {
    // CommonJS, where exports may be different each time.
    ICAL = module.exports;
  } else {}
})();
/* jshint ignore:end */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */

/**
 * The number of characters before iCalendar line folding should occur
 * @type {Number}
 * @default 75
 */
ICAL.foldLength = 75;


/**
 * The character(s) to be used for a newline. The default value is provided by
 * rfc5545.
 * @type {String}
 * @default "\r\n"
 */
ICAL.newLineChar = '\r\n';


/**
 * Helper functions used in various places within ical.js
 * @namespace
 */
ICAL.helpers = {
  /**
   * Compiles a list of all referenced TZIDs in all subcomponents and
   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
   * are referenced by a component, but a VTIMEZONE does not exist,
   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
   *
   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
   * @return {ICAL.Component}         The ICAL.Component that was passed in.
   */
  updateTimezones: function(vcal) {
    var allsubs, properties, vtimezones, reqTzid, i, tzid;

    if (!vcal || vcal.name !== "vcalendar") {
      //not a top-level vcalendar component
      return vcal;
    }

    //Store vtimezone subcomponents in an object reference by tzid.
    //Store properties from everything else in another array
    allsubs = vcal.getAllSubcomponents();
    properties = [];
    vtimezones = {};
    for (i = 0; i < allsubs.length; i++) {
      if (allsubs[i].name === "vtimezone") {
        tzid = allsubs[i].getFirstProperty("tzid").getFirstValue();
        vtimezones[tzid] = allsubs[i];
      } else {
        properties = properties.concat(allsubs[i].getAllProperties());
      }
    }

    //create an object with one entry for each required tz
    reqTzid = {};
    for (i = 0; i < properties.length; i++) {
      if ((tzid = properties[i].getParameter("tzid"))) {
        reqTzid[tzid] = true;
      }
    }

    //delete any vtimezones that are not on the reqTzid list.
    for (i in vtimezones) {
      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {
        vcal.removeSubcomponent(vtimezones[i]);
      }
    }

    //create any missing, but registered timezones
    for (i in reqTzid) {
      if (
        reqTzid.hasOwnProperty(i) &&
        !vtimezones[i] &&
        ICAL.TimezoneService.has(i)
      ) {
        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);
      }
    }

    return vcal;
  },

  /**
   * Checks if the given type is of the number type and also NaN.
   *
   * @param {Number} number     The number to check
   * @return {Boolean}          True, if the number is strictly NaN
   */
  isStrictlyNaN: function(number) {
    return typeof(number) === 'number' && isNaN(number);
  },

  /**
   * Parses a string value that is expected to be an integer, when the valid is
   * not an integer throws a decoration error.
   *
   * @param {String} string     Raw string input
   * @return {Number}           Parsed integer
   */
  strictParseInt: function(string) {
    var result = parseInt(string, 10);

    if (ICAL.helpers.isStrictlyNaN(result)) {
      throw new Error(
        'Could not extract integer from "' + string + '"'
      );
    }

    return result;
  },

  /**
   * Creates or returns a class instance of a given type with the initialization
   * data if the data is not already an instance of the given type.
   *
   * @example
   * var time = new ICAL.Time(...);
   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
   *
   * (result instanceof ICAL.Time)
   * // => true
   *
   * result = ICAL.helpers.formatClassType({}, ICAL.Time);
   * (result isntanceof ICAL.Time)
   * // => true
   *
   *
   * @param {Object} data       object initialization data
   * @param {Object} type       object type (like ICAL.Time)
   * @return {?}                An instance of the found type.
   */
  formatClassType: function formatClassType(data, type) {
    if (typeof(data) === 'undefined') {
      return undefined;
    }

    if (data instanceof type) {
      return data;
    }
    return new type(data);
  },

  /**
   * Identical to indexOf but will only match values when they are not preceded
   * by a backslash character.
   *
   * @param {String} buffer         String to search
   * @param {String} search         Value to look for
   * @param {Number} pos            Start position
   * @return {Number}               The position, or -1 if not found
   */
  unescapedIndexOf: function(buffer, search, pos) {
    while ((pos = buffer.indexOf(search, pos)) !== -1) {
      if (pos > 0 && buffer[pos - 1] === '\\') {
        pos += 1;
      } else {
        return pos;
      }
    }
    return -1;
  },

  /**
   * Find the index for insertion using binary search.
   *
   * @param {Array} list            The list to search
   * @param {?} seekVal             The value to insert
   * @param {function(?,?)} cmpfunc The comparison func, that can
   *                                  compare two seekVals
   * @return {Number}               The insert position
   */
  binsearchInsert: function(list, seekVal, cmpfunc) {
    if (!list.length)
      return 0;

    var low = 0, high = list.length - 1,
        mid, cmpval;

    while (low <= high) {
      mid = low + Math.floor((high - low) / 2);
      cmpval = cmpfunc(seekVal, list[mid]);

      if (cmpval < 0)
        high = mid - 1;
      else if (cmpval > 0)
        low = mid + 1;
      else
        break;
    }

    if (cmpval < 0)
      return mid; // insertion is displacing, so use mid outright.
    else if (cmpval > 0)
      return mid + 1;
    else
      return mid;
  },

  /**
   * Convenience function for debug output
   * @private
   */
  dumpn: /* istanbul ignore next */ function() {
    if (!ICAL.debug) {
      return;
    }

    if (typeof (console) !== 'undefined' && 'log' in console) {
      ICAL.helpers.dumpn = function consoleDumpn(input) {
        console.log(input);
      };
    } else {
      ICAL.helpers.dumpn = function geckoDumpn(input) {
        dump(input + '\n');
      };
    }

    ICAL.helpers.dumpn(arguments[0]);
  },

  /**
   * Clone the passed object or primitive. By default a shallow clone will be
   * executed.
   *
   * @param {*} aSrc            The thing to clone
   * @param {Boolean=} aDeep    If true, a deep clone will be performed
   * @return {*}                The copy of the thing
   */
  clone: function(aSrc, aDeep) {
    if (!aSrc || typeof aSrc != "object") {
      return aSrc;
    } else if (aSrc instanceof Date) {
      return new Date(aSrc.getTime());
    } else if ("clone" in aSrc) {
      return aSrc.clone();
    } else if (Array.isArray(aSrc)) {
      var arr = [];
      for (var i = 0; i < aSrc.length; i++) {
        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);
      }
      return arr;
    } else {
      var obj = {};
      for (var name in aSrc) {
        // uses prototype method to allow use of Object.create(null);
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
          if (aDeep) {
            obj[name] = ICAL.helpers.clone(aSrc[name], true);
          } else {
            obj[name] = aSrc[name];
          }
        }
      }
      return obj;
    }
  },

  /**
   * Performs iCalendar line folding. A line ending character is inserted and
   * the next line begins with a whitespace.
   *
   * @example
   * SUMMARY:This line will be fold
   *  ed right in the middle of a word.
   *
   * @param {String} aLine      The line to fold
   * @return {String}           The folded line
   */
  foldline: function foldline(aLine) {
    var result = "";
    var line = aLine || "", pos = 0, line_length = 0;
    //pos counts position in line for the UTF-16 presentation
    //line_length counts the bytes for the UTF-8 presentation
    while (line.length) {
      var cp = line.codePointAt(pos);
      if (cp < 128) ++line_length;
      else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes
      else if (cp < 65536) line_length += 3;
      else line_length += 4; //cp is less than 1114112
      if (line_length < ICAL.foldLength + 1)
        pos += cp > 65535 ? 2 : 1;
      else {
        result += ICAL.newLineChar + " " + line.substring(0, pos);
        line = line.substring(pos);
        pos = line_length = 0;
      }
    }
    return result.substr(ICAL.newLineChar.length + 1);
  },

  /**
   * Pads the given string or number with zeros so it will have at least two
   * characters.
   *
   * @param {String|Number} data    The string or number to pad
   * @return {String}               The number padded as a string
   */
  pad2: function pad(data) {
    if (typeof(data) !== 'string') {
      // handle fractions.
      if (typeof(data) === 'number') {
        data = parseInt(data);
      }
      data = String(data);
    }

    var len = data.length;

    switch (len) {
      case 0:
        return '00';
      case 1:
        return '0' + data;
      default:
        return data;
    }
  },

  /**
   * Truncates the given number, correctly handling negative numbers.
   *
   * @param {Number} number     The number to truncate
   * @return {Number}           The truncated number
   */
  trunc: function trunc(number) {
    return (number < 0 ? Math.ceil(number) : Math.floor(number));
  },

  /**
   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
   * the features, but enough for our usage.
   *
   * @param {Function} base     The base class constructor function.
   * @param {Function} child    The child class constructor function.
   * @param {Object} extra      Extends the prototype with extra properties
   *                              and methods
   */
  inherits: function(base, child, extra) {
    function F() {}
    F.prototype = base.prototype;
    child.prototype = new F();

    if (extra) {
      ICAL.helpers.extend(extra, child.prototype);
    }
  },

  /**
   * Poor-man's cross-browser object extension. Doesn't support all the
   * features, but enough for our usage. Note that the target's properties are
   * not overwritten with the source properties.
   *
   * @example
   * var child = ICAL.helpers.extend(parent, {
   *   "bar": 123
   * });
   *
   * @param {Object} source     The object to extend
   * @param {Object} target     The object to extend with
   * @return {Object}           Returns the target.
   */
  extend: function(source, target) {
    for (var key in source) {
      var descr = Object.getOwnPropertyDescriptor(source, key);
      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
        Object.defineProperty(target, key, descr);
      }
    }
    return target;
  }
};
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */

/** @namespace ICAL */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.design = (function() {
  'use strict';

  var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
  var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
  var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
  var TO_VCARD_NEWLINE = /\\|,|\n/g;

  function createTextType(fromNewline, toNewline) {
    var result = {
      matches: /.*/,

      fromICAL: function(aValue, structuredEscape) {
        return replaceNewline(aValue, fromNewline, structuredEscape);
      },

      toICAL: function(aValue, structuredEscape) {
        var regEx = toNewline;
        if (structuredEscape)
          regEx = new RegExp(regEx.source + '|' + structuredEscape);
        return aValue.replace(regEx, function(str) {
          switch (str) {
          case "\\":
            return "\\\\";
          case ";":
            return "\\;";
          case ",":
            return "\\,";
          case "\n":
            return "\\n";
          /* istanbul ignore next */
          default:
            return str;
          }
        });
      }
    };
    return result;
  }

  // default types used multiple times
  var DEFAULT_TYPE_TEXT = { defaultType: "text" };
  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
  var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
  var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
  var DEFAULT_TYPE_URI = { defaultType: "uri" };
  var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
  var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };

  function replaceNewlineReplace(string) {
    switch (string) {
      case "\\\\":
        return "\\";
      case "\\;":
        return ";";
      case "\\,":
        return ",";
      case "\\n":
      case "\\N":
        return "\n";
      /* istanbul ignore next */
      default:
        return string;
    }
  }

  function replaceNewline(value, newline, structuredEscape) {
    // avoid regex when possible.
    if (value.indexOf('\\') === -1) {
      return value;
    }
    if (structuredEscape)
      newline = new RegExp(newline.source + '|\\\\' + structuredEscape);
    return value.replace(newline, replaceNewlineReplace);
  }

  var commonProperties = {
    "categories": DEFAULT_TYPE_TEXT_MULTI,
    "url": DEFAULT_TYPE_URI,
    "version": DEFAULT_TYPE_TEXT,
    "uid": DEFAULT_TYPE_TEXT
  };

  var commonValues = {
    "boolean": {
      values: ["TRUE", "FALSE"],

      fromICAL: function(aValue) {
        switch (aValue) {
          case 'TRUE':
            return true;
          case 'FALSE':
            return false;
          default:
            //TODO: parser warning
            return false;
        }
      },

      toICAL: function(aValue) {
        if (aValue) {
          return 'TRUE';
        }
        return 'FALSE';
      }

    },
    float: {
      matches: /^[+-]?\d+\.\d+$/,

      fromICAL: function(aValue) {
        var parsed = parseFloat(aValue);
        if (ICAL.helpers.isStrictlyNaN(parsed)) {
          // TODO: parser warning
          return 0.0;
        }
        return parsed;
      },

      toICAL: function(aValue) {
        return String(aValue);
      }
    },
    integer: {
      fromICAL: function(aValue) {
        var parsed = parseInt(aValue);
        if (ICAL.helpers.isStrictlyNaN(parsed)) {
          return 0;
        }
        return parsed;
      },

      toICAL: function(aValue) {
        return String(aValue);
      }
    },
    "utc-offset": {
      toICAL: function(aValue) {
        if (aValue.length < 7) {
          // no seconds
          // -0500
          return aValue.substr(0, 3) +
                 aValue.substr(4, 2);
        } else {
          // seconds
          // -050000
          return aValue.substr(0, 3) +
                 aValue.substr(4, 2) +
                 aValue.substr(7, 2);
        }
      },

      fromICAL: function(aValue) {
        if (aValue.length < 6) {
          // no seconds
          // -05:00
          return aValue.substr(0, 3) + ':' +
                 aValue.substr(3, 2);
        } else {
          // seconds
          // -05:00:00
          return aValue.substr(0, 3) + ':' +
                 aValue.substr(3, 2) + ':' +
                 aValue.substr(5, 2);
        }
      },

      decorate: function(aValue) {
        return ICAL.UtcOffset.fromString(aValue);
      },

      undecorate: function(aValue) {
        return aValue.toString();
      }
    }
  };

  var icalParams = {
    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
    // enfoce anything aside from it being a valid content line.
    //
    // At least some params require - if multi values are used - DQUOTEs
    // for each of its values - e.g. delegated-from="uri1","uri2"
    // To indicate this, I introduced the new k/v pair
    // multiValueSeparateDQuote: true
    //
    // "ALTREP": { ... },

    // CN just wants a param-value
    // "CN": { ... }

    "cutype": {
      values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
      allowXName: true,
      allowIanaToken: true
    },

    "delegated-from": {
      valueType: "cal-address",
      multiValue: ",",
      multiValueSeparateDQuote: true
    },
    "delegated-to": {
      valueType: "cal-address",
      multiValue: ",",
      multiValueSeparateDQuote: true
    },
    // "DIR": { ... }, // See ALTREP
    "encoding": {
      values: ["8BIT", "BASE64"]
    },
    // "FMTTYPE": { ... }, // See ALTREP
    "fbtype": {
      values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
      allowXName: true,
      allowIanaToken: true
    },
    // "LANGUAGE": { ... }, // See ALTREP
    "member": {
      valueType: "cal-address",
      multiValue: ",",
      multiValueSeparateDQuote: true
    },
    "partstat": {
      // TODO These values are actually different per-component
      values: ["NEEDS-ACTION", "ACCEPTED", "DECLINED", "TENTATIVE",
               "DELEGATED", "COMPLETED", "IN-PROCESS"],
      allowXName: true,
      allowIanaToken: true
    },
    "range": {
      values: ["THISANDFUTURE"]
    },
    "related": {
      values: ["START", "END"]
    },
    "reltype": {
      values: ["PARENT", "CHILD", "SIBLING"],
      allowXName: true,
      allowIanaToken: true
    },
    "role": {
      values: ["REQ-PARTICIPANT", "CHAIR",
               "OPT-PARTICIPANT", "NON-PARTICIPANT"],
      allowXName: true,
      allowIanaToken: true
    },
    "rsvp": {
      values: ["TRUE", "FALSE"]
    },
    "sent-by": {
      valueType: "cal-address"
    },
    "tzid": {
      matches: /^\//
    },
    "value": {
      // since the value here is a 'type' lowercase is used.
      values: ["binary", "boolean", "cal-address", "date", "date-time",
               "duration", "float", "integer", "period", "recur", "text",
               "time", "uri", "utc-offset"],
      allowXName: true,
      allowIanaToken: true
    }
  };

  // When adding a value here, be sure to add it to the parameter types!
  var icalValues = ICAL.helpers.extend(commonValues, {
    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),

    uri: {
      // TODO
      /* ... */
    },

    "binary": {
      decorate: function(aString) {
        return ICAL.Binary.fromString(aString);
      },

      undecorate: function(aBinary) {
        return aBinary.toString();
      }
    },
    "cal-address": {
      // needs to be an uri
    },
    "date": {
      decorate: function(aValue, aProp) {
        if (design.strict) {
          return ICAL.Time.fromDateString(aValue, aProp);
        } else {
          return ICAL.Time.fromString(aValue, aProp);
        }
      },

      /**
       * undecorates a time object.
       */
      undecorate: function(aValue) {
        return aValue.toString();
      },

      fromICAL: function(aValue) {
        // from: 20120901
        // to: 2012-09-01
        if (!design.strict && aValue.length >= 15) {
          // This is probably a date-time, e.g. 20120901T130000Z
          return icalValues["date-time"].fromICAL(aValue);
        } else {
          return aValue.substr(0, 4) + '-' +
                 aValue.substr(4, 2) + '-' +
                 aValue.substr(6, 2);
        }
      },

      toICAL: function(aValue) {
        // from: 2012-09-01
        // to: 20120901
        var len = aValue.length;

        if (len == 10) {
          return aValue.substr(0, 4) +
                 aValue.substr(5, 2) +
                 aValue.substr(8, 2);
        } else if (len >= 19) {
          return icalValues["date-time"].toICAL(aValue);
        } else {
          //TODO: serialize warning?
          return aValue;
        }

      }
    },
    "date-time": {
      fromICAL: function(aValue) {
        // from: 20120901T130000
        // to: 2012-09-01T13:00:00
        if (!design.strict && aValue.length == 8) {
          // This is probably a date, e.g. 20120901
          return icalValues.date.fromICAL(aValue);
        } else {
          var result = aValue.substr(0, 4) + '-' +
                       aValue.substr(4, 2) + '-' +
                       aValue.substr(6, 2) + 'T' +
                       aValue.substr(9, 2) + ':' +
                       aValue.substr(11, 2) + ':' +
                       aValue.substr(13, 2);

          if (aValue[15] && aValue[15] === 'Z') {
            result += 'Z';
          }

          return result;
        }
      },

      toICAL: function(aValue) {
        // from: 2012-09-01T13:00:00
        // to: 20120901T130000
        var len = aValue.length;

        if (len == 10 && !design.strict) {
          return icalValues.date.toICAL(aValue);
        } else if (len >= 19) {
          var result = aValue.substr(0, 4) +
                       aValue.substr(5, 2) +
                       // grab the (DDTHH) segment
                       aValue.substr(8, 5) +
                       // MM
                       aValue.substr(14, 2) +
                       // SS
                       aValue.substr(17, 2);

          if (aValue[19] && aValue[19] === 'Z') {
            result += 'Z';
          }
          return result;
        } else {
          // TODO: error
          return aValue;
        }
      },

      decorate: function(aValue, aProp) {
        if (design.strict) {
          return ICAL.Time.fromDateTimeString(aValue, aProp);
        } else {
          return ICAL.Time.fromString(aValue, aProp);
        }
      },

      undecorate: function(aValue) {
        return aValue.toString();
      }
    },
    duration: {
      decorate: function(aValue) {
        return ICAL.Duration.fromString(aValue);
      },
      undecorate: function(aValue) {
        return aValue.toString();
      }
    },
    period: {

      fromICAL: function(string) {
        var parts = string.split('/');
        parts[0] = icalValues['date-time'].fromICAL(parts[0]);

        if (!ICAL.Duration.isValueString(parts[1])) {
          parts[1] = icalValues['date-time'].fromICAL(parts[1]);
        }

        return parts;
      },

      toICAL: function(parts) {
        if (!design.strict && parts[0].length == 10) {
          parts[0] = icalValues.date.toICAL(parts[0]);
        } else {
          parts[0] = icalValues['date-time'].toICAL(parts[0]);
        }

        if (!ICAL.Duration.isValueString(parts[1])) {
          if (!design.strict && parts[1].length == 10) {
            parts[1] = icalValues.date.toICAL(parts[1]);
          } else {
            parts[1] = icalValues['date-time'].toICAL(parts[1]);
          }
        }

        return parts.join("/");
      },

      decorate: function(aValue, aProp) {
        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);
      },

      undecorate: function(aValue) {
        return aValue.toJSON();
      }
    },
    recur: {
      fromICAL: function(string) {
        return ICAL.Recur._stringToData(string, true);
      },

      toICAL: function(data) {
        var str = "";
        for (var k in data) {
          /* istanbul ignore if */
          if (!Object.prototype.hasOwnProperty.call(data, k)) {
            continue;
          }
          var val = data[k];
          if (k == "until") {
            if (val.length > 10) {
              val = icalValues['date-time'].toICAL(val);
            } else {
              val = icalValues.date.toICAL(val);
            }
          } else if (k == "wkst") {
            if (typeof val === 'number') {
              val = ICAL.Recur.numericDayToIcalDay(val);
            }
          } else if (Array.isArray(val)) {
            val = val.join(",");
          }
          str += k.toUpperCase() + "=" + val + ";";
        }
        return str.substr(0, str.length - 1);
      },

      decorate: function decorate(aValue) {
        return ICAL.Recur.fromData(aValue);
      },

      undecorate: function(aRecur) {
        return aRecur.toJSON();
      }
    },

    time: {
      fromICAL: function(aValue) {
        // from: MMHHSS(Z)?
        // to: HH:MM:SS(Z)?
        if (aValue.length < 6) {
          // TODO: parser exception?
          return aValue;
        }

        // HH::MM::SSZ?
        var result = aValue.substr(0, 2) + ':' +
                     aValue.substr(2, 2) + ':' +
                     aValue.substr(4, 2);

        if (aValue[6] === 'Z') {
          result += 'Z';
        }

        return result;
      },

      toICAL: function(aValue) {
        // from: HH:MM:SS(Z)?
        // to: MMHHSS(Z)?
        if (aValue.length < 8) {
          //TODO: error
          return aValue;
        }

        var result = aValue.substr(0, 2) +
                     aValue.substr(3, 2) +
                     aValue.substr(6, 2);

        if (aValue[8] === 'Z') {
          result += 'Z';
        }

        return result;
      }
    }
  });

  var icalProperties = ICAL.helpers.extend(commonProperties, {

    "action": DEFAULT_TYPE_TEXT,
    "attach": { defaultType: "uri" },
    "attendee": { defaultType: "cal-address" },
    "calscale": DEFAULT_TYPE_TEXT,
    "class": DEFAULT_TYPE_TEXT,
    "comment": DEFAULT_TYPE_TEXT,
    "completed": DEFAULT_TYPE_DATETIME,
    "contact": DEFAULT_TYPE_TEXT,
    "created": DEFAULT_TYPE_DATETIME,
    "description": DEFAULT_TYPE_TEXT,
    "dtend": DEFAULT_TYPE_DATETIME_DATE,
    "dtstamp": DEFAULT_TYPE_DATETIME,
    "dtstart": DEFAULT_TYPE_DATETIME_DATE,
    "due": DEFAULT_TYPE_DATETIME_DATE,
    "duration": { defaultType: "duration" },
    "exdate": {
      defaultType: "date-time",
      allowedTypes: ["date-time", "date"],
      multiValue: ','
    },
    "exrule": DEFAULT_TYPE_RECUR,
    "freebusy": { defaultType: "period", multiValue: "," },
    "geo": { defaultType: "float", structuredValue: ";" },
    "last-modified": DEFAULT_TYPE_DATETIME,
    "location": DEFAULT_TYPE_TEXT,
    "method": DEFAULT_TYPE_TEXT,
    "organizer": { defaultType: "cal-address" },
    "percent-complete": DEFAULT_TYPE_INTEGER,
    "priority": DEFAULT_TYPE_INTEGER,
    "prodid": DEFAULT_TYPE_TEXT,
    "related-to": DEFAULT_TYPE_TEXT,
    "repeat": DEFAULT_TYPE_INTEGER,
    "rdate": {
      defaultType: "date-time",
      allowedTypes: ["date-time", "date", "period"],
      multiValue: ',',
      detectType: function(string) {
        if (string.indexOf('/') !== -1) {
          return 'period';
        }
        return (string.indexOf('T') === -1) ? 'date' : 'date-time';
      }
    },
    "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
    "resources": DEFAULT_TYPE_TEXT_MULTI,
    "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
    "rrule": DEFAULT_TYPE_RECUR,
    "sequence": DEFAULT_TYPE_INTEGER,
    "status": DEFAULT_TYPE_TEXT,
    "summary": DEFAULT_TYPE_TEXT,
    "transp": DEFAULT_TYPE_TEXT,
    "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
    "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
    "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
    "tzurl": DEFAULT_TYPE_URI,
    "tzid": DEFAULT_TYPE_TEXT,
    "tzname": DEFAULT_TYPE_TEXT
  });

  // When adding a value here, be sure to add it to the parameter types!
  var vcardValues = ICAL.helpers.extend(commonValues, {
    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),

    date: {
      decorate: function(aValue) {
        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date");
      },
      undecorate: function(aValue) {
        return aValue.toString();
      },
      fromICAL: function(aValue) {
        if (aValue.length == 8) {
          return icalValues.date.fromICAL(aValue);
        } else if (aValue[0] == '-' && aValue.length == 6) {
          return aValue.substr(0, 4) + '-' + aValue.substr(4);
        } else {
          return aValue;
        }
      },
      toICAL: function(aValue) {
        if (aValue.length == 10) {
          return icalValues.date.toICAL(aValue);
        } else if (aValue[0] == '-' && aValue.length == 7) {
          return aValue.substr(0, 4) + aValue.substr(5);
        } else {
          return aValue;
        }
      }
    },

    time: {
      decorate: function(aValue) {
        return ICAL.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
      },
      undecorate: function(aValue) {
        return aValue.toString();
      },
      fromICAL: function(aValue) {
        var splitzone = vcardValues.time._splitZone(aValue, true);
        var zone = splitzone[0], value = splitzone[1];

        //console.log("SPLIT: ",splitzone);

        if (value.length == 6) {
          value = value.substr(0, 2) + ':' +
                  value.substr(2, 2) + ':' +
                  value.substr(4, 2);
        } else if (value.length == 4 && value[0] != '-') {
          value = value.substr(0, 2) + ':' + value.substr(2, 2);
        } else if (value.length == 5) {
          value = value.substr(0, 3) + ':' + value.substr(3, 2);
        }

        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {
          zone = zone.substr(0, 3) + ':' + zone.substr(3);
        }

        return value + zone;
      },

      toICAL: function(aValue) {
        var splitzone = vcardValues.time._splitZone(aValue);
        var zone = splitzone[0], value = splitzone[1];

        if (value.length == 8) {
          value = value.substr(0, 2) +
                  value.substr(3, 2) +
                  value.substr(6, 2);
        } else if (value.length == 5 && value[0] != '-') {
          value = value.substr(0, 2) + value.substr(3, 2);
        } else if (value.length == 6) {
          value = value.substr(0, 3) + value.substr(4, 2);
        }

        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {
          zone = zone.substr(0, 3) + zone.substr(4);
        }

        return value + zone;
      },

      _splitZone: function(aValue, isFromIcal) {
        var lastChar = aValue.length - 1;
        var signChar = aValue.length - (isFromIcal ? 5 : 6);
        var sign = aValue[signChar];
        var zone, value;

        if (aValue[lastChar] == 'Z') {
          zone = aValue[lastChar];
          value = aValue.substr(0, lastChar);
        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {
          zone = aValue.substr(signChar);
          value = aValue.substr(0, signChar);
        } else {
          zone = "";
          value = aValue;
        }

        return [zone, value];
      }
    },

    "date-time": {
      decorate: function(aValue) {
        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
      },

      undecorate: function(aValue) {
        return aValue.toString();
      },

      fromICAL: function(aValue) {
        return vcardValues['date-and-or-time'].fromICAL(aValue);
      },

      toICAL: function(aValue) {
        return vcardValues['date-and-or-time'].toICAL(aValue);
      }
    },

    "date-and-or-time": {
      decorate: function(aValue) {
        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
      },

      undecorate: function(aValue) {
        return aValue.toString();
      },

      fromICAL: function(aValue) {
        var parts = aValue.split('T');
        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +
               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');
      },

      toICAL: function(aValue) {
        var parts = aValue.split('T');
        return vcardValues.date.toICAL(parts[0]) +
               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');

      }
    },
    timestamp: icalValues['date-time'],
    "language-tag": {
      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here
    }
  });

  var vcardParams = {
    "type": {
      valueType: "text",
      multiValue: ","
    },
    "value": {
      // since the value here is a 'type' lowercase is used.
      values: ["text", "uri", "date", "time", "date-time", "date-and-or-time",
               "timestamp", "boolean", "integer", "float", "utc-offset",
               "language-tag"],
      allowXName: true,
      allowIanaToken: true
    }
  };

  var vcardProperties = ICAL.helpers.extend(commonProperties, {
    "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
    "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
    "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
    "caladruri": DEFAULT_TYPE_URI,
    "caluri": DEFAULT_TYPE_URI,
    "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
    "email": DEFAULT_TYPE_TEXT,
    "fburl": DEFAULT_TYPE_URI,
    "fn": DEFAULT_TYPE_TEXT,
    "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
    "geo": DEFAULT_TYPE_URI,
    "impp": DEFAULT_TYPE_URI,
    "key": DEFAULT_TYPE_URI,
    "kind": DEFAULT_TYPE_TEXT,
    "lang": { defaultType: "language-tag" },
    "logo": DEFAULT_TYPE_URI,
    "member": DEFAULT_TYPE_URI,
    "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
    "nickname": DEFAULT_TYPE_TEXT_MULTI,
    "note": DEFAULT_TYPE_TEXT,
    "org": { defaultType: "text", structuredValue: ";" },
    "photo": DEFAULT_TYPE_URI,
    "related": DEFAULT_TYPE_URI,
    "rev": { defaultType: "timestamp" },
    "role": DEFAULT_TYPE_TEXT,
    "sound": DEFAULT_TYPE_URI,
    "source": DEFAULT_TYPE_URI,
    "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
    "title": DEFAULT_TYPE_TEXT,
    "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
    "xml": DEFAULT_TYPE_TEXT
  });

  var vcard3Values = ICAL.helpers.extend(commonValues, {
    binary: icalValues.binary,
    date: vcardValues.date,
    "date-time": vcardValues["date-time"],
    "phone-number": {
      // TODO
      /* ... */
    },
    uri: icalValues.uri,
    text: icalValues.text,
    time: icalValues.time,
    vcard: icalValues.text,
    "utc-offset": {
      toICAL: function(aValue) {
        return aValue.substr(0, 7);
      },

      fromICAL: function(aValue) {
        return aValue.substr(0, 7);
      },

      decorate: function(aValue) {
        return ICAL.UtcOffset.fromString(aValue);
      },

      undecorate: function(aValue) {
        return aValue.toString();
      }
    }
  });

  var vcard3Params = {
    "type": {
      valueType: "text",
      multiValue: ","
    },
    "value": {
      // since the value here is a 'type' lowercase is used.
      values: ["text", "uri", "date", "date-time", "phone-number", "time",
               "boolean", "integer", "float", "utc-offset", "vcard", "binary"],
      allowXName: true,
      allowIanaToken: true
    }
  };

  var vcard3Properties = ICAL.helpers.extend(commonProperties, {
    fn: DEFAULT_TYPE_TEXT,
    n: { defaultType: "text", structuredValue: ";", multiValue: "," },
    nickname: DEFAULT_TYPE_TEXT_MULTI,
    photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
    bday: {
      defaultType: "date-time",
      allowedTypes: ["date-time", "date"],
      detectType: function(string) {
        return (string.indexOf('T') === -1) ? 'date' : 'date-time';
      }
    },

    adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
    label: DEFAULT_TYPE_TEXT,

    tel: { defaultType: "phone-number" },
    email: DEFAULT_TYPE_TEXT,
    mailer: DEFAULT_TYPE_TEXT,

    tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
    geo: { defaultType: "float", structuredValue: ";" },

    title: DEFAULT_TYPE_TEXT,
    role: DEFAULT_TYPE_TEXT,
    logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
    agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
    org: DEFAULT_TYPE_TEXT_STRUCTURED,

    note: DEFAULT_TYPE_TEXT_MULTI,
    prodid: DEFAULT_TYPE_TEXT,
    rev: {
      defaultType: "date-time",
      allowedTypes: ["date-time", "date"],
      detectType: function(string) {
        return (string.indexOf('T') === -1) ? 'date' : 'date-time';
      }
    },
    "sort-string": DEFAULT_TYPE_TEXT,
    sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },

    class: DEFAULT_TYPE_TEXT,
    key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
  });

  /**
   * iCalendar design set
   * @type {ICAL.design.designSet}
   */
  var icalSet = {
    value: icalValues,
    param: icalParams,
    property: icalProperties
  };

  /**
   * vCard 4.0 design set
   * @type {ICAL.design.designSet}
   */
  var vcardSet = {
    value: vcardValues,
    param: vcardParams,
    property: vcardProperties
  };

  /**
   * vCard 3.0 design set
   * @type {ICAL.design.designSet}
   */
  var vcard3Set = {
    value: vcard3Values,
    param: vcard3Params,
    property: vcard3Properties
  };

  /**
   * The design data, used by the parser to determine types for properties and
   * other metadata needed to produce correct jCard/jCal data.
   *
   * @alias ICAL.design
   * @namespace
   */
  var design = {
    /**
     * A designSet describes value, parameter and property data. It is used by
     * ther parser and stringifier in components and properties to determine they
     * should be represented.
     *
     * @typedef {Object} designSet
     * @memberOf ICAL.design
     * @property {Object} value       Definitions for value types, keys are type names
     * @property {Object} param       Definitions for params, keys are param names
     * @property {Object} property    Defintions for properties, keys are property names
     */

    /**
     * Can be set to false to make the parser more lenient.
     */
    strict: true,

    /**
     * The default set for new properties and components if none is specified.
     * @type {ICAL.design.designSet}
     */
    defaultSet: icalSet,

    /**
     * The default type for unknown properties
     * @type {String}
     */
    defaultType: 'unknown',

    /**
     * Holds the design set for known top-level components
     *
     * @type {Object}
     * @property {ICAL.design.designSet} vcard       vCard VCARD
     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
     * @property {ICAL.design.designSet} valarm      iCalendar VALARM
     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
     * @property {ICAL.design.designSet} standard    iCalendar STANDARD
     *
     * @example
     * var propertyName = 'fn';
     * var componentDesign = ICAL.design.components.vcard;
     * var propertyDetails = componentDesign.property[propertyName];
     * if (propertyDetails.defaultType == 'text') {
     *   // Yep, sure is...
     * }
     */
    components: {
      vcard: vcardSet,
      vcard3: vcard3Set,
      vevent: icalSet,
      vtodo: icalSet,
      vjournal: icalSet,
      valarm: icalSet,
      vtimezone: icalSet,
      daylight: icalSet,
      standard: icalSet
    },


    /**
     * The design set for iCalendar (rfc5545/rfc7265) components.
     * @type {ICAL.design.designSet}
     */
    icalendar: icalSet,

    /**
     * The design set for vCard (rfc6350/rfc7095) components.
     * @type {ICAL.design.designSet}
     */
    vcard: vcardSet,

    /**
     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
     * @type {ICAL.design.designSet}
     */
    vcard3: vcard3Set,

    /**
     * Gets the design set for the given component name.
     *
     * @param {String} componentName        The name of the component
     * @return {ICAL.design.designSet}      The design set for the component
     */
    getDesignSet: function(componentName) {
      var isInDesign = componentName && componentName in design.components;
      return isInDesign ? design.components[componentName] : design.defaultSet;
    }
  };

  return design;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * Contains various functions to convert jCal and jCard data back into
 * iCalendar and vCard.
 * @namespace
 */
ICAL.stringify = (function() {
  'use strict';

  var LINE_ENDING = '\r\n';
  var DEFAULT_VALUE_TYPE = 'unknown';

  var design = ICAL.design;
  var helpers = ICAL.helpers;

  /**
   * Convert a full jCal/jCard array into a iCalendar/vCard string.
   *
   * @function ICAL.stringify
   * @variation function
   * @param {Array} jCal    The jCal/jCard document
   * @return {String}       The stringified iCalendar/vCard document
   */
  function stringify(jCal) {
    if (typeof jCal[0] == "string") {
      // This is a single component
      jCal = [jCal];
    }

    var i = 0;
    var len = jCal.length;
    var result = '';

    for (; i < len; i++) {
      result += stringify.component(jCal[i]) + LINE_ENDING;
    }

    return result;
  }

  /**
   * Converts an jCal component array into a ICAL string.
   * Recursive will resolve sub-components.
   *
   * Exact component/property order is not saved all
   * properties will come before subcomponents.
   *
   * @function ICAL.stringify.component
   * @param {Array} component
   *        jCal/jCard fragment of a component
   * @param {ICAL.design.designSet} designSet
   *        The design data to use for this component
   * @return {String}       The iCalendar/vCard string
   */
  stringify.component = function(component, designSet) {
    var name = component[0].toUpperCase();
    var result = 'BEGIN:' + name + LINE_ENDING;

    var props = component[1];
    var propIdx = 0;
    var propLen = props.length;

    var designSetName = component[0];
    // rfc6350 requires that in vCard 4.0 the first component is the VERSION
    // component with as value 4.0, note that 3.0 does not have this requirement.
    if (designSetName === 'vcard' && component[1].length > 0 &&
            !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
      designSetName = "vcard3";
    }
    designSet = designSet || design.getDesignSet(designSetName);

    for (; propIdx < propLen; propIdx++) {
      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
    }

    // Ignore subcomponents if none exist, e.g. in vCard.
    var comps = component[2] || [];
    var compIdx = 0;
    var compLen = comps.length;

    for (; compIdx < compLen; compIdx++) {
      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
    }

    result += 'END:' + name;
    return result;
  };

  /**
   * Converts a single jCal/jCard property to a iCalendar/vCard string.
   *
   * @function ICAL.stringify.property
   * @param {Array} property
   *        jCal/jCard property array
   * @param {ICAL.design.designSet} designSet
   *        The design data to use for this property
   * @param {Boolean} noFold
   *        If true, the line is not folded
   * @return {String}       The iCalendar/vCard string
   */
  stringify.property = function(property, designSet, noFold) {
    var name = property[0].toUpperCase();
    var jsName = property[0];
    var params = property[1];

    var line = name;

    var paramName;
    for (paramName in params) {
      var value = params[paramName];

      /* istanbul ignore else */
      if (params.hasOwnProperty(paramName)) {
        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;
        if (multiValue && Array.isArray(value)) {
          if (designSet.param[paramName].multiValueSeparateDQuote) {
            multiValue = '"' + multiValue + '"';
          }
          value = value.map(stringify._rfc6868Unescape);
          value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
        } else {
          value = stringify._rfc6868Unescape(value);
        }


        line += ';' + paramName.toUpperCase();
        line += '=' + stringify.propertyValue(value);
      }
    }

    if (property.length === 3) {
      // If there are no values, we must assume a blank value
      return line + ':';
    }

    var valueType = property[2];

    if (!designSet) {
      designSet = design.defaultSet;
    }

    var propDetails;
    var multiValue = false;
    var structuredValue = false;
    var isDefault = false;

    if (jsName in designSet.property) {
      propDetails = designSet.property[jsName];

      if ('multiValue' in propDetails) {
        multiValue = propDetails.multiValue;
      }

      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {
        structuredValue = propDetails.structuredValue;
      }

      if ('defaultType' in propDetails) {
        if (valueType === propDetails.defaultType) {
          isDefault = true;
        }
      } else {
        if (valueType === DEFAULT_VALUE_TYPE) {
          isDefault = true;
        }
      }
    } else {
      if (valueType === DEFAULT_VALUE_TYPE) {
        isDefault = true;
      }
    }

    // push the VALUE property if type is not the default
    // for the current property.
    if (!isDefault) {
      // value will never contain ;/:/, so we don't escape it here.
      line += ';VALUE=' + valueType.toUpperCase();
    }

    line += ':';

    if (multiValue && structuredValue) {
      line += stringify.multiValue(
        property[3], structuredValue, valueType, multiValue, designSet, structuredValue
      );
    } else if (multiValue) {
      line += stringify.multiValue(
        property.slice(3), multiValue, valueType, null, designSet, false
      );
    } else if (structuredValue) {
      line += stringify.multiValue(
        property[3], structuredValue, valueType, null, designSet, structuredValue
      );
    } else {
      line += stringify.value(property[3], valueType, designSet, false);
    }

    return noFold ? line : ICAL.helpers.foldline(line);
  };

  /**
   * Handles escaping of property values that may contain:
   *
   *    COLON (:), SEMICOLON (;), or COMMA (,)
   *
   * If any of the above are present the result is wrapped
   * in double quotes.
   *
   * @function ICAL.stringify.propertyValue
   * @param {String} value      Raw property value
   * @return {String}           Given or escaped value when needed
   */
  stringify.propertyValue = function(value) {

    if ((helpers.unescapedIndexOf(value, ',') === -1) &&
        (helpers.unescapedIndexOf(value, ':') === -1) &&
        (helpers.unescapedIndexOf(value, ';') === -1)) {

      return value;
    }

    return '"' + value + '"';
  };

  /**
   * Converts an array of ical values into a single
   * string based on a type and a delimiter value (like ",").
   *
   * @function ICAL.stringify.multiValue
   * @param {Array} values      List of values to convert
   * @param {String} delim      Used to join the values (",", ";", ":")
   * @param {String} type       Lowecase ical value type
   *        (like boolean, date-time, etc..)
   * @param {?String} innerMulti If set, each value will again be processed
   *        Used for structured values
   * @param {ICAL.design.designSet} designSet
   *        The design data to use for this property
   *
   * @return {String}           iCalendar/vCard string for value
   */
  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
    var result = '';
    var len = values.length;
    var i = 0;

    for (; i < len; i++) {
      if (innerMulti && Array.isArray(values[i])) {
        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);
      } else {
        result += stringify.value(values[i], type, designSet, structuredValue);
      }

      if (i !== (len - 1)) {
        result += delim;
      }
    }

    return result;
  };

  /**
   * Processes a single ical value runs the associated "toICAL" method from the
   * design value type if available to convert the value.
   *
   * @function ICAL.stringify.value
   * @param {String|Number} value       A formatted value
   * @param {String} type               Lowercase iCalendar/vCard value type
   *  (like boolean, date-time, etc..)
   * @return {String}                   iCalendar/vCard value for single value
   */
  stringify.value = function(value, type, designSet, structuredValue) {
    if (type in designSet.value && 'toICAL' in designSet.value[type]) {
      return designSet.value[type].toICAL(value, structuredValue);
    }
    return value;
  };

  /**
   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that
   * hackers can disable the rfc6868 parsing if the really need to.
   *
   * @param {String} val        The value to unescape
   * @return {String}           The escaped value
   */
  stringify._rfc6868Unescape = function(val) {
    return val.replace(/[\n^"]/g, function(x) {
      return RFC6868_REPLACE_MAP[x];
    });
  };
  var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };

  return stringify;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * Contains various functions to parse iCalendar and vCard data.
 * @namespace
 */
ICAL.parse = (function() {
  'use strict';

  var CHAR = /[^ \t]/;
  var MULTIVALUE_DELIMITER = ',';
  var VALUE_DELIMITER = ':';
  var PARAM_DELIMITER = ';';
  var PARAM_NAME_DELIMITER = '=';
  var DEFAULT_VALUE_TYPE = 'unknown';
  var DEFAULT_PARAM_TYPE = 'text';

  var design = ICAL.design;
  var helpers = ICAL.helpers;

  /**
   * An error that occurred during parsing.
   *
   * @param {String} message        The error message
   * @memberof ICAL.parse
   * @extends {Error}
   * @class
   */
  function ParserError(message) {
    this.message = message;
    this.name = 'ParserError';

    try {
      throw new Error();
    } catch (e) {
      if (e.stack) {
        var split = e.stack.split('\n');
        split.shift();
        this.stack = split.join('\n');
      }
    }
  }

  ParserError.prototype = Error.prototype;

  /**
   * Parses iCalendar or vCard data into a raw jCal object. Consult
   * documentation on the {@tutorial layers|layers of parsing} for more
   * details.
   *
   * @function ICAL.parse
   * @variation function
   * @todo Fix the API to be more clear on the return type
   * @param {String} input      The string data to parse
   * @return {Object|Object[]}  A single jCal object, or an array thereof
   */
  function parser(input) {
    var state = {};
    var root = state.component = [];

    state.stack = [root];

    parser._eachLine(input, function(err, line) {
      parser._handleContentLine(line, state);
    });


    // when there are still items on the stack
    // throw a fatal error, a component was not closed
    // correctly in that case.
    if (state.stack.length > 1) {
      throw new ParserError(
        'invalid ical body. component began but did not end'
      );
    }

    state = null;

    return (root.length == 1 ? root[0] : root);
  }

  /**
   * Parse an iCalendar property value into the jCal for a single property
   *
   * @function ICAL.parse.property
   * @param {String} str
   *   The iCalendar property string to parse
   * @param {ICAL.design.designSet=} designSet
   *   The design data to use for this property
   * @return {Object}
   *   The jCal Object containing the property
   */
  parser.property = function(str, designSet) {
    var state = {
      component: [[], []],
      designSet: designSet || design.defaultSet
    };
    parser._handleContentLine(str, state);
    return state.component[1][0];
  };

  /**
   * Convenience method to parse a component. You can use ICAL.parse() directly
   * instead.
   *
   * @function ICAL.parse.component
   * @see ICAL.parse(function)
   * @param {String} str    The iCalendar component string to parse
   * @return {Object}       The jCal Object containing the component
   */
  parser.component = function(str) {
    return parser(str);
  };

  // classes & constants
  parser.ParserError = ParserError;

  /**
   * The state for parsing content lines from an iCalendar/vCard string.
   *
   * @private
   * @memberof ICAL.parse
   * @typedef {Object} parserState
   * @property {ICAL.design.designSet} designSet    The design set to use for parsing
   * @property {ICAL.Component[]} stack             The stack of components being processed
   * @property {ICAL.Component} component           The currently active component
   */


  /**
   * Handles a single line of iCalendar/vCard, updating the state.
   *
   * @private
   * @function ICAL.parse._handleContentLine
   * @param {String} line               The content line to process
   * @param {ICAL.parse.parserState}    The current state of the line parsing
   */
  parser._handleContentLine = function(line, state) {
    // break up the parts of the line
    var valuePos = line.indexOf(VALUE_DELIMITER);
    var paramPos = line.indexOf(PARAM_DELIMITER);

    var lastParamIndex;
    var lastValuePos;

    // name of property or begin/end
    var name;
    var value;
    // params is only overridden if paramPos !== -1.
    // we can't do params = params || {} later on
    // because it sacrifices ops.
    var params = {};

    /**
     * Different property cases
     *
     *
     * 1. RRULE:FREQ=foo
     *    // FREQ= is not a param but the value
     *
     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;
     *    // ROLE= is a param because : has not happened yet
     */
      // when the parameter delimiter is after the
      // value delimiter then it is not a parameter.

    if ((paramPos !== -1 && valuePos !== -1)) {
      // when the parameter delimiter is after the
      // value delimiter then it is not a parameter.
      if (paramPos > valuePos) {
        paramPos = -1;
      }
    }

    var parsedParams;
    if (paramPos !== -1) {
      name = line.substring(0, paramPos).toLowerCase();
      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
      if (parsedParams[2] == -1) {
        throw new ParserError("Invalid parameters in '" + line + "'");
      }
      params = parsedParams[0];
      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
      if ((lastValuePos =
        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
        value = line.substring(lastParamIndex + lastValuePos + 1);
      } else {
        throw new ParserError("Missing parameter value in '" + line + "'");
      }
    } else if (valuePos !== -1) {
      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)
      name = line.substring(0, valuePos).toLowerCase();
      value = line.substring(valuePos + 1);

      if (name === 'begin') {
        var newComponent = [value.toLowerCase(), [], []];
        if (state.stack.length === 1) {
          state.component.push(newComponent);
        } else {
          state.component[2].push(newComponent);
        }
        state.stack.push(state.component);
        state.component = newComponent;
        if (!state.designSet) {
          state.designSet = design.getDesignSet(state.component[0]);
        }
        return;
      } else if (name === 'end') {
        state.component = state.stack.pop();
        return;
      }
      // If it is not begin/end, then this is a property with an empty value,
      // which should be considered valid.
    } else {
      /**
       * Invalid line.
       * The rational to throw an error is we will
       * never be certain that the rest of the file
       * is sane and it is unlikely that we can serialize
       * the result correctly either.
       */
      throw new ParserError(
        'invalid line (no token ";" or ":") "' + line + '"'
      );
    }

    var valueType;
    var multiValue = false;
    var structuredValue = false;
    var propertyDetails;

    if (name in state.designSet.property) {
      propertyDetails = state.designSet.property[name];

      if ('multiValue' in propertyDetails) {
        multiValue = propertyDetails.multiValue;
      }

      if ('structuredValue' in propertyDetails) {
        structuredValue = propertyDetails.structuredValue;
      }

      if (value && 'detectType' in propertyDetails) {
        valueType = propertyDetails.detectType(value);
      }
    }

    // attempt to determine value
    if (!valueType) {
      if (!('value' in params)) {
        if (propertyDetails) {
          valueType = propertyDetails.defaultType;
        } else {
          valueType = DEFAULT_VALUE_TYPE;
        }
      } else {
        // possible to avoid this?
        valueType = params.value.toLowerCase();
      }
    }

    delete params.value;

    /**
     * Note on `var result` juggling:
     *
     * I observed that building the array in pieces has adverse
     * effects on performance, so where possible we inline the creation.
     * It is a little ugly but resulted in ~2000 additional ops/sec.
     */

    var result;
    if (multiValue && structuredValue) {
      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
      result = [name, params, valueType, value];
    } else if (multiValue) {
      result = [name, params, valueType];
      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
    } else if (structuredValue) {
      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
      result = [name, params, valueType, value];
    } else {
      value = parser._parseValue(value, valueType, state.designSet, false);
      result = [name, params, valueType, value];
    }
    // rfc6350 requires that in vCard 4.0 the first component is the VERSION
    // component with as value 4.0, note that 3.0 does not have this requirement.
    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&
            !(name === 'version' && value === '4.0')) {
      state.designSet = design.getDesignSet("vcard3");
    }
    state.component[1].push(result);
  };

  /**
   * Parse a value from the raw value into the jCard/jCal value.
   *
   * @private
   * @function ICAL.parse._parseValue
   * @param {String} value          Original value
   * @param {String} type           Type of value
   * @param {Object} designSet      The design data to use for this value
   * @return {Object} varies on type
   */
  parser._parseValue = function(value, type, designSet, structuredValue) {
    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {
      return designSet.value[type].fromICAL(value, structuredValue);
    }
    return value;
  };

  /**
   * Parse parameters from a string to object.
   *
   * @function ICAL.parse._parseParameters
   * @private
   * @param {String} line           A single unfolded line
   * @param {Numeric} start         Position to start looking for properties
   * @param {Object} designSet      The design data to use for this property
   * @return {Object} key/value pairs
   */
  parser._parseParameters = function(line, start, designSet) {
    var lastParam = start;
    var pos = 0;
    var delim = PARAM_NAME_DELIMITER;
    var result = {};
    var name, lcname;
    var value, valuePos = -1;
    var type, multiValue, mvdelim;

    // find the next '=' sign
    // use lastParam and pos to find name
    // check if " is used if so get value from "->"
    // then increment pos to find next ;

    while ((pos !== false) &&
           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {

      name = line.substr(lastParam + 1, pos - lastParam - 1);
      if (name.length == 0) {
        throw new ParserError("Empty parameter name in '" + line + "'");
      }
      lcname = name.toLowerCase();
      mvdelim = false;
      multiValue = false;

      if (lcname in designSet.param && designSet.param[lcname].valueType) {
        type = designSet.param[lcname].valueType;
      } else {
        type = DEFAULT_PARAM_TYPE;
      }

      if (lcname in designSet.param) {
        multiValue = designSet.param[lcname].multiValue;
        if (designSet.param[lcname].multiValueSeparateDQuote) {
          mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
        }
      }

      var nextChar = line[pos + 1];
      if (nextChar === '"') {
        valuePos = pos + 2;
        pos = helpers.unescapedIndexOf(line, '"', valuePos);
        if (multiValue && pos != -1) {
            var extendedValue = true;
            while (extendedValue) {
              if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                pos = helpers.unescapedIndexOf(line, '"', pos + 3);
              } else {
                extendedValue = false;
              }
            }
          }
        if (pos === -1) {
          throw new ParserError(
            'invalid line (no matching double quote) "' + line + '"'
          );
        }
        value = line.substr(valuePos, pos - valuePos);
        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
        if (lastParam === -1) {
          pos = false;
        }
      } else {
        valuePos = pos + 1;

        // move to next ";"
        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
        if (propValuePos !== -1 && nextPos > propValuePos) {
          // this is a delimiter in the property value, let's stop here
          nextPos = propValuePos;
          pos = false;
        } else if (nextPos === -1) {
          // no ";"
          if (propValuePos === -1) {
            nextPos = line.length;
          } else {
            nextPos = propValuePos;
          }
          pos = false;
        } else {
          lastParam = nextPos;
          pos = nextPos;
        }

        value = line.substr(valuePos, nextPos - valuePos);
      }

      value = parser._rfc6868Escape(value);
      if (multiValue) {
        var delimiter = mvdelim || multiValue;
        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
      } else {
        value = parser._parseValue(value, type, designSet);
      }

      if (multiValue && (lcname in result)) {
        if (Array.isArray(result[lcname])) {
          result[lcname].push(value);
        } else {
          result[lcname] = [
            result[lcname],
            value
          ];
        }
      } else {
        result[lcname] = value;
      }
    }
    return [result, value, valuePos];
  };

  /**
   * Internal helper for rfc6868. Exposing this on ICAL.parse so that
   * hackers can disable the rfc6868 parsing if the really need to.
   *
   * @function ICAL.parse._rfc6868Escape
   * @param {String} val        The value to escape
   * @return {String}           The escaped value
   */
  parser._rfc6868Escape = function(val) {
    return val.replace(/\^['n^]/g, function(x) {
      return RFC6868_REPLACE_MAP[x];
    });
  };
  var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };

  /**
   * Parse a multi value string. This function is used either for parsing
   * actual multi-value property's values, or for handling parameter values. It
   * can be used for both multi-value properties and structured value properties.
   *
   * @private
   * @function ICAL.parse._parseMultiValue
   * @param {String} buffer     The buffer containing the full value
   * @param {String} delim      The multi-value delimiter
   * @param {String} type       The value type to be parsed
   * @param {Array.<?>} result        The array to append results to, varies on value type
   * @param {String} innerMulti The inner delimiter to split each value with
   * @param {ICAL.design.designSet} designSet   The design data for this value
   * @return {?|Array.<?>}            Either an array of results, or the first result
   */
  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
    var pos = 0;
    var lastPos = 0;
    var value;
    if (delim.length === 0) {
      return buffer;
    }

    // split each piece
    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
      value = buffer.substr(lastPos, pos - lastPos);
      if (innerMulti) {
        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
      } else {
        value = parser._parseValue(value, type, designSet, structuredValue);
      }
      result.push(value);
      lastPos = pos + delim.length;
    }

    // on the last piece take the rest of string
    value = buffer.substr(lastPos);
    if (innerMulti) {
      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
    } else {
      value = parser._parseValue(value, type, designSet, structuredValue);
    }
    result.push(value);

    return result.length == 1 ? result[0] : result;
  };

  /**
   * Process a complete buffer of iCalendar/vCard data line by line, correctly
   * unfolding content. Each line will be processed with the given callback
   *
   * @private
   * @function ICAL.parse._eachLine
   * @param {String} buffer                         The buffer to process
   * @param {function(?String, String)} callback    The callback for each line
   */
  parser._eachLine = function(buffer, callback) {
    var len = buffer.length;
    var lastPos = buffer.search(CHAR);
    var pos = lastPos;
    var line;
    var firstChar;

    var newlineOffset;

    do {
      pos = buffer.indexOf('\n', lastPos) + 1;

      if (pos > 1 && buffer[pos - 2] === '\r') {
        newlineOffset = 2;
      } else {
        newlineOffset = 1;
      }

      if (pos === 0) {
        pos = len;
        newlineOffset = 0;
      }

      firstChar = buffer[lastPos];

      if (firstChar === ' ' || firstChar === '\t') {
        // add to line
        line += buffer.substr(
          lastPos + 1,
          pos - lastPos - (newlineOffset + 1)
        );
      } else {
        if (line)
          callback(null, line);
        // push line
        line = buffer.substr(
          lastPos,
          pos - lastPos - newlineOffset
        );
      }

      lastPos = pos;
    } while (pos !== len);

    // extra ending line
    line = line.trim();

    if (line.length)
      callback(null, line);
  };

  return parser;

}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.Component = (function() {
  'use strict';

  var PROPERTY_INDEX = 1;
  var COMPONENT_INDEX = 2;
  var NAME_INDEX = 0;

  /**
   * @classdesc
   * Wraps a jCal component, adding convenience methods to add, remove and
   * update subcomponents and properties.
   *
   * @class
   * @alias ICAL.Component
   * @param {Array|String} jCal         Raw jCal component data OR name of new
   *                                      component
   * @param {ICAL.Component} parent     Parent component to associate
   */
  function Component(jCal, parent) {
    if (typeof(jCal) === 'string') {
      // jCal spec (name, properties, components)
      jCal = [jCal, [], []];
    }

    // mostly for legacy reasons.
    this.jCal = jCal;

    this.parent = parent || null;
  }

  Component.prototype = {
    /**
     * Hydrated properties are inserted into the _properties array at the same
     * position as in the jCal array, so it is possible that the array contains
     * undefined values for unhydrdated properties. To avoid iterating the
     * array when checking if all properties have been hydrated, we save the
     * count here.
     *
     * @type {Number}
     * @private
     */
    _hydratedPropertyCount: 0,

    /**
     * The same count as for _hydratedPropertyCount, but for subcomponents
     *
     * @type {Number}
     * @private
     */
    _hydratedComponentCount: 0,

    /**
     * The name of this component
     * @readonly
     */
    get name() {
      return this.jCal[NAME_INDEX];
    },

    /**
     * The design set for this component, e.g. icalendar vs vcard
     *
     * @type {ICAL.design.designSet}
     * @private
     */
    get _designSet() {
      var parentDesign = this.parent && this.parent._designSet;
      return parentDesign || ICAL.design.getDesignSet(this.name);
    },

    _hydrateComponent: function(index) {
      if (!this._components) {
        this._components = [];
        this._hydratedComponentCount = 0;
      }

      if (this._components[index]) {
        return this._components[index];
      }

      var comp = new Component(
        this.jCal[COMPONENT_INDEX][index],
        this
      );

      this._hydratedComponentCount++;
      return (this._components[index] = comp);
    },

    _hydrateProperty: function(index) {
      if (!this._properties) {
        this._properties = [];
        this._hydratedPropertyCount = 0;
      }

      if (this._properties[index]) {
        return this._properties[index];
      }

      var prop = new ICAL.Property(
        this.jCal[PROPERTY_INDEX][index],
        this
      );

      this._hydratedPropertyCount++;
      return (this._properties[index] = prop);
    },

    /**
     * Finds first sub component, optionally filtered by name.
     *
     * @param {String=} name        Optional name to filter by
     * @return {?ICAL.Component}     The found subcomponent
     */
    getFirstSubcomponent: function(name) {
      if (name) {
        var i = 0;
        var comps = this.jCal[COMPONENT_INDEX];
        var len = comps.length;

        for (; i < len; i++) {
          if (comps[i][NAME_INDEX] === name) {
            var result = this._hydrateComponent(i);
            return result;
          }
        }
      } else {
        if (this.jCal[COMPONENT_INDEX].length) {
          return this._hydrateComponent(0);
        }
      }

      // ensure we return a value (strict mode)
      return null;
    },

    /**
     * Finds all sub components, optionally filtering by name.
     *
     * @param {String=} name            Optional name to filter by
     * @return {ICAL.Component[]}       The found sub components
     */
    getAllSubcomponents: function(name) {
      var jCalLen = this.jCal[COMPONENT_INDEX].length;
      var i = 0;

      if (name) {
        var comps = this.jCal[COMPONENT_INDEX];
        var result = [];

        for (; i < jCalLen; i++) {
          if (name === comps[i][NAME_INDEX]) {
            result.push(
              this._hydrateComponent(i)
            );
          }
        }
        return result;
      } else {
        if (!this._components ||
            (this._hydratedComponentCount !== jCalLen)) {
          for (; i < jCalLen; i++) {
            this._hydrateComponent(i);
          }
        }

        return this._components || [];
      }
    },

    /**
     * Returns true when a named property exists.
     *
     * @param {String} name     The property name
     * @return {Boolean}        True, when property is found
     */
    hasProperty: function(name) {
      var props = this.jCal[PROPERTY_INDEX];
      var len = props.length;

      var i = 0;
      for (; i < len; i++) {
        // 0 is property name
        if (props[i][NAME_INDEX] === name) {
          return true;
        }
      }

      return false;
    },

    /**
     * Finds the first property, optionally with the given name.
     *
     * @param {String=} name        Lowercase property name
     * @return {?ICAL.Property}     The found property
     */
    getFirstProperty: function(name) {
      if (name) {
        var i = 0;
        var props = this.jCal[PROPERTY_INDEX];
        var len = props.length;

        for (; i < len; i++) {
          if (props[i][NAME_INDEX] === name) {
            var result = this._hydrateProperty(i);
            return result;
          }
        }
      } else {
        if (this.jCal[PROPERTY_INDEX].length) {
          return this._hydrateProperty(0);
        }
      }

      return null;
    },

    /**
     * Returns first property's value, if available.
     *
     * @param {String=} name    Lowercase property name
     * @return {?String}        The found property value.
     */
    getFirstPropertyValue: function(name) {
      var prop = this.getFirstProperty(name);
      if (prop) {
        return prop.getFirstValue();
      }

      return null;
    },

    /**
     * Get all properties in the component, optionally filtered by name.
     *
     * @param {String=} name        Lowercase property name
     * @return {ICAL.Property[]}    List of properties
     */
    getAllProperties: function(name) {
      var jCalLen = this.jCal[PROPERTY_INDEX].length;
      var i = 0;

      if (name) {
        var props = this.jCal[PROPERTY_INDEX];
        var result = [];

        for (; i < jCalLen; i++) {
          if (name === props[i][NAME_INDEX]) {
            result.push(
              this._hydrateProperty(i)
            );
          }
        }
        return result;
      } else {
        if (!this._properties ||
            (this._hydratedPropertyCount !== jCalLen)) {
          for (; i < jCalLen; i++) {
            this._hydrateProperty(i);
          }
        }

        return this._properties || [];
      }
    },

    _removeObjectByIndex: function(jCalIndex, cache, index) {
      cache = cache || [];
      // remove cached version
      if (cache[index]) {
        var obj = cache[index];
        if ("parent" in obj) {
            obj.parent = null;
        }
      }

      cache.splice(index, 1);

      // remove it from the jCal
      this.jCal[jCalIndex].splice(index, 1);
    },

    _removeObject: function(jCalIndex, cache, nameOrObject) {
      var i = 0;
      var objects = this.jCal[jCalIndex];
      var len = objects.length;
      var cached = this[cache];

      if (typeof(nameOrObject) === 'string') {
        for (; i < len; i++) {
          if (objects[i][NAME_INDEX] === nameOrObject) {
            this._removeObjectByIndex(jCalIndex, cached, i);
            return true;
          }
        }
      } else if (cached) {
        for (; i < len; i++) {
          if (cached[i] && cached[i] === nameOrObject) {
            this._removeObjectByIndex(jCalIndex, cached, i);
            return true;
          }
        }
      }

      return false;
    },

    _removeAllObjects: function(jCalIndex, cache, name) {
      var cached = this[cache];

      // Unfortunately we have to run through all children to reset their
      // parent property.
      var objects = this.jCal[jCalIndex];
      var i = objects.length - 1;

      // descending search required because splice
      // is used and will effect the indices.
      for (; i >= 0; i--) {
        if (!name || objects[i][NAME_INDEX] === name) {
          this._removeObjectByIndex(jCalIndex, cached, i);
        }
      }
    },

    /**
     * Adds a single sub component.
     *
     * @param {ICAL.Component} component        The component to add
     * @return {ICAL.Component}                 The passed in component
     */
    addSubcomponent: function(component) {
      if (!this._components) {
        this._components = [];
        this._hydratedComponentCount = 0;
      }

      if (component.parent) {
        component.parent.removeSubcomponent(component);
      }

      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
      this._components[idx - 1] = component;
      this._hydratedComponentCount++;
      component.parent = this;
      return component;
    },

    /**
     * Removes a single component by name or the instance of a specific
     * component.
     *
     * @param {ICAL.Component|String} nameOrComp    Name of component, or component
     * @return {Boolean}                            True when comp is removed
     */
    removeSubcomponent: function(nameOrComp) {
      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);
      if (removed) {
        this._hydratedComponentCount--;
      }
      return removed;
    },

    /**
     * Removes all components or (if given) all components by a particular
     * name.
     *
     * @param {String=} name            Lowercase component name
     */
    removeAllSubcomponents: function(name) {
      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);
      this._hydratedComponentCount = 0;
      return removed;
    },

    /**
     * Adds an {@link ICAL.Property} to the component.
     *
     * @param {ICAL.Property} property      The property to add
     * @return {ICAL.Property}              The passed in property
     */
    addProperty: function(property) {
      if (!(property instanceof ICAL.Property)) {
        throw new TypeError('must instance of ICAL.Property');
      }

      if (!this._properties) {
        this._properties = [];
        this._hydratedPropertyCount = 0;
      }

      if (property.parent) {
        property.parent.removeProperty(property);
      }

      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
      this._properties[idx - 1] = property;
      this._hydratedPropertyCount++;
      property.parent = this;
      return property;
    },

    /**
     * Helper method to add a property with a value to the component.
     *
     * @param {String}               name         Property name to add
     * @param {String|Number|Object} value        Property value
     * @return {ICAL.Property}                    The created property
     */
    addPropertyWithValue: function(name, value) {
      var prop = new ICAL.Property(name);
      prop.setValue(value);

      this.addProperty(prop);

      return prop;
    },

    /**
     * Helper method that will update or create a property of the given name
     * and sets its value. If multiple properties with the given name exist,
     * only the first is updated.
     *
     * @param {String}               name         Property name to update
     * @param {String|Number|Object} value        Property value
     * @return {ICAL.Property}                    The created property
     */
    updatePropertyWithValue: function(name, value) {
      var prop = this.getFirstProperty(name);

      if (prop) {
        prop.setValue(value);
      } else {
        prop = this.addPropertyWithValue(name, value);
      }

      return prop;
    },

    /**
     * Removes a single property by name or the instance of the specific
     * property.
     *
     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
     * @return {Boolean}                            True, when deleted
     */
    removeProperty: function(nameOrProp) {
      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);
      if (removed) {
        this._hydratedPropertyCount--;
      }
      return removed;
    },

    /**
     * Removes all properties associated with this component, optionally
     * filtered by name.
     *
     * @param {String=} name        Lowercase property name
     * @return {Boolean}            True, when deleted
     */
    removeAllProperties: function(name) {
      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);
      this._hydratedPropertyCount = 0;
      return removed;
    },

    /**
     * Returns the Object representation of this component. The returned object
     * is a live jCal object and should be cloned if modified.
     * @return {Object}
     */
    toJSON: function() {
      return this.jCal;
    },

    /**
     * The string representation of this component.
     * @return {String}
     */
    toString: function() {
      return ICAL.stringify.component(
        this.jCal, this._designSet
      );
    }
  };

  /**
   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.
   *
   * @param {String} str        The iCalendar string to parse
   */
  Component.fromString = function(str) {
    return new Component(ICAL.parse.component(str));
  };

  return Component;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.Property = (function() {
  'use strict';

  var NAME_INDEX = 0;
  var PROP_INDEX = 1;
  var TYPE_INDEX = 2;
  var VALUE_INDEX = 3;

  var design = ICAL.design;

  /**
   * @classdesc
   * Provides a layer on top of the raw jCal object for manipulating a single
   * property, with its parameters and value.
   *
   * @description
   * It is important to note that mutations done in the wrapper
   * directly mutate the jCal object used to initialize.
   *
   * Can also be used to create new properties by passing
   * the name of the property (as a String).
   *
   * @class
   * @alias ICAL.Property
   * @param {Array|String} jCal         Raw jCal representation OR
   *  the new name of the property
   *
   * @param {ICAL.Component=} parent    Parent component
   */
  function Property(jCal, parent) {
    this._parent = parent || null;

    if (typeof(jCal) === 'string') {
      // We are creating the property by name and need to detect the type
      this.jCal = [jCal, {}, design.defaultType];
      this.jCal[TYPE_INDEX] = this.getDefaultType();
    } else {
      this.jCal = jCal;
    }
    this._updateType();
  }

  Property.prototype = {

    /**
     * The value type for this property
     * @readonly
     * @type {String}
     */
    get type() {
      return this.jCal[TYPE_INDEX];
    },

    /**
     * The name of this property, in lowercase.
     * @readonly
     * @type {String}
     */
    get name() {
      return this.jCal[NAME_INDEX];
    },

    /**
     * The parent component for this property.
     * @type {ICAL.Component}
     */
    get parent() {
      return this._parent;
    },

    set parent(p) {
      // Before setting the parent, check if the design set has changed. If it
      // has, we later need to update the type if it was unknown before.
      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);

      this._parent = p;

      if (this.type == design.defaultType && designSetChanged) {
        this.jCal[TYPE_INDEX] = this.getDefaultType();
        this._updateType();
      }

      return p;
    },

    /**
     * The design set for this property, e.g. icalendar vs vcard
     *
     * @type {ICAL.design.designSet}
     * @private
     */
    get _designSet() {
      return this.parent ? this.parent._designSet : design.defaultSet;
    },

    /**
     * Updates the type metadata from the current jCal type and design set.
     *
     * @private
     */
    _updateType: function() {
      var designSet = this._designSet;

      if (this.type in designSet.value) {
        var designType = designSet.value[this.type];

        if ('decorate' in designSet.value[this.type]) {
          this.isDecorated = true;
        } else {
          this.isDecorated = false;
        }

        if (this.name in designSet.property) {
          this.isMultiValue = ('multiValue' in designSet.property[this.name]);
          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);
        }
      }
    },

    /**
     * Hydrate a single value. The act of hydrating means turning the raw jCal
     * value into a potentially wrapped object, for example {@link ICAL.Time}.
     *
     * @private
     * @param {Number} index        The index of the value to hydrate
     * @return {Object}             The decorated value.
     */
    _hydrateValue: function(index) {
      if (this._values && this._values[index]) {
        return this._values[index];
      }

      // for the case where there is no value.
      if (this.jCal.length <= (VALUE_INDEX + index)) {
        return null;
      }

      if (this.isDecorated) {
        if (!this._values) {
          this._values = [];
        }
        return (this._values[index] = this._decorate(
          this.jCal[VALUE_INDEX + index]
        ));
      } else {
        return this.jCal[VALUE_INDEX + index];
      }
    },

    /**
     * Decorate a single value, returning its wrapped object. This is used by
     * the hydrate function to actually wrap the value.
     *
     * @private
     * @param {?} value         The value to decorate
     * @return {Object}         The decorated value
     */
    _decorate: function(value) {
      return this._designSet.value[this.type].decorate(value, this);
    },

    /**
     * Undecorate a single value, returning its raw jCal data.
     *
     * @private
     * @param {Object} value         The value to undecorate
     * @return {?}                   The undecorated value
     */
    _undecorate: function(value) {
      return this._designSet.value[this.type].undecorate(value, this);
    },

    /**
     * Sets the value at the given index while also hydrating it. The passed
     * value can either be a decorated or undecorated value.
     *
     * @private
     * @param {?} value             The value to set
     * @param {Number} index        The index to set it at
     */
    _setDecoratedValue: function(value, index) {
      if (!this._values) {
        this._values = [];
      }

      if (typeof(value) === 'object' && 'icaltype' in value) {
        // decorated value
        this.jCal[VALUE_INDEX + index] = this._undecorate(value);
        this._values[index] = value;
      } else {
        // undecorated value
        this.jCal[VALUE_INDEX + index] = value;
        this._values[index] = this._decorate(value);
      }
    },

    /**
     * Gets a parameter on the property.
     *
     * @param {String}        name   Parameter name (lowercase)
     * @return {Array|String}        Parameter value
     */
    getParameter: function(name) {
      if (name in this.jCal[PROP_INDEX]) {
        return this.jCal[PROP_INDEX][name];
      } else {
        return undefined;
      }
    },

    /**
     * Gets first parameter on the property.
     *
     * @param {String}        name   Parameter name (lowercase)
     * @return {String}        Parameter value
     */
    getFirstParameter: function(name) {
      var parameters = this.getParameter(name);

      if (Array.isArray(parameters)) {
        return parameters[0];
      }

      return parameters;
    },

    /**
     * Sets a parameter on the property.
     *
     * @param {String}       name     The parameter name
     * @param {Array|String} value    The parameter value
     */
    setParameter: function(name, value) {
      var lcname = name.toLowerCase();
      if (typeof value === "string" &&
          lcname in this._designSet.param &&
          'multiValue' in this._designSet.param[lcname]) {
          value = [value];
      }
      this.jCal[PROP_INDEX][name] = value;
    },

    /**
     * Removes a parameter
     *
     * @param {String} name     The parameter name
     */
    removeParameter: function(name) {
      delete this.jCal[PROP_INDEX][name];
    },

    /**
     * Get the default type based on this property's name.
     *
     * @return {String}     The default type for this property
     */
    getDefaultType: function() {
      var name = this.jCal[NAME_INDEX];
      var designSet = this._designSet;

      if (name in designSet.property) {
        var details = designSet.property[name];
        if ('defaultType' in details) {
          return details.defaultType;
        }
      }
      return design.defaultType;
    },

    /**
     * Sets type of property and clears out any existing values of the current
     * type.
     *
     * @param {String} type     New iCAL type (see design.*.values)
     */
    resetType: function(type) {
      this.removeAllValues();
      this.jCal[TYPE_INDEX] = type;
      this._updateType();
    },

    /**
     * Finds the first property value.
     *
     * @return {String}         First property value
     */
    getFirstValue: function() {
      return this._hydrateValue(0);
    },

    /**
     * Gets all values on the property.
     *
     * NOTE: this creates an array during each call.
     *
     * @return {Array}          List of values
     */
    getValues: function() {
      var len = this.jCal.length - VALUE_INDEX;

      if (len < 1) {
        // it is possible for a property to have no value.
        return [];
      }

      var i = 0;
      var result = [];

      for (; i < len; i++) {
        result[i] = this._hydrateValue(i);
      }

      return result;
    },

    /**
     * Removes all values from this property
     */
    removeAllValues: function() {
      if (this._values) {
        this._values.length = 0;
      }
      this.jCal.length = 3;
    },

    /**
     * Sets the values of the property.  Will overwrite the existing values.
     * This can only be used for multi-value properties.
     *
     * @param {Array} values    An array of values
     */
    setValues: function(values) {
      if (!this.isMultiValue) {
        throw new Error(
          this.name + ': does not not support mulitValue.\n' +
          'override isMultiValue'
        );
      }

      var len = values.length;
      var i = 0;
      this.removeAllValues();

      if (len > 0 &&
          typeof(values[0]) === 'object' &&
          'icaltype' in values[0]) {
        this.resetType(values[0].icaltype);
      }

      if (this.isDecorated) {
        for (; i < len; i++) {
          this._setDecoratedValue(values[i], i);
        }
      } else {
        for (; i < len; i++) {
          this.jCal[VALUE_INDEX + i] = values[i];
        }
      }
    },

    /**
     * Sets the current value of the property. If this is a multi-value
     * property, all other values will be removed.
     *
     * @param {String|Object} value     New property value.
     */
    setValue: function(value) {
      this.removeAllValues();
      if (typeof(value) === 'object' && 'icaltype' in value) {
        this.resetType(value.icaltype);
      }

      if (this.isDecorated) {
        this._setDecoratedValue(value, 0);
      } else {
        this.jCal[VALUE_INDEX] = value;
      }
    },

    /**
     * Returns the Object representation of this component. The returned object
     * is a live jCal object and should be cloned if modified.
     * @return {Object}
     */
    toJSON: function() {
      return this.jCal;
    },

    /**
     * The string representation of this component.
     * @return {String}
     */
    toICALString: function() {
      return ICAL.stringify.property(
        this.jCal, this._designSet, true
      );
    }
  };

  /**
   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.
   *
   * @param {String} str                        The iCalendar string to parse
   * @param {ICAL.design.designSet=} designSet  The design data to use for this property
   * @return {ICAL.Property}                    The created iCalendar property
   */
  Property.fromString = function(str, designSet) {
    return new Property(ICAL.parse.property(str, designSet));
  };

  return Property;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.UtcOffset = (function() {

  /**
   * @classdesc
   * This class represents the "duration" value type, with various calculation
   * and manipulation methods.
   *
   * @class
   * @alias ICAL.UtcOffset
   * @param {Object} aData          An object with members of the utc offset
   * @param {Number=} aData.hours   The hours for the utc offset
   * @param {Number=} aData.minutes The minutes in the utc offset
   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
   */
  function UtcOffset(aData) {
    this.fromData(aData);
  }

  UtcOffset.prototype = {

    /**
     * The hours in the utc-offset
     * @type {Number}
     */
    hours: 0,

    /**
     * The minutes in the utc-offset
     * @type {Number}
     */
    minutes: 0,

    /**
     * The sign of the utc offset, 1 for positive offset, -1 for negative
     * offsets.
     * @type {Number}
     */
    factor: 1,

    /**
     * The type name, to be used in the jCal object.
     * @constant
     * @type {String}
     * @default "utc-offset"
     */
    icaltype: "utc-offset",

    /**
     * Returns a clone of the utc offset object.
     *
     * @return {ICAL.UtcOffset}     The cloned object
     */
    clone: function() {
      return ICAL.UtcOffset.fromSeconds(this.toSeconds());
    },

    /**
     * Sets up the current instance using members from the passed data object.
     *
     * @param {Object} aData          An object with members of the utc offset
     * @param {Number=} aData.hours   The hours for the utc offset
     * @param {Number=} aData.minutes The minutes in the utc offset
     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
     */
    fromData: function(aData) {
      if (aData) {
        for (var key in aData) {
          /* istanbul ignore else */
          if (aData.hasOwnProperty(key)) {
            this[key] = aData[key];
          }
        }
      }
      this._normalize();
    },

    /**
     * Sets up the current instance from the given seconds value. The seconds
     * value is truncated to the minute. Offsets are wrapped when the world
     * ends, the hour after UTC+14:00 is UTC-12:00.
     *
     * @param {Number} aSeconds         The seconds to convert into an offset
     */
    fromSeconds: function(aSeconds) {
      var secs = Math.abs(aSeconds);

      this.factor = aSeconds < 0 ? -1 : 1;
      this.hours = ICAL.helpers.trunc(secs / 3600);

      secs -= (this.hours * 3600);
      this.minutes = ICAL.helpers.trunc(secs / 60);
      return this;
    },

    /**
     * Convert the current offset to a value in seconds
     *
     * @return {Number}                 The offset in seconds
     */
    toSeconds: function() {
      return this.factor * (60 * this.minutes + 3600 * this.hours);
    },

    /**
     * Compare this utc offset with another one.
     *
     * @param {ICAL.UtcOffset} other        The other offset to compare with
     * @return {Number}                     -1, 0 or 1 for less/equal/greater
     */
    compare: function icaltime_compare(other) {
      var a = this.toSeconds();
      var b = other.toSeconds();
      return (a > b) - (b > a);
    },

    _normalize: function() {
      // Range: 97200 seconds (with 1 hour inbetween)
      var secs = this.toSeconds();
      var factor = this.factor;
      while (secs < -43200) { // = UTC-12:00
        secs += 97200;
      }
      while (secs > 50400) { // = UTC+14:00
        secs -= 97200;
      }

      this.fromSeconds(secs);

      // Avoid changing the factor when on zero seconds
      if (secs == 0) {
        this.factor = factor;
      }
    },

    /**
     * The iCalendar string representation of this utc-offset.
     * @return {String}
     */
    toICALString: function() {
      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());
    },

    /**
     * The string representation of this utc-offset.
     * @return {String}
     */
    toString: function toString() {
      return (this.factor == 1 ? "+" : "-") +
              ICAL.helpers.pad2(this.hours) + ':' +
              ICAL.helpers.pad2(this.minutes);
    }
  };

  /**
   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.
   *
   * @param {String} aString    The string to parse
   * @return {ICAL.Duration}    The created utc-offset instance
   */
  UtcOffset.fromString = function(aString) {
    // -05:00
    var options = {};
    //TODO: support seconds per rfc5545 ?
    options.factor = (aString[0] === '+') ? 1 : -1;
    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));
    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));

    return new ICAL.UtcOffset(options);
  };

  /**
   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds
   * value.
   *
   * @param {Number} aSeconds       The number of seconds to convert
   */
  UtcOffset.fromSeconds = function(aSeconds) {
    var instance = new UtcOffset();
    instance.fromSeconds(aSeconds);
    return instance;
  };

  return UtcOffset;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.Binary = (function() {

  /**
   * @classdesc
   * Represents the BINARY value type, which contains extra methods for
   * encoding and decoding.
   *
   * @class
   * @alias ICAL.Binary
   * @param {String} aValue     The binary data for this value
   */
  function Binary(aValue) {
    this.value = aValue;
  }

  Binary.prototype = {
    /**
     * The type name, to be used in the jCal object.
     * @default "binary"
     * @constant
     */
    icaltype: "binary",

    /**
     * Base64 decode the current value
     *
     * @return {String}         The base64-decoded value
     */
    decodeValue: function decodeValue() {
      return this._b64_decode(this.value);
    },

    /**
     * Encodes the passed parameter with base64 and sets the internal
     * value to the result.
     *
     * @param {String} aValue      The raw binary value to encode
     */
    setEncodedValue: function setEncodedValue(aValue) {
      this.value = this._b64_encode(aValue);
    },

    _b64_encode: function base64_encode(data) {
      // http://kevin.vanzonneveld.net
      // +   original by: Tyler Akins (http://rumkin.com)
      // +   improved by: Bayron Guevara
      // +   improved by: Thunder.m
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +   bugfixed by: Pellentesque Malesuada
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +   improved by: Rafał Kukawski (http://kukawski.pl)
      // *     example 1: base64_encode('Kevin van Zonneveld');
      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
      // mozilla has this native
      // - but breaks in 2.0.0.12!
      //if (typeof this.window['atob'] == 'function') {
      //    return atob(data);
      //}
      var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                "abcdefghijklmnopqrstuvwxyz0123456789+/=";
      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        enc = "",
        tmp_arr = [];

      if (!data) {
        return data;
      }

      do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1 << 16 | o2 << 8 | o3;

        h1 = bits >> 18 & 0x3f;
        h2 = bits >> 12 & 0x3f;
        h3 = bits >> 6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
      } while (i < data.length);

      enc = tmp_arr.join('');

      var r = data.length % 3;

      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

    },

    _b64_decode: function base64_decode(data) {
      // http://kevin.vanzonneveld.net
      // +   original by: Tyler Akins (http://rumkin.com)
      // +   improved by: Thunder.m
      // +      input by: Aman Gupta
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +   bugfixed by: Onno Marsman
      // +   bugfixed by: Pellentesque Malesuada
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +      input by: Brett Zamir (http://brett-zamir.me)
      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
      // *     returns 1: 'Kevin van Zonneveld'
      // mozilla has this native
      // - but breaks in 2.0.0.12!
      //if (typeof this.window['btoa'] == 'function') {
      //    return btoa(data);
      //}
      var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                "abcdefghijklmnopqrstuvwxyz0123456789+/=";
      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        dec = "",
        tmp_arr = [];

      if (!data) {
        return data;
      }

      data += '';

      do { // unpack four hexets into three octets using index points in b64
        h1 = b64.indexOf(data.charAt(i++));
        h2 = b64.indexOf(data.charAt(i++));
        h3 = b64.indexOf(data.charAt(i++));
        h4 = b64.indexOf(data.charAt(i++));

        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

        o1 = bits >> 16 & 0xff;
        o2 = bits >> 8 & 0xff;
        o3 = bits & 0xff;

        if (h3 == 64) {
          tmp_arr[ac++] = String.fromCharCode(o1);
        } else if (h4 == 64) {
          tmp_arr[ac++] = String.fromCharCode(o1, o2);
        } else {
          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
        }
      } while (i < data.length);

      dec = tmp_arr.join('');

      return dec;
    },

    /**
     * The string representation of this value
     * @return {String}
     */
    toString: function() {
      return this.value;
    }
  };

  /**
   * Creates a binary value from the given string.
   *
   * @param {String} aString        The binary value string
   * @return {ICAL.Binary}          The binary value instance
   */
  Binary.fromString = function(aString) {
    return new Binary(aString);
  };

  return Binary;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



(function() {
  /**
   * @classdesc
   * This class represents the "period" value type, with various calculation
   * and manipulation methods.
   *
   * @description
   * The passed data object cannot contain both and end date and a duration.
   *
   * @class
   * @param {Object} aData                  An object with members of the period
   * @param {ICAL.Time=} aData.start        The start of the period
   * @param {ICAL.Time=} aData.end          The end of the period
   * @param {ICAL.Duration=} aData.duration The duration of the period
   */
  ICAL.Period = function icalperiod(aData) {
    this.wrappedJSObject = this;

    if (aData && 'start' in aData) {
      if (aData.start && !(aData.start instanceof ICAL.Time)) {
        throw new TypeError('.start must be an instance of ICAL.Time');
      }
      this.start = aData.start;
    }

    if (aData && aData.end && aData.duration) {
      throw new Error('cannot accept both end and duration');
    }

    if (aData && 'end' in aData) {
      if (aData.end && !(aData.end instanceof ICAL.Time)) {
        throw new TypeError('.end must be an instance of ICAL.Time');
      }
      this.end = aData.end;
    }

    if (aData && 'duration' in aData) {
      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {
        throw new TypeError('.duration must be an instance of ICAL.Duration');
      }
      this.duration = aData.duration;
    }
  };

  ICAL.Period.prototype = {

    /**
     * The start of the period
     * @type {ICAL.Time}
     */
    start: null,

    /**
     * The end of the period
     * @type {ICAL.Time}
     */
    end: null,

    /**
     * The duration of the period
     * @type {ICAL.Duration}
     */
    duration: null,

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "icalperiod"
     */
    icalclass: "icalperiod",

    /**
     * The type name, to be used in the jCal object.
     * @constant
     * @type {String}
     * @default "period"
     */
    icaltype: "period",

    /**
     * Returns a clone of the duration object.
     *
     * @return {ICAL.Period}      The cloned object
     */
    clone: function() {
      return ICAL.Period.fromData({
        start: this.start ? this.start.clone() : null,
        end: this.end ? this.end.clone() : null,
        duration: this.duration ? this.duration.clone() : null
      });
    },

    /**
     * Calculates the duration of the period, either directly or by subtracting
     * start from end date.
     *
     * @return {ICAL.Duration}      The calculated duration
     */
    getDuration: function duration() {
      if (this.duration) {
        return this.duration;
      } else {
        return this.end.subtractDate(this.start);
      }
    },

    /**
     * Calculates the end date of the period, either directly or by adding
     * duration to start date.
     *
     * @return {ICAL.Time}          The calculated end date
     */
    getEnd: function() {
      if (this.end) {
        return this.end;
      } else {
        var end = this.start.clone();
        end.addDuration(this.duration);
        return end;
      }
    },

    /**
     * The string representation of this period.
     * @return {String}
     */
    toString: function toString() {
      return this.start + "/" + (this.end || this.duration);
    },

    /**
     * The jCal representation of this period type.
     * @return {Object}
     */
    toJSON: function() {
      return [this.start.toString(), (this.end || this.duration).toString()];
    },

    /**
     * The iCalendar string representation of this period.
     * @return {String}
     */
    toICALString: function() {
      return this.start.toICALString() + "/" +
             (this.end || this.duration).toICALString();
    }
  };

  /**
   * Creates a new {@link ICAL.Period} instance from the passed string.
   *
   * @param {String} str            The string to parse
   * @param {ICAL.Property} prop    The property this period will be on
   * @return {ICAL.Period}          The created period instance
   */
  ICAL.Period.fromString = function fromString(str, prop) {
    var parts = str.split('/');

    if (parts.length !== 2) {
      throw new Error(
        'Invalid string value: "' + str + '" must contain a "/" char.'
      );
    }

    var options = {
      start: ICAL.Time.fromDateTimeString(parts[0], prop)
    };

    var end = parts[1];

    if (ICAL.Duration.isValueString(end)) {
      options.duration = ICAL.Duration.fromString(end);
    } else {
      options.end = ICAL.Time.fromDateTimeString(end, prop);
    }

    return new ICAL.Period(options);
  };

  /**
   * Creates a new {@link ICAL.Period} instance from the given data object.
   * The passed data object cannot contain both and end date and a duration.
   *
   * @param {Object} aData                  An object with members of the period
   * @param {ICAL.Time=} aData.start        The start of the period
   * @param {ICAL.Time=} aData.end          The end of the period
   * @param {ICAL.Duration=} aData.duration The duration of the period
   * @return {ICAL.Period}                  The period instance
   */
  ICAL.Period.fromData = function fromData(aData) {
    return new ICAL.Period(aData);
  };

  /**
   * Returns a new period instance from the given jCal data array. The first
   * member is always the start date string, the second member is either a
   * duration or end date string.
   *
   * @param {Array<String,String>} aData    The jCal data array
   * @param {ICAL.Property} aProp           The property this jCal data is on
   * @param {Boolean} aLenient              If true, data value can be both date and date-time
   * @return {ICAL.Period}                  The period instance
   */
  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {
    function fromDateOrDateTimeString(aValue, aProp) {
      if (aLenient) {
        return ICAL.Time.fromString(aValue, aProp);
      } else {
        return ICAL.Time.fromDateTimeString(aValue, aProp);
      }
    }

    if (ICAL.Duration.isValueString(aData[1])) {
      return ICAL.Period.fromData({
        start: fromDateOrDateTimeString(aData[0], aProp),
        duration: ICAL.Duration.fromString(aData[1])
      });
    } else {
      return ICAL.Period.fromData({
        start: fromDateOrDateTimeString(aData[0], aProp),
        end: fromDateOrDateTimeString(aData[1], aProp)
      });
    }
  };
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



(function() {
  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;

  /**
   * @classdesc
   * This class represents the "duration" value type, with various calculation
   * and manipulation methods.
   *
   * @class
   * @alias ICAL.Duration
   * @param {Object} data               An object with members of the duration
   * @param {Number} data.weeks         Duration in weeks
   * @param {Number} data.days          Duration in days
   * @param {Number} data.hours         Duration in hours
   * @param {Number} data.minutes       Duration in minutes
   * @param {Number} data.seconds       Duration in seconds
   * @param {Boolean} data.isNegative   If true, the duration is negative
   */
  ICAL.Duration = function icalduration(data) {
    this.wrappedJSObject = this;
    this.fromData(data);
  };

  ICAL.Duration.prototype = {
    /**
     * The weeks in this duration
     * @type {Number}
     * @default 0
     */
    weeks: 0,

    /**
     * The days in this duration
     * @type {Number}
     * @default 0
     */
    days: 0,

    /**
     * The days in this duration
     * @type {Number}
     * @default 0
     */
    hours: 0,

    /**
     * The minutes in this duration
     * @type {Number}
     * @default 0
     */
    minutes: 0,

    /**
     * The seconds in this duration
     * @type {Number}
     * @default 0
     */
    seconds: 0,

    /**
     * The seconds in this duration
     * @type {Boolean}
     * @default false
     */
    isNegative: false,

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "icalduration"
     */
    icalclass: "icalduration",

    /**
     * The type name, to be used in the jCal object.
     * @constant
     * @type {String}
     * @default "duration"
     */
    icaltype: "duration",

    /**
     * Returns a clone of the duration object.
     *
     * @return {ICAL.Duration}      The cloned object
     */
    clone: function clone() {
      return ICAL.Duration.fromData(this);
    },

    /**
     * The duration value expressed as a number of seconds.
     *
     * @return {Number}             The duration value in seconds
     */
    toSeconds: function toSeconds() {
      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +
                    86400 * this.days + 7 * 86400 * this.weeks;
      return (this.isNegative ? -seconds : seconds);
    },

    /**
     * Reads the passed seconds value into this duration object. Afterwards,
     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
     * accordingly.
     *
     * @param {Number} aSeconds     The duration value in seconds
     * @return {ICAL.Duration}      Returns this instance
     */
    fromSeconds: function fromSeconds(aSeconds) {
      var secs = Math.abs(aSeconds);

      this.isNegative = (aSeconds < 0);
      this.days = ICAL.helpers.trunc(secs / 86400);

      // If we have a flat number of weeks, use them.
      if (this.days % 7 == 0) {
        this.weeks = this.days / 7;
        this.days = 0;
      } else {
        this.weeks = 0;
      }

      secs -= (this.days + 7 * this.weeks) * 86400;

      this.hours = ICAL.helpers.trunc(secs / 3600);
      secs -= this.hours * 3600;

      this.minutes = ICAL.helpers.trunc(secs / 60);
      secs -= this.minutes * 60;

      this.seconds = secs;
      return this;
    },

    /**
     * Sets up the current instance using members from the passed data object.
     *
     * @param {Object} aData               An object with members of the duration
     * @param {Number} aData.weeks         Duration in weeks
     * @param {Number} aData.days          Duration in days
     * @param {Number} aData.hours         Duration in hours
     * @param {Number} aData.minutes       Duration in minutes
     * @param {Number} aData.seconds       Duration in seconds
     * @param {Boolean} aData.isNegative   If true, the duration is negative
     */
    fromData: function fromData(aData) {
      var propsToCopy = ["weeks", "days", "hours",
                         "minutes", "seconds", "isNegative"];
      for (var key in propsToCopy) {
        /* istanbul ignore if */
        if (!propsToCopy.hasOwnProperty(key)) {
          continue;
        }
        var prop = propsToCopy[key];
        if (aData && prop in aData) {
          this[prop] = aData[prop];
        } else {
          this[prop] = 0;
        }
      }
    },

    /**
     * Resets the duration instance to the default values, i.e. PT0S
     */
    reset: function reset() {
      this.isNegative = false;
      this.weeks = 0;
      this.days = 0;
      this.hours = 0;
      this.minutes = 0;
      this.seconds = 0;
    },

    /**
     * Compares the duration instance with another one.
     *
     * @param {ICAL.Duration} aOther        The instance to compare with
     * @return {Number}                     -1, 0 or 1 for less/equal/greater
     */
    compare: function compare(aOther) {
      var thisSeconds = this.toSeconds();
      var otherSeconds = aOther.toSeconds();
      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
    },

    /**
     * Normalizes the duration instance. For example, a duration with a value
     * of 61 seconds will be normalized to 1 minute and 1 second.
     */
    normalize: function normalize() {
      this.fromSeconds(this.toSeconds());
    },

    /**
     * The string representation of this duration.
     * @return {String}
     */
    toString: function toString() {
      if (this.toSeconds() == 0) {
        return "PT0S";
      } else {
        var str = "";
        if (this.isNegative) str += "-";
        str += "P";
        if (this.weeks) str += this.weeks + "W";
        if (this.days) str += this.days + "D";

        if (this.hours || this.minutes || this.seconds) {
          str += "T";
          if (this.hours) str += this.hours + "H";
          if (this.minutes) str += this.minutes + "M";
          if (this.seconds) str += this.seconds + "S";
        }
        return str;
      }
    },

    /**
     * The iCalendar string representation of this duration.
     * @return {String}
     */
    toICALString: function() {
      return this.toString();
    }
  };

  /**
   * Returns a new ICAL.Duration instance from the passed seconds value.
   *
   * @param {Number} aSeconds       The seconds to create the instance from
   * @return {ICAL.Duration}        The newly created duration instance
   */
  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
    return (new ICAL.Duration()).fromSeconds(aSeconds);
  };

  /**
   * Internal helper function to handle a chunk of a duration.
   *
   * @param {String} letter type of duration chunk
   * @param {String} number numeric value or -/+
   * @param {Object} dict target to assign values to
   */
  function parseDurationChunk(letter, number, object) {
    var type;
    switch (letter) {
      case 'P':
        if (number && number === '-') {
          object.isNegative = true;
        } else {
          object.isNegative = false;
        }
        // period
        break;
      case 'D':
        type = 'days';
        break;
      case 'W':
        type = 'weeks';
        break;
      case 'H':
        type = 'hours';
        break;
      case 'M':
        type = 'minutes';
        break;
      case 'S':
        type = 'seconds';
        break;
      default:
        // Not a valid chunk
        return 0;
    }

    if (type) {
      if (!number && number !== 0) {
        throw new Error(
          'invalid duration value: Missing number before "' + letter + '"'
        );
      }
      var num = parseInt(number, 10);
      if (ICAL.helpers.isStrictlyNaN(num)) {
        throw new Error(
          'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
        );
      }
      object[type] = num;
    }

    return 1;
  }

  /**
   * Checks if the given string is an iCalendar duration value.
   *
   * @param {String} value      The raw ical value
   * @return {Boolean}          True, if the given value is of the
   *                              duration ical type
   */
  ICAL.Duration.isValueString = function(string) {
    return (string[0] === 'P' || string[1] === 'P');
  };

  /**
   * Creates a new {@link ICAL.Duration} instance from the passed string.
   *
   * @param {String} aStr       The string to parse
   * @return {ICAL.Duration}    The created duration instance
   */
  ICAL.Duration.fromString = function icalduration_from_string(aStr) {
    var pos = 0;
    var dict = Object.create(null);
    var chunks = 0;

    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
      var type = aStr[pos];
      var numeric = aStr.substr(0, pos);
      aStr = aStr.substr(pos + 1);

      chunks += parseDurationChunk(type, numeric, dict);
    }

    if (chunks < 2) {
      // There must be at least a chunk with "P" and some unit chunk
      throw new Error(
        'invalid duration value: Not enough duration components in "' + aStr + '"'
      );
    }

    return new ICAL.Duration(dict);
  };

  /**
   * Creates a new ICAL.Duration instance from the given data object.
   *
   * @param {Object} aData               An object with members of the duration
   * @param {Number} aData.weeks         Duration in weeks
   * @param {Number} aData.days          Duration in days
   * @param {Number} aData.hours         Duration in hours
   * @param {Number} aData.minutes       Duration in minutes
   * @param {Number} aData.seconds       Duration in seconds
   * @param {Boolean} aData.isNegative   If true, the duration is negative
   * @return {ICAL.Duration}             The createad duration instance
   */
  ICAL.Duration.fromData = function icalduration_from_data(aData) {
    return new ICAL.Duration(aData);
  };
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2012 */



(function() {
  var OPTIONS = ["tzid", "location", "tznames",
                 "latitude", "longitude"];

  /**
   * @classdesc
   * Timezone representation, created by passing in a tzid and component.
   *
   * @example
   * var vcalendar;
   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');
   * var tzid = timezoneComp.getFirstPropertyValue('tzid');
   *
   * var timezone = new ICAL.Timezone({
   *   component: timezoneComp,
   *   tzid
   * });
   *
   * @class
   * @param {ICAL.Component|Object} data options for class
   * @param {String|ICAL.Component} data.component
   *        If data is a simple object, then this member can be set to either a
   *        string containing the component data, or an already parsed
   *        ICAL.Component
   * @param {String} data.tzid      The timezone identifier
   * @param {String} data.location  The timezone locationw
   * @param {String} data.tznames   An alternative string representation of the
   *                                  timezone
   * @param {Number} data.latitude  The latitude of the timezone
   * @param {Number} data.longitude The longitude of the timezone
   */
  ICAL.Timezone = function icaltimezone(data) {
    this.wrappedJSObject = this;
    this.fromData(data);
  };

  ICAL.Timezone.prototype = {

    /**
     * Timezone identifier
     * @type {String}
     */
    tzid: "",

    /**
     * Timezone location
     * @type {String}
     */
    location: "",

    /**
     * Alternative timezone name, for the string representation
     * @type {String}
     */
    tznames: "",

    /**
     * The primary latitude for the timezone.
     * @type {Number}
     */
    latitude: 0.0,

    /**
     * The primary longitude for the timezone.
     * @type {Number}
     */
    longitude: 0.0,

    /**
     * The vtimezone component for this timezone.
     * @type {ICAL.Component}
     */
    component: null,

    /**
     * The year this timezone has been expanded to. All timezone transition
     * dates until this year are known and can be used for calculation
     *
     * @private
     * @type {Number}
     */
    expandedUntilYear: 0,

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "icaltimezone"
     */
    icalclass: "icaltimezone",

    /**
     * Sets up the current instance using members from the passed data object.
     *
     * @param {ICAL.Component|Object} aData options for class
     * @param {String|ICAL.Component} aData.component
     *        If aData is a simple object, then this member can be set to either a
     *        string containing the component data, or an already parsed
     *        ICAL.Component
     * @param {String} aData.tzid      The timezone identifier
     * @param {String} aData.location  The timezone locationw
     * @param {String} aData.tznames   An alternative string representation of the
     *                                  timezone
     * @param {Number} aData.latitude  The latitude of the timezone
     * @param {Number} aData.longitude The longitude of the timezone
     */
    fromData: function fromData(aData) {
      this.expandedUntilYear = 0;
      this.changes = [];

      if (aData instanceof ICAL.Component) {
        // Either a component is passed directly
        this.component = aData;
      } else {
        // Otherwise the component may be in the data object
        if (aData && "component" in aData) {
          if (typeof aData.component == "string") {
            // If a string was passed, parse it as a component
            var jCal = ICAL.parse(aData.component);
            this.component = new ICAL.Component(jCal);
          } else if (aData.component instanceof ICAL.Component) {
            // If it was a component already, then just set it
            this.component = aData.component;
          } else {
            // Otherwise just null out the component
            this.component = null;
          }
        }

        // Copy remaining passed properties
        for (var key in OPTIONS) {
          /* istanbul ignore else */
          if (OPTIONS.hasOwnProperty(key)) {
            var prop = OPTIONS[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            }
          }
        }
      }

      // If we have a component but no TZID, attempt to get it from the
      // component's properties.
      if (this.component instanceof ICAL.Component && !this.tzid) {
        this.tzid = this.component.getFirstPropertyValue('tzid');
      }

      return this;
    },

    /**
     * Finds the utcOffset the given time would occur in this timezone.
     *
     * @param {ICAL.Time} tt        The time to check for
     * @return {Number} utc offset in seconds
     */
    utcOffset: function utcOffset(tt) {
      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {
        return 0;
      }

      this._ensureCoverage(tt.year);

      if (!this.changes.length) {
        return 0;
      }

      var tt_change = {
        year: tt.year,
        month: tt.month,
        day: tt.day,
        hour: tt.hour,
        minute: tt.minute,
        second: tt.second
      };

      var change_num = this._findNearbyChange(tt_change);
      var change_num_to_use = -1;
      var step = 1;

      // TODO: replace with bin search?
      for (;;) {
        var change = ICAL.helpers.clone(this.changes[change_num], true);
        if (change.utcOffset < change.prevUtcOffset) {
          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
        } else {
          ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                          change.prevUtcOffset);
        }

        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);

        if (cmp >= 0) {
          change_num_to_use = change_num;
        } else {
          step = -1;
        }

        if (step == -1 && change_num_to_use != -1) {
          break;
        }

        change_num += step;

        if (change_num < 0) {
          return 0;
        }

        if (change_num >= this.changes.length) {
          break;
        }
      }

      var zone_change = this.changes[change_num_to_use];
      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;

      if (utcOffset_change < 0 && change_num_to_use > 0) {
        var tmp_change = ICAL.helpers.clone(zone_change, true);
        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,
                                        tmp_change.prevUtcOffset);

        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
          var prev_zone_change = this.changes[change_num_to_use - 1];

          var want_daylight = false; // TODO

          if (zone_change.is_daylight != want_daylight &&
              prev_zone_change.is_daylight == want_daylight) {
            zone_change = prev_zone_change;
          }
        }
      }

      // TODO return is_daylight?
      return zone_change.utcOffset;
    },

    _findNearbyChange: function icaltimezone_find_nearby_change(change) {
      // find the closest match
      var idx = ICAL.helpers.binsearchInsert(
        this.changes,
        change,
        ICAL.Timezone._compare_change_fn
      );

      if (idx >= this.changes.length) {
        return this.changes.length - 1;
      }

      return idx;
    },

    _ensureCoverage: function(aYear) {
      if (ICAL.Timezone._minimumExpansionYear == -1) {
        var today = ICAL.Time.now();
        ICAL.Timezone._minimumExpansionYear = today.year;
      }

      var changesEndYear = aYear;
      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {
        changesEndYear = ICAL.Timezone._minimumExpansionYear;
      }

      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;

      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {
        changesEndYear = ICAL.Timezone.MAX_YEAR;
      }

      if (!this.changes.length || this.expandedUntilYear < aYear) {
        var subcomps = this.component.getAllSubcomponents();
        var compLen = subcomps.length;
        var compIdx = 0;

        for (; compIdx < compLen; compIdx++) {
          this._expandComponent(
            subcomps[compIdx], changesEndYear, this.changes
          );
        }

        this.changes.sort(ICAL.Timezone._compare_change_fn);
        this.expandedUntilYear = changesEndYear;
      }
    },

    _expandComponent: function(aComponent, aYear, changes) {
      if (!aComponent.hasProperty("dtstart") ||
          !aComponent.hasProperty("tzoffsetto") ||
          !aComponent.hasProperty("tzoffsetfrom")) {
        return null;
      }

      var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
      var change;

      function convert_tzoffset(offset) {
        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
      }

      function init_changes() {
        var changebase = {};
        changebase.is_daylight = (aComponent.name == "daylight");
        changebase.utcOffset = convert_tzoffset(
          aComponent.getFirstProperty("tzoffsetto").getFirstValue()
        );

        changebase.prevUtcOffset = convert_tzoffset(
          aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
        );

        return changebase;
      }

      if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
        change = init_changes();
        change.year = dtstart.year;
        change.month = dtstart.month;
        change.day = dtstart.day;
        change.hour = dtstart.hour;
        change.minute = dtstart.minute;
        change.second = dtstart.second;

        ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                        -change.prevUtcOffset);
        changes.push(change);
      } else {
        var props = aComponent.getAllProperties("rdate");
        for (var rdatekey in props) {
          /* istanbul ignore if */
          if (!props.hasOwnProperty(rdatekey)) {
            continue;
          }
          var rdate = props[rdatekey];
          var time = rdate.getFirstValue();
          change = init_changes();

          change.year = time.year;
          change.month = time.month;
          change.day = time.day;

          if (time.isDate) {
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;

            if (dtstart.zone != ICAL.Timezone.utcTimezone) {
              ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                              -change.prevUtcOffset);
            }
          } else {
            change.hour = time.hour;
            change.minute = time.minute;
            change.second = time.second;

            if (time.zone != ICAL.Timezone.utcTimezone) {
              ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                              -change.prevUtcOffset);
            }
          }

          changes.push(change);
        }

        var rrule = aComponent.getFirstProperty("rrule");

        if (rrule) {
          rrule = rrule.getFirstValue();
          change = init_changes();

          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {
            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
            rrule.until.zone = ICAL.Timezone.localTimezone;
          }

          var iterator = rrule.iterator(dtstart);

          var occ;
          while ((occ = iterator.next())) {
            change = init_changes();
            if (occ.year > aYear || !occ) {
              break;
            }

            change.year = occ.year;
            change.month = occ.month;
            change.day = occ.day;
            change.hour = occ.hour;
            change.minute = occ.minute;
            change.second = occ.second;
            change.isDate = occ.isDate;

            ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                            -change.prevUtcOffset);
            changes.push(change);
          }
        }
      }

      return changes;
    },

    /**
     * The string representation of this timezone.
     * @return {String}
     */
    toString: function toString() {
      return (this.tznames ? this.tznames : this.tzid);
    }
  };

  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {
    if (a.year < b.year) return -1;
    else if (a.year > b.year) return 1;

    if (a.month < b.month) return -1;
    else if (a.month > b.month) return 1;

    if (a.day < b.day) return -1;
    else if (a.day > b.day) return 1;

    if (a.hour < b.hour) return -1;
    else if (a.hour > b.hour) return 1;

    if (a.minute < b.minute) return -1;
    else if (a.minute > b.minute) return 1;

    if (a.second < b.second) return -1;
    else if (a.second > b.second) return 1;

    return 0;
  };

  /**
   * Convert the date/time from one zone to the next.
   *
   * @param {ICAL.Time} tt                  The time to convert
   * @param {ICAL.Timezone} from_zone       The source zone to convert from
   * @param {ICAL.Timezone} to_zone         The target zone to convert to
   * @return {ICAL.Time}                    The converted date/time object
   */
  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
    if (tt.isDate ||
        from_zone.tzid == to_zone.tzid ||
        from_zone == ICAL.Timezone.localTimezone ||
        to_zone == ICAL.Timezone.localTimezone) {
      tt.zone = to_zone;
      return tt;
    }

    var utcOffset = from_zone.utcOffset(tt);
    tt.adjust(0, 0, 0, - utcOffset);

    utcOffset = to_zone.utcOffset(tt);
    tt.adjust(0, 0, 0, utcOffset);

    return null;
  };

  /**
   * Creates a new ICAL.Timezone instance from the passed data object.
   *
   * @param {ICAL.Component|Object} aData options for class
   * @param {String|ICAL.Component} aData.component
   *        If aData is a simple object, then this member can be set to either a
   *        string containing the component data, or an already parsed
   *        ICAL.Component
   * @param {String} aData.tzid      The timezone identifier
   * @param {String} aData.location  The timezone locationw
   * @param {String} aData.tznames   An alternative string representation of the
   *                                  timezone
   * @param {Number} aData.latitude  The latitude of the timezone
   * @param {Number} aData.longitude The longitude of the timezone
   */
  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {
    var tt = new ICAL.Timezone();
    return tt.fromData(aData);
  };

  /**
   * The instance describing the UTC timezone
   * @type {ICAL.Timezone}
   * @constant
   * @instance
   */
  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({
    tzid: "UTC"
  });

  /**
   * The instance describing the local timezone
   * @type {ICAL.Timezone}
   * @constant
   * @instance
   */
  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({
    tzid: "floating"
  });

  /**
   * Adjust a timezone change object.
   * @private
   * @param {Object} change     The timezone change object
   * @param {Number} days       The extra amount of days
   * @param {Number} hours      The extra amount of hours
   * @param {Number} minutes    The extra amount of minutes
   * @param {Number} seconds    The extra amount of seconds
   */
  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
    return ICAL.Time.prototype.adjust.call(
      change,
      days,
      hours,
      minutes,
      seconds,
      change
    );
  };

  ICAL.Timezone._minimumExpansionYear = -1;
  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?
  ICAL.Timezone.EXTRA_COVERAGE = 5;
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.TimezoneService = (function() {
  var zones;

  /**
   * @classdesc
   * Singleton class to contain timezones.  Right now it is all manual registry in
   * the future we may use this class to download timezone information or handle
   * loading pre-expanded timezones.
   *
   * @namespace
   * @alias ICAL.TimezoneService
   */
  var TimezoneService = {
    get count() {
      return Object.keys(zones).length;
    },

    reset: function() {
      zones = Object.create(null);
      var utc = ICAL.Timezone.utcTimezone;

      zones.Z = utc;
      zones.UTC = utc;
      zones.GMT = utc;
    },

    /**
     * Checks if timezone id has been registered.
     *
     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
     * @return {Boolean}        False, when not present
     */
    has: function(tzid) {
      return !!zones[tzid];
    },

    /**
     * Returns a timezone by its tzid if present.
     *
     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
     * @return {?ICAL.Timezone} The timezone, or null if not found
     */
    get: function(tzid) {
      return zones[tzid];
    },

    /**
     * Registers a timezone object or component.
     *
     * @param {String=} name
     *        The name of the timezone. Defaults to the component's TZID if not
     *        passed.
     * @param {ICAL.Component|ICAL.Timezone} zone
     *        The initialized zone or vtimezone.
     */
    register: function(name, timezone) {
      if (name instanceof ICAL.Component) {
        if (name.name === 'vtimezone') {
          timezone = new ICAL.Timezone(name);
          name = timezone.tzid;
        }
      }

      if (timezone instanceof ICAL.Timezone) {
        zones[name] = timezone;
      } else {
        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');
      }
    },

    /**
     * Removes a timezone by its tzid from the list.
     *
     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
     * @return {?ICAL.Timezone} The removed timezone, or null if not registered
     */
    remove: function(tzid) {
      return (delete zones[tzid]);
    }
  };

  // initialize defaults
  TimezoneService.reset();

  return TimezoneService;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



(function() {

  /**
   * @classdesc
   * iCalendar Time representation (similar to JS Date object).  Fully
   * independent of system (OS) timezone / time.  Unlike JS Date, the month
   * January is 1, not zero.
   *
   * @example
   * var time = new ICAL.Time({
   *   year: 2012,
   *   month: 10,
   *   day: 11
   *   minute: 0,
   *   second: 0,
   *   isDate: false
   * });
   *
   *
   * @alias ICAL.Time
   * @class
   * @param {Object} data           Time initialization
   * @param {Number=} data.year     The year for this date
   * @param {Number=} data.month    The month for this date
   * @param {Number=} data.day      The day for this date
   * @param {Number=} data.hour     The hour for this date
   * @param {Number=} data.minute   The minute for this date
   * @param {Number=} data.second   The second for this date
   * @param {Boolean=} data.isDate  If true, the instance represents a date (as
   *                                  opposed to a date-time)
   * @param {ICAL.Timezone} zone timezone this position occurs in
   */
  ICAL.Time = function icaltime(data, zone) {
    this.wrappedJSObject = this;
    var time = this._time = Object.create(null);

    /* time defaults */
    time.year = 0;
    time.month = 1;
    time.day = 1;
    time.hour = 0;
    time.minute = 0;
    time.second = 0;
    time.isDate = false;

    this.fromData(data, zone);
  };

  ICAL.Time._dowCache = {};
  ICAL.Time._wnCache = {};

  ICAL.Time.prototype = {

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "icaltime"
     */
    icalclass: "icaltime",
    _cachedUnixTime: null,

    /**
     * The type name, to be used in the jCal object. This value may change and
     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
     * @readonly
     * @type {String}
     * @default "date-time"
     */
    get icaltype() {
      return this.isDate ? 'date' : 'date-time';
    },

    /**
     * The timezone for this time.
     * @type {ICAL.Timezone}
     */
    zone: null,

    /**
     * Internal uses to indicate that a change has been made and the next read
     * operation must attempt to normalize the value (for example changing the
     * day to 33).
     *
     * @type {Boolean}
     * @private
     */
    _pendingNormalization: false,

    /**
     * Returns a clone of the time object.
     *
     * @return {ICAL.Time}              The cloned object
     */
    clone: function() {
      return new ICAL.Time(this._time, this.zone);
    },

    /**
     * Reset the time instance to epoch time
     */
    reset: function icaltime_reset() {
      this.fromData(ICAL.Time.epochTime);
      this.zone = ICAL.Timezone.utcTimezone;
    },

    /**
     * Reset the time instance to the given date/time values.
     *
     * @param {Number} year             The year to set
     * @param {Number} month            The month to set
     * @param {Number} day              The day to set
     * @param {Number} hour             The hour to set
     * @param {Number} minute           The minute to set
     * @param {Number} second           The second to set
     * @param {ICAL.Timezone} timezone  The timezone to set
     */
    resetTo: function icaltime_resetTo(year, month, day,
                                       hour, minute, second, timezone) {
      this.fromData({
        year: year,
        month: month,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        zone: timezone
      });
    },

    /**
     * Set up the current instance from the Javascript date value.
     *
     * @param {?Date} aDate     The Javascript Date to read, or null to reset
     * @param {Boolean} useUTC  If true, the UTC values of the date will be used
     */
    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
      if (!aDate) {
        this.reset();
      } else {
        if (useUTC) {
          this.zone = ICAL.Timezone.utcTimezone;
          this.year = aDate.getUTCFullYear();
          this.month = aDate.getUTCMonth() + 1;
          this.day = aDate.getUTCDate();
          this.hour = aDate.getUTCHours();
          this.minute = aDate.getUTCMinutes();
          this.second = aDate.getUTCSeconds();
        } else {
          this.zone = ICAL.Timezone.localTimezone;
          this.year = aDate.getFullYear();
          this.month = aDate.getMonth() + 1;
          this.day = aDate.getDate();
          this.hour = aDate.getHours();
          this.minute = aDate.getMinutes();
          this.second = aDate.getSeconds();
        }
      }
      this._cachedUnixTime = null;
      return this;
    },

    /**
     * Sets up the current instance using members from the passed data object.
     *
     * @param {Object} aData            Time initialization
     * @param {Number=} aData.year      The year for this date
     * @param {Number=} aData.month     The month for this date
     * @param {Number=} aData.day       The day for this date
     * @param {Number=} aData.hour      The hour for this date
     * @param {Number=} aData.minute    The minute for this date
     * @param {Number=} aData.second    The second for this date
     * @param {Boolean=} aData.isDate   If true, the instance represents a date
     *                                    (as opposed to a date-time)
     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
     */
    fromData: function fromData(aData, aZone) {
      if (aData) {
        for (var key in aData) {
          /* istanbul ignore else */
          if (Object.prototype.hasOwnProperty.call(aData, key)) {
            // ical type cannot be set
            if (key === 'icaltype') continue;
            this[key] = aData[key];
          }
        }
      }

      if (aZone) {
        this.zone = aZone;
      }

      if (aData && !("isDate" in aData)) {
        this.isDate = !("hour" in aData);
      } else if (aData && ("isDate" in aData)) {
        this.isDate = aData.isDate;
      }

      if (aData && "timezone" in aData) {
        var zone = ICAL.TimezoneService.get(
          aData.timezone
        );

        this.zone = zone || ICAL.Timezone.localTimezone;
      }

      if (aData && "zone" in aData) {
        this.zone = aData.zone;
      }

      if (!this.zone) {
        this.zone = ICAL.Timezone.localTimezone;
      }

      this._cachedUnixTime = null;
      return this;
    },

    /**
     * Calculate the day of week.
     * @param {ICAL.Time.weekDay=} aWeekStart
     *        The week start weekday, defaults to SUNDAY
     * @return {ICAL.Time.weekDay}
     */
    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
      var firstDow = aWeekStart || ICAL.Time.SUNDAY;
      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
      if (dowCacheKey in ICAL.Time._dowCache) {
        return ICAL.Time._dowCache[dowCacheKey];
      }

      // Using Zeller's algorithm
      var q = this.day;
      var m = this.month + (this.month < 3 ? 12 : 0);
      var Y = this.year - (this.month < 3 ? 1 : 0);

      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));
      /* istanbul ignore else */
      if (true /* gregorian */) {
        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);
      } else {}

      // Normalize to 1 = wkst
      h = ((h + 7 - firstDow) % 7) + 1;
      ICAL.Time._dowCache[dowCacheKey] = h;
      return h;
    },

    /**
     * Calculate the day of year.
     * @return {Number}
     */
    dayOfYear: function dayOfYear() {
      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);
      var diypm = ICAL.Time.daysInYearPassedMonth;
      return diypm[is_leap][this.month - 1] + this.day;
    },

    /**
     * Returns a copy of the current date/time, rewound to the start of the
     * week. The resulting ICAL.Time instance is of icaltype date, even if this
     * is a date-time.
     *
     * @param {ICAL.Time.weekDay=} aWeekStart
     *        The week start weekday, defaults to SUNDAY
     * @return {ICAL.Time}      The start of the week (cloned)
     */
    startOfWeek: function startOfWeek(aWeekStart) {
      var firstDow = aWeekStart || ICAL.Time.SUNDAY;
      var result = this.clone();
      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * Returns a copy of the current date/time, shifted to the end of the week.
     * The resulting ICAL.Time instance is of icaltype date, even if this is a
     * date-time.
     *
     * @param {ICAL.Time.weekDay=} aWeekStart
     *        The week start weekday, defaults to SUNDAY
     * @return {ICAL.Time}      The end of the week (cloned)
     */
    endOfWeek: function endOfWeek(aWeekStart) {
      var firstDow = aWeekStart || ICAL.Time.SUNDAY;
      var result = this.clone();
      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * Returns a copy of the current date/time, rewound to the start of the
     * month. The resulting ICAL.Time instance is of icaltype date, even if
     * this is a date-time.
     *
     * @return {ICAL.Time}      The start of the month (cloned)
     */
    startOfMonth: function startOfMonth() {
      var result = this.clone();
      result.day = 1;
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * Returns a copy of the current date/time, shifted to the end of the
     * month.  The resulting ICAL.Time instance is of icaltype date, even if
     * this is a date-time.
     *
     * @return {ICAL.Time}      The end of the month (cloned)
     */
    endOfMonth: function endOfMonth() {
      var result = this.clone();
      result.day = ICAL.Time.daysInMonth(result.month, result.year);
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * Returns a copy of the current date/time, rewound to the start of the
     * year. The resulting ICAL.Time instance is of icaltype date, even if
     * this is a date-time.
     *
     * @return {ICAL.Time}      The start of the year (cloned)
     */
    startOfYear: function startOfYear() {
      var result = this.clone();
      result.day = 1;
      result.month = 1;
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * Returns a copy of the current date/time, shifted to the end of the
     * year.  The resulting ICAL.Time instance is of icaltype date, even if
     * this is a date-time.
     *
     * @return {ICAL.Time}      The end of the year (cloned)
     */
    endOfYear: function endOfYear() {
      var result = this.clone();
      result.day = 31;
      result.month = 12;
      result.isDate = true;
      result.hour = 0;
      result.minute = 0;
      result.second = 0;
      return result;
    },

    /**
     * First calculates the start of the week, then returns the day of year for
     * this date. If the day falls into the previous year, the day is zero or negative.
     *
     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
     *        The week start weekday, defaults to SUNDAY
     * @return {Number}     The calculated day of year
     */
    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;
      var delta = this.dayOfWeek() - firstDow;
      if (delta < 0) delta += 7;
      return this.dayOfYear() - delta;
    },

    /**
     * Get the dominical letter for the current year. Letters range from A - G
     * for common years, and AG to GF for leap years.
     *
     * @param {Number} yr           The year to retrieve the letter for
     * @return {String}             The dominical letter.
     */
    getDominicalLetter: function() {
      return ICAL.Time.getDominicalLetter(this.year);
    },

    /**
     * Finds the nthWeekDay relative to the current month (not day).  The
     * returned value is a day relative the month that this month belongs to so
     * 1 would indicate the first of the month and 40 would indicate a day in
     * the following month.
     *
     * @param {Number} aDayOfWeek   Day of the week see the day name constants
     * @param {Number} aPos         Nth occurrence of a given week day values
     *        of 1 and 0 both indicate the first weekday of that type. aPos may
     *        be either positive or negative
     *
     * @return {Number} numeric value indicating a day relative
     *                   to the current month of this time object
     */
    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);
      var weekday;
      var pos = aPos;

      var start = 0;

      var otherDay = this.clone();

      if (pos >= 0) {
        otherDay.day = 1;

        // because 0 means no position has been given
        // 1 and 0 indicate the same day.
        if (pos != 0) {
          // remove the extra numeric value
          pos--;
        }

        // set current start offset to current day.
        start = otherDay.day;

        // find the current day of week
        var startDow = otherDay.dayOfWeek();

        // calculate the difference between current
        // day of the week and desired day of the week
        var offset = aDayOfWeek - startDow;


        // if the offset goes into the past
        // week we add 7 so it goes into the next
        // week. We only want to go forward in time here.
        if (offset < 0)
          // this is really important otherwise we would
          // end up with dates from in the past.
          offset += 7;

        // add offset to start so start is the same
        // day of the week as the desired day of week.
        start += offset;

        // because we are going to add (and multiply)
        // the numeric value of the day we subtract it
        // from the start position so not to add it twice.
        start -= aDayOfWeek;

        // set week day
        weekday = aDayOfWeek;
      } else {

        // then we set it to the last day in the current month
        otherDay.day = daysInMonth;

        // find the ends weekday
        var endDow = otherDay.dayOfWeek();

        pos++;

        weekday = (endDow - aDayOfWeek);

        if (weekday < 0) {
          weekday += 7;
        }

        weekday = daysInMonth - weekday;
      }

      weekday += pos * 7;

      return start + weekday;
    },

    /**
     * Checks if current time is the nth weekday, relative to the current
     * month.  Will always return false when rule resolves outside of current
     * month.
     *
     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
     * @param {Number} aPos                        Relative position
     * @return {Boolean}                           True, if it is the nth weekday
     */
    isNthWeekDay: function(aDayOfWeek, aPos) {
      var dow = this.dayOfWeek();

      if (aPos === 0 && dow === aDayOfWeek) {
        return true;
      }

      // get pos
      var day = this.nthWeekDay(aDayOfWeek, aPos);

      if (day === this.day) {
        return true;
      }

      return false;
    },

    /**
     * Calculates the ISO 8601 week number. The first week of a year is the
     * week that contains the first Thursday. The year can have 53 weeks, if
     * January 1st is a Friday.
     *
     * Note there are regions where the first week of the year is the one that
     * starts on January 1st, which may offset the week number. Also, if a
     * different week start is specified, this will also affect the week
     * number.
     *
     * @see ICAL.Time.weekOneStarts
     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
     * @return {Number}                             The ISO week number
     */
    weekNumber: function weekNumber(aWeekStart) {
      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
      if (wnCacheKey in ICAL.Time._wnCache) {
        return ICAL.Time._wnCache[wnCacheKey];
      }
      // This function courtesty of Julian Bucknall, published under the MIT license
      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html
      // plus some fixes to be able to use different week starts.
      var week1;

      var dt = this.clone();
      dt.isDate = true;
      var isoyear = this.year;

      if (dt.month == 12 && dt.day > 25) {
        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);
        if (dt.compare(week1) < 0) {
          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
        } else {
          isoyear++;
        }
      } else {
        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
        if (dt.compare(week1) < 0) {
          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);
        }
      }

      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);
      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;
      ICAL.Time._wnCache[wnCacheKey] = answer;
      return answer;
    },

    /**
     * Adds the duration to the current time. The instance is modified in
     * place.
     *
     * @param {ICAL.Duration} aDuration         The duration to add
     */
    addDuration: function icaltime_add(aDuration) {
      var mult = (aDuration.isNegative ? -1 : 1);

      // because of the duration optimizations it is much
      // more efficient to grab all the values up front
      // then set them directly (which will avoid a normalization call).
      // So we don't actually normalize until we need it.
      var second = this.second;
      var minute = this.minute;
      var hour = this.hour;
      var day = this.day;

      second += mult * aDuration.seconds;
      minute += mult * aDuration.minutes;
      hour += mult * aDuration.hours;
      day += mult * aDuration.days;
      day += mult * 7 * aDuration.weeks;

      this.second = second;
      this.minute = minute;
      this.hour = hour;
      this.day = day;

      this._cachedUnixTime = null;
    },

    /**
     * Subtract the date details (_excluding_ timezone).  Useful for finding
     * the relative difference between two time objects excluding their
     * timezone differences.
     *
     * @param {ICAL.Time} aDate     The date to substract
     * @return {ICAL.Duration}      The difference as a duration
     */
    subtractDate: function icaltime_subtract(aDate) {
      var unixTime = this.toUnixTime() + this.utcOffset();
      var other = aDate.toUnixTime() + aDate.utcOffset();
      return ICAL.Duration.fromSeconds(unixTime - other);
    },

    /**
     * Subtract the date details, taking timezones into account.
     *
     * @param {ICAL.Time} aDate  The date to subtract
     * @return {ICAL.Duration}  The difference in duration
     */
    subtractDateTz: function icaltime_subtract_abs(aDate) {
      var unixTime = this.toUnixTime();
      var other = aDate.toUnixTime();
      return ICAL.Duration.fromSeconds(unixTime - other);
    },

    /**
     * Compares the ICAL.Time instance with another one.
     *
     * @param {ICAL.Duration} aOther        The instance to compare with
     * @return {Number}                     -1, 0 or 1 for less/equal/greater
     */
    compare: function icaltime_compare(other) {
      var a = this.toUnixTime();
      var b = other.toUnixTime();

      if (a > b) return 1;
      if (b > a) return -1;
      return 0;
    },

    /**
     * Compares only the date part of this instance with another one.
     *
     * @param {ICAL.Duration} other         The instance to compare with
     * @param {ICAL.Timezone} tz            The timezone to compare in
     * @return {Number}                     -1, 0 or 1 for less/equal/greater
     */
    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
      function cmp(attr) {
        return ICAL.Time._cmp_attr(a, b, attr);
      }
      var a = this.convertToZone(tz);
      var b = other.convertToZone(tz);
      var rc = 0;

      if ((rc = cmp("year")) != 0) return rc;
      if ((rc = cmp("month")) != 0) return rc;
      if ((rc = cmp("day")) != 0) return rc;

      return rc;
    },

    /**
     * Convert the instance into another timezone. The returned ICAL.Time
     * instance is always a copy.
     *
     * @param {ICAL.Timezone} zone      The zone to convert to
     * @return {ICAL.Time}              The copy, converted to the zone
     */
    convertToZone: function convertToZone(zone) {
      var copy = this.clone();
      var zone_equals = (this.zone.tzid == zone.tzid);

      if (!this.isDate && !zone_equals) {
        ICAL.Timezone.convert_time(copy, this.zone, zone);
      }

      copy.zone = zone;
      return copy;
    },

    /**
     * Calculates the UTC offset of the current date/time in the timezone it is
     * in.
     *
     * @return {Number}     UTC offset in seconds
     */
    utcOffset: function utc_offset() {
      if (this.zone == ICAL.Timezone.localTimezone ||
          this.zone == ICAL.Timezone.utcTimezone) {
        return 0;
      } else {
        return this.zone.utcOffset(this);
      }
    },

    /**
     * Returns an RFC 5545 compliant ical representation of this object.
     *
     * @return {String} ical date/date-time
     */
    toICALString: function() {
      var string = this.toString();

      if (string.length > 10) {
        return ICAL.design.icalendar.value['date-time'].toICAL(string);
      } else {
        return ICAL.design.icalendar.value.date.toICAL(string);
      }
    },

    /**
     * The string representation of this date/time, in jCal form
     * (including : and - separators).
     * @return {String}
     */
    toString: function toString() {
      var result = this.year + '-' +
                   ICAL.helpers.pad2(this.month) + '-' +
                   ICAL.helpers.pad2(this.day);

      if (!this.isDate) {
          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +
                    ICAL.helpers.pad2(this.minute) + ':' +
                    ICAL.helpers.pad2(this.second);

        if (this.zone === ICAL.Timezone.utcTimezone) {
          result += 'Z';
        }
      }

      return result;
    },

    /**
     * Converts the current instance to a Javascript date
     * @return {Date}
     */
    toJSDate: function toJSDate() {
      if (this.zone == ICAL.Timezone.localTimezone) {
        if (this.isDate) {
          return new Date(this.year, this.month - 1, this.day);
        } else {
          return new Date(this.year, this.month - 1, this.day,
                          this.hour, this.minute, this.second, 0);
        }
      } else {
        return new Date(this.toUnixTime() * 1000);
      }
    },

    _normalize: function icaltime_normalize() {
      var isDate = this._time.isDate;
      if (this._time.isDate) {
        this._time.hour = 0;
        this._time.minute = 0;
        this._time.second = 0;
      }
      this.adjust(0, 0, 0, 0);

      return this;
    },

    /**
     * Adjust the date/time by the given offset
     *
     * @param {Number} aExtraDays       The extra amount of days
     * @param {Number} aExtraHours      The extra amount of hours
     * @param {Number} aExtraMinutes    The extra amount of minutes
     * @param {Number} aExtraSeconds    The extra amount of seconds
     * @param {Number=} aTime           The time to adjust, defaults to the
     *                                    current instance.
     */
    adjust: function icaltime_adjust(aExtraDays, aExtraHours,
                                     aExtraMinutes, aExtraSeconds, aTime) {

      var minutesOverflow, hoursOverflow,
          daysOverflow = 0, yearsOverflow = 0;

      var second, minute, hour, day;
      var daysInMonth;

      var time = aTime || this._time;

      if (!time.isDate) {
        second = time.second + aExtraSeconds;
        time.second = second % 60;
        minutesOverflow = ICAL.helpers.trunc(second / 60);
        if (time.second < 0) {
          time.second += 60;
          minutesOverflow--;
        }

        minute = time.minute + aExtraMinutes + minutesOverflow;
        time.minute = minute % 60;
        hoursOverflow = ICAL.helpers.trunc(minute / 60);
        if (time.minute < 0) {
          time.minute += 60;
          hoursOverflow--;
        }

        hour = time.hour + aExtraHours + hoursOverflow;

        time.hour = hour % 24;
        daysOverflow = ICAL.helpers.trunc(hour / 24);
        if (time.hour < 0) {
          time.hour += 24;
          daysOverflow--;
        }
      }


      // Adjust month and year first, because we need to know what month the day
      // is in before adjusting it.
      if (time.month > 12) {
        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);
      } else if (time.month < 1) {
        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;
      }

      time.year += yearsOverflow;
      time.month -= 12 * yearsOverflow;

      // Now take care of the days (and adjust month if needed)
      day = time.day + aExtraDays + daysOverflow;

      if (day > 0) {
        for (;;) {
          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);
          if (day <= daysInMonth) {
            break;
          }

          time.month++;
          if (time.month > 12) {
            time.year++;
            time.month = 1;
          }

          day -= daysInMonth;
        }
      } else {
        while (day <= 0) {
          if (time.month == 1) {
            time.year--;
            time.month = 12;
          } else {
            time.month--;
          }

          day += ICAL.Time.daysInMonth(time.month, time.year);
        }
      }

      time.day = day;

      this._cachedUnixTime = null;
      return this;
    },

    /**
     * Sets up the current instance from unix time, the number of seconds since
     * January 1st, 1970.
     *
     * @param {Number} seconds      The seconds to set up with
     */
    fromUnixTime: function fromUnixTime(seconds) {
      this.zone = ICAL.Timezone.utcTimezone;
      var epoch = ICAL.Time.epochTime.clone();
      epoch.adjust(0, 0, 0, seconds);

      this.year = epoch.year;
      this.month = epoch.month;
      this.day = epoch.day;
      this.hour = epoch.hour;
      this.minute = epoch.minute;
      this.second = Math.floor(epoch.second);

      this._cachedUnixTime = null;
    },

    /**
     * Converts the current instance to seconds since January 1st 1970.
     *
     * @return {Number}         Seconds since 1970
     */
    toUnixTime: function toUnixTime() {
      if (this._cachedUnixTime !== null) {
        return this._cachedUnixTime;
      }
      var offset = this.utcOffset();

      // we use the offset trick to ensure
      // that we are getting the actual UTC time
      var ms = Date.UTC(
        this.year,
        this.month - 1,
        this.day,
        this.hour,
        this.minute,
        this.second - offset
      );

      // seconds
      this._cachedUnixTime = ms / 1000;
      return this._cachedUnixTime;
    },

    /**
     * Converts time to into Object which can be serialized then re-created
     * using the constructor.
     *
     * @example
     * // toJSON will automatically be called
     * var json = JSON.stringify(mytime);
     *
     * var deserialized = JSON.parse(json);
     *
     * var time = new ICAL.Time(deserialized);
     *
     * @return {Object}
     */
    toJSON: function() {
      var copy = [
        'year',
        'month',
        'day',
        'hour',
        'minute',
        'second',
        'isDate'
      ];

      var result = Object.create(null);

      var i = 0;
      var len = copy.length;
      var prop;

      for (; i < len; i++) {
        prop = copy[i];
        result[prop] = this[prop];
      }

      if (this.zone) {
        result.timezone = this.zone.tzid;
      }

      return result;
    }

  };

  (function setupNormalizeAttributes() {
    // This needs to run before any instances are created!
    function defineAttr(attr) {
      Object.defineProperty(ICAL.Time.prototype, attr, {
        get: function getTimeAttr() {
          if (this._pendingNormalization) {
            this._normalize();
            this._pendingNormalization = false;
          }

          return this._time[attr];
        },
        set: function setTimeAttr(val) {
          // Check if isDate will be set and if was not set to normalize date.
          // This avoids losing days when seconds, minutes and hours are zeroed
          // what normalize will do when time is a date.
          if (attr === "isDate" && val && !this._time.isDate) {
            this.adjust(0, 0, 0, 0);
          }
          this._cachedUnixTime = null;
          this._pendingNormalization = true;
          this._time[attr] = val;

          return val;
        }
      });

    }

    /* istanbul ignore else */
    if ("defineProperty" in Object) {
      defineAttr("year");
      defineAttr("month");
      defineAttr("day");
      defineAttr("hour");
      defineAttr("minute");
      defineAttr("second");
      defineAttr("isDate");
    }
  })();

  /**
   * Returns the days in the given month
   *
   * @param {Number} month      The month to check
   * @param {Number} year       The year to check
   * @return {Number}           The number of days in the month
   */
  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var days = 30;

    if (month < 1 || month > 12) return days;

    days = _daysInMonth[month];

    if (month == 2) {
      days += ICAL.Time.isLeapYear(year);
    }

    return days;
  };

  /**
   * Checks if the year is a leap year
   *
   * @param {Number} year       The year to check
   * @return {Boolean}          True, if the year is a leap year
   */
  ICAL.Time.isLeapYear = function isLeapYear(year) {
    if (year <= 1752) {
      return ((year % 4) == 0);
    } else {
      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));
    }
  };

  /**
   * Create a new ICAL.Time from the day of year and year. The date is returned
   * in floating timezone.
   *
   * @param {Number} aDayOfYear     The day of year
   * @param {Number} aYear          The year to create the instance in
   * @return {ICAL.Time}            The created instance with the calculated date
   */
  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
    var year = aYear;
    var doy = aDayOfYear;
    var tt = new ICAL.Time();
    tt.auto_normalize = false;
    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);

    if (doy < 1) {
      year--;
      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);
      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];
      return ICAL.Time.fromDayOfYear(doy, year);
    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {
      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);
      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];
      year++;
      return ICAL.Time.fromDayOfYear(doy, year);
    }

    tt.year = year;
    tt.isDate = true;

    for (var month = 11; month >= 0; month--) {
      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {
        tt.month = month + 1;
        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];
        break;
      }
    }

    tt.auto_normalize = true;
    return tt;
  };

  /**
   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
   *
   * @deprecated                Use {@link ICAL.Time.fromDateString} instead
   * @param {String} str        The string to create from
   * @return {ICAL.Time}        The date/time instance
   */
  ICAL.Time.fromStringv2 = function fromString(str) {
    return new ICAL.Time({
      year: parseInt(str.substr(0, 4), 10),
      month: parseInt(str.substr(5, 2), 10),
      day: parseInt(str.substr(8, 2), 10),
      isDate: true
    });
  };

  /**
   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
   *
   * @param {String} aValue     The string to create from
   * @return {ICAL.Time}        The date/time instance
   */
  ICAL.Time.fromDateString = function(aValue) {
    // Dates should have no timezone.
    // Google likes to sometimes specify Z on dates
    // we specifically ignore that to avoid issues.

    // YYYY-MM-DD
    // 2012-10-10
    return new ICAL.Time({
      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
      isDate: true
    });
  };

  /**
   * Returns a new ICAL.Time instance from a date-time string, e.g
   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up
   * from the property's TZID parameter.
   *
   * @param {String} aValue         The string to create from
   * @param {ICAL.Property=} prop   The property the date belongs to
   * @return {ICAL.Time}            The date/time instance
   */
  ICAL.Time.fromDateTimeString = function(aValue, prop) {
    if (aValue.length < 19) {
      throw new Error(
        'invalid date-time value: "' + aValue + '"'
      );
    }

    var zone;

    if (aValue[19] && aValue[19] === 'Z') {
      zone = 'Z';
    } else if (prop) {
      zone = prop.getParameter('tzid');
    }

    // 2012-10-10T10:10:10(Z)?
    var time = new ICAL.Time({
      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),
      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),
      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),
      timezone: zone
    });

    return time;
  };

  /**
   * Returns a new ICAL.Time instance from a date or date-time string,
   *
   * @param {String} aValue         The string to create from
   * @param {ICAL.Property=} prop   The property the date belongs to
   * @return {ICAL.Time}            The date/time instance
   */
  ICAL.Time.fromString = function fromString(aValue, aProperty) {
    if (aValue.length > 10) {
      return ICAL.Time.fromDateTimeString(aValue, aProperty);
    } else {
      return ICAL.Time.fromDateString(aValue);
    }
  };

  /**
   * Creates a new ICAL.Time instance from the given Javascript Date.
   *
   * @param {?Date} aDate     The Javascript Date to read, or null to reset
   * @param {Boolean} useUTC  If true, the UTC values of the date will be used
   */
  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
    var tt = new ICAL.Time();
    return tt.fromJSDate(aDate, useUTC);
  };

  /**
   * Creates a new ICAL.Time instance from the the passed data object.
   *
   * @param {Object} aData            Time initialization
   * @param {Number=} aData.year      The year for this date
   * @param {Number=} aData.month     The month for this date
   * @param {Number=} aData.day       The day for this date
   * @param {Number=} aData.hour      The hour for this date
   * @param {Number=} aData.minute    The minute for this date
   * @param {Number=} aData.second    The second for this date
   * @param {Boolean=} aData.isDate   If true, the instance represents a date
   *                                    (as opposed to a date-time)
   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
   */
  ICAL.Time.fromData = function fromData(aData, aZone) {
    var t = new ICAL.Time();
    return t.fromData(aData, aZone);
  };

  /**
   * Creates a new ICAL.Time instance from the current moment.
   * The instance is “floating” - has no timezone relation.
   * To create an instance considering the time zone, call
   * ICAL.Time.fromJSDate(new Date(), true)
   * @return {ICAL.Time}
   */
  ICAL.Time.now = function icaltime_now() {
    return ICAL.Time.fromJSDate(new Date(), false);
  };

  /**
   * Returns the date on which ISO week number 1 starts.
   *
   * @see ICAL.Time#weekNumber
   * @param {Number} aYear                  The year to search in
   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.
   * @return {ICAL.Time}                    The date on which week number 1 starts
   */
  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
    var t = ICAL.Time.fromData({
      year: aYear,
      month: 1,
      day: 1,
      isDate: true
    });

    var dow = t.dayOfWeek();
    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;
    if (dow > ICAL.Time.THURSDAY) {
      t.day += 7;
    }
    if (wkst > ICAL.Time.THURSDAY) {
      t.day -= 7;
    }

    t.day -= dow - wkst;

    return t;
  };

  /**
   * Get the dominical letter for the given year. Letters range from A - G for
   * common years, and AG to GF for leap years.
   *
   * @param {Number} yr           The year to retrieve the letter for
   * @return {String}             The dominical letter.
   */
  ICAL.Time.getDominicalLetter = function(yr) {
    var LTRS = "GFEDCBA";
    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
    var isLeap = ICAL.Time.isLeapYear(yr);
    if (isLeap) {
      return LTRS[(dom + 6) % 7] + LTRS[dom];
    } else {
      return LTRS[dom];
    }
  };

  /**
   * January 1st, 1970 as an ICAL.Time.
   * @type {ICAL.Time}
   * @constant
   * @instance
   */
  ICAL.Time.epochTime = ICAL.Time.fromData({
    year: 1970,
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    isDate: false,
    timezone: "Z"
  });

  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {
    if (a[attr] > b[attr]) return 1;
    if (a[attr] < b[attr]) return -1;
    return 0;
  };

  /**
   * The days that have passed in the year after a given month. The array has
   * two members, one being an array of passed days for non-leap years, the
   * other analog for leap years.
   * @example
   * var isLeapYear = ICAL.Time.isLeapYear(year);
   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];
   * @type {Array.<Array.<Number>>}
   */
  ICAL.Time.daysInYearPassedMonth = [
    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
  ];

  /**
   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via
   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...
   *
   * @typedef {Number} weekDay
   * @memberof ICAL.Time
   */

  ICAL.Time.SUNDAY = 1;
  ICAL.Time.MONDAY = 2;
  ICAL.Time.TUESDAY = 3;
  ICAL.Time.WEDNESDAY = 4;
  ICAL.Time.THURSDAY = 5;
  ICAL.Time.FRIDAY = 6;
  ICAL.Time.SATURDAY = 7;

  /**
   * The default weekday for the WKST part.
   * @constant
   * @default ICAL.Time.MONDAY
   */
  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2015 */



(function() {

  /**
   * Describes a vCard time, which has slight differences to the ICAL.Time.
   * Properties can be null if not specified, for example for dates with
   * reduced accuracy or truncation.
   *
   * Note that currently not all methods are correctly re-implemented for
   * VCardTime. For example, comparison will have undefined results when some
   * members are null.
   *
   * Also, normalization is not yet implemented for this class!
   *
   * @alias ICAL.VCardTime
   * @class
   * @extends {ICAL.Time}
   * @param {Object} data                           The data for the time instance
   * @param {Number=} data.year                     The year for this date
   * @param {Number=} data.month                    The month for this date
   * @param {Number=} data.day                      The day for this date
   * @param {Number=} data.hour                     The hour for this date
   * @param {Number=} data.minute                   The minute for this date
   * @param {Number=} data.second                   The second for this date
   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use
   * @param {String} icaltype                       The type for this date/time object
   */
  ICAL.VCardTime = function(data, zone, icaltype) {
    this.wrappedJSObject = this;
    var time = this._time = Object.create(null);

    time.year = null;
    time.month = null;
    time.day = null;
    time.hour = null;
    time.minute = null;
    time.second = null;

    this.icaltype = icaltype || "date-and-or-time";

    this.fromData(data, zone);
  };
  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "vcardtime"
     */
    icalclass: "vcardtime",

    /**
     * The type name, to be used in the jCal object.
     * @type {String}
     * @default "date-and-or-time"
     */
    icaltype: "date-and-or-time",

    /**
     * The timezone. This can either be floating, UTC, or an instance of
     * ICAL.UtcOffset.
     * @type {ICAL.Timezone|ICAL.UtcOFfset}
     */
    zone: null,

    /**
     * Returns a clone of the vcard date/time object.
     *
     * @return {ICAL.VCardTime}     The cloned object
     */
    clone: function() {
      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);
    },

    _normalize: function() {
      return this;
    },

    /**
     * @inheritdoc
     */
    utcOffset: function() {
      if (this.zone instanceof ICAL.UtcOffset) {
        return this.zone.toSeconds();
      } else {
        return ICAL.Time.prototype.utcOffset.apply(this, arguments);
      }
    },

    /**
     * Returns an RFC 6350 compliant representation of this object.
     *
     * @return {String}         vcard date/time string
     */
    toICALString: function() {
      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());
    },

    /**
     * The string representation of this date/time, in jCard form
     * (including : and - separators).
     * @return {String}
     */
    toString: function toString() {
      var p2 = ICAL.helpers.pad2;
      var y = this.year, m = this.month, d = this.day;
      var h = this.hour, mm = this.minute, s = this.second;

      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;
      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;

      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +
                     (hasMonth ? p2(m) : '') +
                     (hasDay ? '-' + p2(d) : '');
      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +
                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +
                     (hasMinute && hasSecond ? ':' : '') +
                     (hasSecond ? p2(s) : '');

      var zone;
      if (this.zone === ICAL.Timezone.utcTimezone) {
        zone = 'Z';
      } else if (this.zone instanceof ICAL.UtcOffset) {
        zone = this.zone.toString();
      } else if (this.zone === ICAL.Timezone.localTimezone) {
        zone = '';
      } else if (this.zone instanceof ICAL.Timezone) {
        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));
        zone = offset.toString();
      } else {
        zone = '';
      }

      switch (this.icaltype) {
        case "time":
          return timepart + zone;
        case "date-and-or-time":
        case "date-time":
          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);
        case "date":
          return datepart;
      }
      return null;
    }
  });

  /**
   * Returns a new ICAL.VCardTime instance from a date and/or time string.
   *
   * @param {String} aValue     The string to create from
   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time
   * @return {ICAL.VCardTime}   The date/time instance
   */
  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
    function part(v, s, e) {
      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;
    }
    var parts = aValue.split('T');
    var dt = parts[0], tmz = parts[1];
    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];
    var zone = splitzone[0], tm = splitzone[1];

    var stoi = ICAL.helpers.strictParseInt;
    var dtlen = dt ? dt.length : 0;
    var tmlen = tm ? tm.length : 0;

    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';
    var hasDashTime = tm && tm[0] == '-';

    var o = {
      year: hasDashDate ? null : part(dt, 0, 4),
      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,

      hour: hasDashTime ? null : part(tm, 0, 2),
      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
    };

    if (zone == 'Z') {
      zone = ICAL.Timezone.utcTimezone;
    } else if (zone && zone[3] == ':') {
      zone = ICAL.UtcOffset.fromString(zone);
    } else {
      zone = null;
    }

    return new ICAL.VCardTime(o, zone, aIcalType);
  };
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



(function() {
  var DOW_MAP = {
    SU: ICAL.Time.SUNDAY,
    MO: ICAL.Time.MONDAY,
    TU: ICAL.Time.TUESDAY,
    WE: ICAL.Time.WEDNESDAY,
    TH: ICAL.Time.THURSDAY,
    FR: ICAL.Time.FRIDAY,
    SA: ICAL.Time.SATURDAY
  };

  var REVERSE_DOW_MAP = {};
  for (var key in DOW_MAP) {
    /* istanbul ignore else */
    if (DOW_MAP.hasOwnProperty(key)) {
      REVERSE_DOW_MAP[DOW_MAP[key]] = key;
    }
  }

  var COPY_PARTS = ["BYSECOND", "BYMINUTE", "BYHOUR", "BYDAY",
                    "BYMONTHDAY", "BYYEARDAY", "BYWEEKNO",
                    "BYMONTH", "BYSETPOS"];

  /**
   * @classdesc
   * This class represents the "recur" value type, with various calculation
   * and manipulation methods.
   *
   * @class
   * @alias ICAL.Recur
   * @param {Object} data                               An object with members of the recurrence
   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
   * @param {Number=} data.interval                     The INTERVAL value
   * @param {ICAL.Time.weekDay=} data.wkst              The week start value
   * @param {ICAL.Time=} data.until                     The end of the recurrence set
   * @param {Number=} data.count                        The number of occurrences
   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
   * @param {Array.<String>=} data.byday                The BYDAY values
   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
   */
  ICAL.Recur = function icalrecur(data) {
    this.wrappedJSObject = this;
    this.parts = {};

    if (data && typeof(data) === 'object') {
      this.fromData(data);
    }
  };

  ICAL.Recur.prototype = {
    /**
     * An object holding the BY-parts of the recurrence rule
     * @type {Object}
     */
    parts: null,

    /**
     * The interval value for the recurrence rule.
     * @type {Number}
     */
    interval: 1,

    /**
     * The week start day
     *
     * @type {ICAL.Time.weekDay}
     * @default ICAL.Time.MONDAY
     */
    wkst: ICAL.Time.MONDAY,

    /**
     * The end of the recurrence
     * @type {?ICAL.Time}
     */
    until: null,

    /**
     * The maximum number of occurrences
     * @type {?Number}
     */
    count: null,

    /**
     * The frequency value.
     * @type {ICAL.Recur.frequencyValues}
     */
    freq: null,

    /**
     * The class identifier.
     * @constant
     * @type {String}
     * @default "icalrecur"
     */
    icalclass: "icalrecur",

    /**
     * The type name, to be used in the jCal object.
     * @constant
     * @type {String}
     * @default "recur"
     */
    icaltype: "recur",

    /**
     * Create a new iterator for this recurrence rule. The passed start date
     * must be the start date of the event, not the start of the range to
     * search in.
     *
     * @example
     * var recur = comp.getFirstPropertyValue('rrule');
     * var dtstart = comp.getFirstPropertyValue('dtstart');
     * var iter = recur.iterator(dtstart);
     * for (var next = iter.next(); next; next = iter.next()) {
     *   if (next.compare(rangeStart) < 0) {
     *     continue;
     *   }
     *   console.log(next.toString());
     * }
     *
     * @param {ICAL.Time} aStart        The item's start date
     * @return {ICAL.RecurIterator}     The recurrence iterator
     */
    iterator: function(aStart) {
      return new ICAL.RecurIterator({
        rule: this,
        dtstart: aStart
      });
    },

    /**
     * Returns a clone of the recurrence object.
     *
     * @return {ICAL.Recur}      The cloned object
     */
    clone: function clone() {
      return new ICAL.Recur(this.toJSON());
    },

    /**
     * Checks if the current rule is finite, i.e. has a count or until part.
     *
     * @return {Boolean}        True, if the rule is finite
     */
    isFinite: function isfinite() {
      return !!(this.count || this.until);
    },

    /**
     * Checks if the current rule has a count part, and not limited by an until
     * part.
     *
     * @return {Boolean}        True, if the rule is by count
     */
    isByCount: function isbycount() {
      return !!(this.count && !this.until);
    },

    /**
     * Adds a component (part) to the recurrence rule. This is not a component
     * in the sense of {@link ICAL.Component}, but a part of the recurrence
     * rule, i.e. BYMONTH.
     *
     * @param {String} aType            The name of the component part
     * @param {Array|String} aValue     The component value
     */
    addComponent: function addPart(aType, aValue) {
      var ucname = aType.toUpperCase();
      if (ucname in this.parts) {
        this.parts[ucname].push(aValue);
      } else {
        this.parts[ucname] = [aValue];
      }
    },

    /**
     * Sets the component value for the given by-part.
     *
     * @param {String} aType        The component part name
     * @param {Array} aValues       The component values
     */
    setComponent: function setComponent(aType, aValues) {
      this.parts[aType.toUpperCase()] = aValues.slice();
    },

    /**
     * Gets (a copy) of the requested component value.
     *
     * @param {String} aType        The component part name
     * @return {Array}              The component part value
     */
    getComponent: function getComponent(aType) {
      var ucname = aType.toUpperCase();
      return (ucname in this.parts ? this.parts[ucname].slice() : []);
    },

    /**
     * Retrieves the next occurrence after the given recurrence id. See the
     * guide on {@tutorial terminology} for more details.
     *
     * NOTE: Currently, this method iterates all occurrences from the start
     * date. It should not be called in a loop for performance reasons. If you
     * would like to get more than one occurrence, you can iterate the
     * occurrences manually, see the example on the
     * {@link ICAL.Recur#iterator iterator} method.
     *
     * @param {ICAL.Time} aStartTime        The start of the event series
     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
     * @return {ICAL.Time}                  The next occurrence after
     */
    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
      var iter = this.iterator(aStartTime);
      var next, cdt;

      do {
        next = iter.next();
      } while (next && next.compare(aRecurrenceId) <= 0);

      if (next && aRecurrenceId.zone) {
        next.zone = aRecurrenceId.zone;
      }

      return next;
    },

    /**
     * Sets up the current instance using members from the passed data object.
     *
     * @param {Object} data                               An object with members of the recurrence
     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
     * @param {Number=} data.interval                     The INTERVAL value
     * @param {ICAL.Time.weekDay=} data.wkst              The week start value
     * @param {ICAL.Time=} data.until                     The end of the recurrence set
     * @param {Number=} data.count                        The number of occurrences
     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
     * @param {Array.<String>=} data.byday                The BYDAY values
     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
     */
    fromData: function(data) {
      for (var key in data) {
        var uckey = key.toUpperCase();

        if (uckey in partDesign) {
          if (Array.isArray(data[key])) {
            this.parts[uckey] = data[key];
          } else {
            this.parts[uckey] = [data[key]];
          }
        } else {
          this[key] = data[key];
        }
      }

      if (this.interval && typeof this.interval != "number") {
        optionDesign.INTERVAL(this.interval, this);
      }

      if (this.wkst && typeof this.wkst != "number") {
        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);
      }

      if (this.until && !(this.until instanceof ICAL.Time)) {
        this.until = ICAL.Time.fromString(this.until);
      }
    },

    /**
     * The jCal representation of this recurrence type.
     * @return {Object}
     */
    toJSON: function() {
      var res = Object.create(null);
      res.freq = this.freq;

      if (this.count) {
        res.count = this.count;
      }

      if (this.interval > 1) {
        res.interval = this.interval;
      }

      for (var k in this.parts) {
        /* istanbul ignore if */
        if (!this.parts.hasOwnProperty(k)) {
          continue;
        }
        var kparts = this.parts[k];
        if (Array.isArray(kparts) && kparts.length == 1) {
          res[k.toLowerCase()] = kparts[0];
        } else {
          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);
        }
      }

      if (this.until) {
        res.until = this.until.toString();
      }
      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);
      }
      return res;
    },

    /**
     * The string representation of this recurrence rule.
     * @return {String}
     */
    toString: function icalrecur_toString() {
      // TODO retain order
      var str = "FREQ=" + this.freq;
      if (this.count) {
        str += ";COUNT=" + this.count;
      }
      if (this.interval > 1) {
        str += ";INTERVAL=" + this.interval;
      }
      for (var k in this.parts) {
        /* istanbul ignore else */
        if (this.parts.hasOwnProperty(k)) {
          str += ";" + k + "=" + this.parts[k];
        }
      }
      if (this.until) {
        str += ';UNTIL=' + this.until.toICALString();
      }
      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);
      }
      return str;
    }
  };

  function parseNumericValue(type, min, max, value) {
    var result = value;

    if (value[0] === '+') {
      result = value.substr(1);
    }

    result = ICAL.helpers.strictParseInt(result);

    if (min !== undefined && value < min) {
      throw new Error(
        type + ': invalid value "' + value + '" must be > ' + min
      );
    }

    if (max !== undefined && value > max) {
      throw new Error(
        type + ': invalid value "' + value + '" must be < ' + min
      );
    }

    return result;
  }

  /**
   * Convert an ical representation of a day (SU, MO, etc..)
   * into a numeric value of that day.
   *
   * @param {String} string     The iCalendar day name
   * @param {ICAL.Time.weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {Number}           Numeric value of given day
   */
  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
    //XXX: this is here so we can deal
    //     with possibly invalid string values.
    var firstDow = aWeekStart || ICAL.Time.SUNDAY;
    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;
  };

  /**
   * Convert a numeric day value into its ical representation (SU, MO, etc..)
   *
   * @param {Number} num        Numeric value of given day
   * @param {ICAL.Time.weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {String}           The ICAL day value, e.g SU,MO,...
   */
  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
    //XXX: this is here so we can deal with possibly invalid number values.
    //     Also, this allows consistent mapping between day numbers and day
    //     names for external users.
    var firstDow = aWeekStart || ICAL.Time.SUNDAY;
    var dow = (num + firstDow - ICAL.Time.SUNDAY);
    if (dow > 7) {
      dow -= 7;
    }
    return REVERSE_DOW_MAP[dow];
  };

  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;

  /**
   * Possible frequency values for the FREQ part
   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)
   *
   * @typedef {String} frequencyValues
   * @memberof ICAL.Recur
   */

  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',
                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];

  var optionDesign = {
    FREQ: function(value, dict, fmtIcal) {
      // yes this is actually equal or faster then regex.
      // upside here is we can enumerate the valid values.
      if (ALLOWED_FREQ.indexOf(value) !== -1) {
        dict.freq = value;
      } else {
        throw new Error(
          'invalid frequency "' + value + '" expected: "' +
          ALLOWED_FREQ.join(', ') + '"'
        );
      }
    },

    COUNT: function(value, dict, fmtIcal) {
      dict.count = ICAL.helpers.strictParseInt(value);
    },

    INTERVAL: function(value, dict, fmtIcal) {
      dict.interval = ICAL.helpers.strictParseInt(value);
      if (dict.interval < 1) {
        // 0 or negative values are not allowed, some engines seem to generate
        // it though. Assume 1 instead.
        dict.interval = 1;
      }
    },

    UNTIL: function(value, dict, fmtIcal) {
      if (value.length > 10) {
        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);
      } else {
        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);
      }
      if (!fmtIcal) {
        dict.until = ICAL.Time.fromString(dict.until);
      }
    },

    WKST: function(value, dict, fmtIcal) {
      if (VALID_DAY_NAMES.test(value)) {
        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);
      } else {
        throw new Error('invalid WKST value "' + value + '"');
      }
    }
  };

  var partDesign = {
    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),
    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),
    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),
    BYDAY: function(value) {
      if (VALID_BYDAY_PART.test(value)) {
        return value;
      } else {
        throw new Error('invalid BYDAY value "' + value + '"');
      }
    },
    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),
    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),
    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),
    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),
    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)
  };


  /**
   * Creates a new {@link ICAL.Recur} instance from the passed string.
   *
   * @param {String} string         The string to parse
   * @return {ICAL.Recur}           The created recurrence instance
   */
  ICAL.Recur.fromString = function(string) {
    var data = ICAL.Recur._stringToData(string, false);
    return new ICAL.Recur(data);
  };

  /**
   * Creates a new {@link ICAL.Recur} instance using members from the passed
   * data object.
   *
   * @param {Object} aData                              An object with members of the recurrence
   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value
   * @param {Number=} aData.interval                    The INTERVAL value
   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value
   * @param {ICAL.Time=} aData.until                    The end of the recurrence set
   * @param {Number=} aData.count                       The number of occurrences
   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part
   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part
   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part
   * @param {Array.<String>=} aData.byday               The BYDAY values
   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part
   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part
   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part
   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part
   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part
   */
  ICAL.Recur.fromData = function(aData) {
    return new ICAL.Recur(aData);
  };

  /**
   * Converts a recurrence string to a data object, suitable for the fromData
   * method.
   *
   * @param {String} string     The string to parse
   * @param {Boolean} fmtIcal   If true, the string is considered to be an
   *                              iCalendar string
   * @return {ICAL.Recur}       The recurrence instance
   */
  ICAL.Recur._stringToData = function(string, fmtIcal) {
    var dict = Object.create(null);

    // split is slower in FF but fast enough.
    // v8 however this is faster then manual split?
    var values = string.split(';');
    var len = values.length;

    for (var i = 0; i < len; i++) {
      var parts = values[i].split('=');
      var ucname = parts[0].toUpperCase();
      var lcname = parts[0].toLowerCase();
      var name = (fmtIcal ? lcname : ucname);
      var value = parts[1];

      if (ucname in partDesign) {
        var partArr = value.split(',');
        var partArrIdx = 0;
        var partArrLen = partArr.length;

        for (; partArrIdx < partArrLen; partArrIdx++) {
          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
        }
        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);
      } else if (ucname in optionDesign) {
        optionDesign[ucname](value, dict, fmtIcal);
      } else {
        // Don't swallow unknown values. Just set them as they are.
        dict[lcname] = value;
      }
    }

    return dict;
  };
})();
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.RecurIterator = (function() {

  /**
   * @classdesc
   * An iterator for a single recurrence rule. This class usually doesn't have
   * to be instanciated directly, the convenience method
   * {@link ICAL.Recur#iterator} can be used.
   *
   * @description
   * The options object may contain additional members when resuming iteration from a previous run
   *
   * @description
   * The options object may contain additional members when resuming iteration
   * from a previous run.
   *
   * @class
   * @alias ICAL.RecurIterator
   * @param {Object} options                The iterator options
   * @param {ICAL.Recur} options.rule       The rule to iterate.
   * @param {ICAL.Time} options.dtstart     The start date of the event.
   * @param {Boolean=} options.initialized  When true, assume that options are
   *        from a previously constructed iterator. Initialization will not be
   *        repeated.
   */
  function icalrecur_iterator(options) {
    this.fromData(options);
  }

  icalrecur_iterator.prototype = {

    /**
     * True when iteration is finished.
     * @type {Boolean}
     */
    completed: false,

    /**
     * The rule that is being iterated
     * @type {ICAL.Recur}
     */
    rule: null,

    /**
     * The start date of the event being iterated.
     * @type {ICAL.Time}
     */
    dtstart: null,

    /**
     * The last occurrence that was returned from the
     * {@link ICAL.RecurIterator#next} method.
     * @type {ICAL.Time}
     */
    last: null,

    /**
     * The sequence number from the occurrence
     * @type {Number}
     */
    occurrence_number: 0,

    /**
     * The indices used for the {@link ICAL.RecurIterator#by_data} object.
     * @type {Object}
     * @private
     */
    by_indices: null,

    /**
     * If true, the iterator has already been initialized
     * @type {Boolean}
     * @private
     */
    initialized: false,

    /**
     * The initializd by-data.
     * @type {Object}
     * @private
     */
    by_data: null,

    /**
     * The expanded yeardays
     * @type {Array}
     * @private
     */
    days: null,

    /**
     * The index in the {@link ICAL.RecurIterator#days} array.
     * @type {Number}
     * @private
     */
    days_index: 0,

    /**
     * Initialize the recurrence iterator from the passed data object. This
     * method is usually not called directly, you can initialize the iterator
     * through the constructor.
     *
     * @param {Object} options                The iterator options
     * @param {ICAL.Recur} options.rule       The rule to iterate.
     * @param {ICAL.Time} options.dtstart     The start date of the event.
     * @param {Boolean=} options.initialized  When true, assume that options are
     *        from a previously constructed iterator. Initialization will not be
     *        repeated.
     */
    fromData: function(options) {
      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);

      if (!this.rule) {
        throw new Error('iterator requires a (ICAL.Recur) rule');
      }

      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);

      if (!this.dtstart) {
        throw new Error('iterator requires a (ICAL.Time) dtstart');
      }

      if (options.by_data) {
        this.by_data = options.by_data;
      } else {
        this.by_data = ICAL.helpers.clone(this.rule.parts, true);
      }

      if (options.occurrence_number)
        this.occurrence_number = options.occurrence_number;

      this.days = options.days || [];
      if (options.last) {
        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);
      }

      this.by_indices = options.by_indices;

      if (!this.by_indices) {
        this.by_indices = {
          "BYSECOND": 0,
          "BYMINUTE": 0,
          "BYHOUR": 0,
          "BYDAY": 0,
          "BYMONTH": 0,
          "BYWEEKNO": 0,
          "BYMONTHDAY": 0
        };
      }

      this.initialized = options.initialized || false;

      if (!this.initialized) {
        this.init();
      }
    },

    /**
     * Intialize the iterator
     * @private
     */
    init: function icalrecur_iterator_init() {
      this.initialized = true;
      this.last = this.dtstart.clone();
      var parts = this.by_data;

      if ("BYDAY" in parts) {
        // libical does this earlier when the rule is loaded, but we postpone to
        // now so we can preserve the original order.
        this.sort_byday_rules(parts.BYDAY);
      }

      // If the BYYEARDAY appares, no other date rule part may appear
      if ("BYYEARDAY" in parts) {
        if ("BYMONTH" in parts || "BYWEEKNO" in parts ||
            "BYMONTHDAY" in parts || "BYDAY" in parts) {
          throw new Error("Invalid BYYEARDAY rule");
        }
      }

      // BYWEEKNO and BYMONTHDAY rule parts may not both appear
      if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
        throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
      }

      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor
      // BYWEEKNO may appear.
      if (this.rule.freq == "MONTHLY" &&
          ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
        throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
      }

      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor
      // BYYEARDAY may appear.
      if (this.rule.freq == "WEEKLY" &&
          ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
        throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
      }

      // BYYEARDAY may only appear in YEARLY rules
      if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
        throw new Error("BYYEARDAY may only appear in YEARLY rules");
      }

      this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
      this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
      this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
      this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
      this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);

      if (this.rule.freq == "WEEKLY") {
        if ("BYDAY" in parts) {
          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
          var pos = bydayParts[0];
          var dow = bydayParts[1];
          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {
            // Initial time is after first day of BYDAY data
            this.last.day += wkdy;
          }
        } else {
          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
          parts.BYDAY = [dayName];
        }
      }

      if (this.rule.freq == "YEARLY") {
        for (;;) {
          this.expand_year_days(this.last.year);
          if (this.days.length > 0) {
            break;
          }
          this.increment_year(this.rule.interval);
        }

        this._nextByYearDay();
      }

      if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
        var tempLast = null;
        var initLast = this.last.clone();
        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);

        // Check every weekday in BYDAY with relative dow and pos.
        for (var i in this.by_data.BYDAY) {
          /* istanbul ignore if */
          if (!this.by_data.BYDAY.hasOwnProperty(i)) {
            continue;
          }
          this.last = initLast.clone();
          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);
          var pos = bydayParts[0];
          var dow = bydayParts[1];
          var dayOfMonth = this.last.nthWeekDay(dow, pos);

          // If |pos| >= 6, the byday is invalid for a monthly rule.
          if (pos >= 6 || pos <= -6) {
            throw new Error("Malformed values in BYDAY part");
          }

          // If a Byday with pos=+/-5 is not in the current month it
          // must be searched in the next months.
          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
            // Skip if we have already found a "last" in this month.
            if (tempLast && tempLast.month == initLast.month) {
              continue;
            }
            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
              this.increment_month();
              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              dayOfMonth = this.last.nthWeekDay(dow, pos);
            }
          }

          this.last.day = dayOfMonth;
          if (!tempLast || this.last.compare(tempLast) < 0) {
            tempLast = this.last.clone();
          }
        }
        this.last = tempLast.clone();

        //XXX: This feels like a hack, but we need to initialize
        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles
        //     this case. It accepts a special flag which will avoid incrementing
        //     the initial value without the flag days that match the start time
        //     would be missed.
        if (this.has_by_data('BYMONTHDAY')) {
          this._byDayAndMonthDay(true);
        }

        if (this.last.day > daysInMonth || this.last.day == 0) {
          throw new Error("Malformed values in BYDAY part");
        }

      } else if (this.has_by_data("BYMONTHDAY")) {
        if (this.last.day < 0) {
          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
          this.last.day = daysInMonth + this.last.day + 1;
        }
      }

    },

    /**
     * Retrieve the next occurrence from the iterator.
     * @return {ICAL.Time}
     */
    next: function icalrecur_iterator_next() {
      var before = (this.last ? this.last.clone() : null);

      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||
          (this.rule.until && this.last.compare(this.rule.until) > 0)) {

        //XXX: right now this is just a flag and has no impact
        //     we can simplify the above case to check for completed later.
        this.completed = true;

        return null;
      }

      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
        // First of all, give the instance that was initialized
        this.occurrence_number++;
        return this.last;
      }


      var valid;
      do {
        valid = 1;

        switch (this.rule.freq) {
        case "SECONDLY":
          this.next_second();
          break;
        case "MINUTELY":
          this.next_minute();
          break;
        case "HOURLY":
          this.next_hour();
          break;
        case "DAILY":
          this.next_day();
          break;
        case "WEEKLY":
          this.next_week();
          break;
        case "MONTHLY":
          valid = this.next_month();
          break;
        case "YEARLY":
          this.next_year();
          break;

        default:
          return null;
        }
      } while (!this.check_contracting_rules() ||
               this.last.compare(this.dtstart) < 0 ||
               !valid);

      // TODO is this valid?
      if (this.last.compare(before) == 0) {
        throw new Error("Same occurrence found twice, protecting " +
                        "you from death by recursion");
      }

      if (this.rule.until && this.last.compare(this.rule.until) > 0) {
        this.completed = true;
        return null;
      } else {
        this.occurrence_number++;
        return this.last;
      }
    },

    next_second: function next_second() {
      return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
    },

    increment_second: function increment_second(inc) {
      return this.increment_generic(inc, "second", 60, "minute");
    },

    next_minute: function next_minute() {
      return this.next_generic("BYMINUTE", "MINUTELY",
                               "minute", "hour", "next_second");
    },

    increment_minute: function increment_minute(inc) {
      return this.increment_generic(inc, "minute", 60, "hour");
    },

    next_hour: function next_hour() {
      return this.next_generic("BYHOUR", "HOURLY", "hour",
                               "monthday", "next_minute");
    },

    increment_hour: function increment_hour(inc) {
      this.increment_generic(inc, "hour", 24, "monthday");
    },

    next_day: function next_day() {
      var has_by_day = ("BYDAY" in this.by_data);
      var this_freq = (this.rule.freq == "DAILY");

      if (this.next_hour() == 0) {
        return 0;
      }

      if (this_freq) {
        this.increment_monthday(this.rule.interval);
      } else {
        this.increment_monthday(1);
      }

      return 0;
    },

    next_week: function next_week() {
      var end_of_data = 0;

      if (this.next_weekday_by_week() == 0) {
        return end_of_data;
      }

      if (this.has_by_data("BYWEEKNO")) {
        var idx = ++this.by_indices.BYWEEKNO;

        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
          this.by_indices.BYWEEKNO = 0;
          end_of_data = 1;
        }

        // HACK should be first month of the year
        this.last.month = 1;
        this.last.day = 1;

        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];

        this.last.day += 7 * week_no;

        if (end_of_data) {
          this.increment_year(1);
        }
      } else {
        // Jump to the next week
        this.increment_monthday(7 * this.rule.interval);
      }

      return end_of_data;
    },

    /**
     * Normalize each by day rule for a given year/month.
     * Takes into account ordering and negative rules
     *
     * @private
     * @param {Number} year         Current year.
     * @param {Number} month        Current month.
     * @param {Array}  rules        Array of rules.
     *
     * @return {Array} sorted and normalized rules.
     *                 Negative rules will be expanded to their
     *                 correct positive values for easier processing.
     */
    normalizeByMonthDayRules: function(year, month, rules) {
      var daysInMonth = ICAL.Time.daysInMonth(month, year);

      // XXX: This is probably bad for performance to allocate
      //      a new array for each month we scan, if possible
      //      we should try to optimize this...
      var newRules = [];

      var ruleIdx = 0;
      var len = rules.length;
      var rule;

      for (; ruleIdx < len; ruleIdx++) {
        rule = rules[ruleIdx];

        // if this rule falls outside of given
        // month discard it.
        if (Math.abs(rule) > daysInMonth) {
          continue;
        }

        // negative case
        if (rule < 0) {
          // we add (not subtract it is a negative number)
          // one from the rule because 1 === last day of month
          rule = daysInMonth + (rule + 1);
        } else if (rule === 0) {
          // skip zero: it is invalid.
          continue;
        }

        // only add unique items...
        if (newRules.indexOf(rule) === -1) {
          newRules.push(rule);
        }

      }

      // unique and sort
      return newRules.sort(function(a, b) { return a - b; });
    },

    /**
     * NOTES:
     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
     * both conditions match a given date (this.last.day) iteration stops.
     *
     * @private
     * @param {Boolean=} isInit     When given true will not increment the
     *                                current day (this.last).
     */
    _byDayAndMonthDay: function(isInit) {
      var byMonthDay; // setup in initMonth
      var byDay = this.by_data.BYDAY;

      var date;
      var dateIdx = 0;
      var dateLen; // setup in initMonth
      var dayLen = byDay.length;

      // we are not valid by default
      var dataIsValid = 0;

      var daysInMonth;
      var self = this;
      // we need a copy of this, because a DateTime gets normalized
      // automatically if the day is out of range. At some points we
      // set the last day to 0 to start counting.
      var lastDay = this.last.day;

      function initMonth() {
        daysInMonth = ICAL.Time.daysInMonth(
          self.last.month, self.last.year
        );

        byMonthDay = self.normalizeByMonthDayRules(
          self.last.year,
          self.last.month,
          self.by_data.BYMONTHDAY
        );

        dateLen = byMonthDay.length;

        // For the case of more than one occurrence in one month
        // we have to be sure to start searching after the last
        // found date or at the last BYMONTHDAY, unless we are
        // initializing the iterator because in this case we have
        // to consider the last found date too.
        while (byMonthDay[dateIdx] <= lastDay &&
               !(isInit && byMonthDay[dateIdx] == lastDay) &&
               dateIdx < dateLen - 1) {
          dateIdx++;
        }
      }

      function nextMonth() {
        // since the day is incremented at the start
        // of the loop below, we need to start at 0
        lastDay = 0;
        self.increment_month();
        dateIdx = 0;
        initMonth();
      }

      initMonth();

      // should come after initMonth
      if (isInit) {
        lastDay -= 1;
      }

      // Use a counter to avoid an infinite loop with malformed rules.
      // Stop checking after 4 years so we consider also a leap year.
      var monthsCounter = 48;

      while (!dataIsValid && monthsCounter) {
        monthsCounter--;
        // increment the current date. This is really
        // important otherwise we may fall into the infinite
        // loop trap. The initial date takes care of the case
        // where the current date is the date we are looking
        // for.
        date = lastDay + 1;

        if (date > daysInMonth) {
          nextMonth();
          continue;
        }

        // find next date
        var next = byMonthDay[dateIdx++];

        // this logic is dependant on the BYMONTHDAYS
        // being in order (which is done by #normalizeByMonthDayRules)
        if (next >= date) {
          // if the next month day is in the future jump to it.
          lastDay = next;
        } else {
          // in this case the 'next' monthday has past
          // we must move to the month.
          nextMonth();
          continue;
        }

        // Now we can loop through the day rules to see
        // if one matches the current month date.
        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
          var parts = this.ruleDayOfWeek(byDay[dayIdx]);
          var pos = parts[0];
          var dow = parts[1];

          this.last.day = lastDay;
          if (this.last.isNthWeekDay(dow, pos)) {
            // when we find the valid one we can mark
            // the conditions as met and break the loop.
            // (Because we have this condition above
            //  it will also break the parent loop).
            dataIsValid = 1;
            break;
          }
        }

        // It is completely possible that the combination
        // cannot be matched in the current month.
        // When we reach the end of possible combinations
        // in the current month we iterate to the next one.
        // since dateIdx is incremented right after getting
        // "next", we don't need dateLen -1 here.
        if (!dataIsValid && dateIdx === dateLen) {
          nextMonth();
          continue;
        }
      }

      if (monthsCounter <= 0) {
        // Checked 4 years without finding a Byday that matches
        // a Bymonthday. Maybe the rule is not correct.
        throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
      }


      return dataIsValid;
    },

    next_month: function next_month() {
      var this_freq = (this.rule.freq == "MONTHLY");
      var data_valid = 1;

      if (this.next_hour() == 0) {
        return data_valid;
      }

      if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
        data_valid = this._byDayAndMonthDay();
      } else if (this.has_by_data("BYDAY")) {
        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
        var setpos = 0;
        var setpos_total = 0;

        if (this.has_by_data("BYSETPOS")) {
          var last_day = this.last.day;
          for (var day = 1; day <= daysInMonth; day++) {
            this.last.day = day;
            if (this.is_day_in_byday(this.last)) {
              setpos_total++;
              if (day <= last_day) {
                setpos++;
              }
            }
          }
          this.last.day = last_day;
        }

        data_valid = 0;
        for (var day = this.last.day + 1; day <= daysInMonth; day++) {
          this.last.day = day;

          if (this.is_day_in_byday(this.last)) {
            if (!this.has_by_data("BYSETPOS") ||
                this.check_set_position(++setpos) ||
                this.check_set_position(setpos - setpos_total - 1)) {

              data_valid = 1;
              break;
            }
          }
        }

        if (day > daysInMonth) {
          this.last.day = 1;
          this.increment_month();

          if (this.is_day_in_byday(this.last)) {
            if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
              data_valid = 1;
            }
          } else {
            data_valid = 0;
          }
        }
      } else if (this.has_by_data("BYMONTHDAY")) {
        this.by_indices.BYMONTHDAY++;

        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
          this.by_indices.BYMONTHDAY = 0;
          this.increment_month();
        }

        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];

        if (day < 0) {
          day = daysInMonth + day + 1;
        }

        if (day > daysInMonth) {
          this.last.day = 1;
          data_valid = this.is_day_in_byday(this.last);
        } else {
          this.last.day = day;
        }

      } else {
        this.increment_month();
        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
          data_valid = 0;
        } else {
          this.last.day = this.by_data.BYMONTHDAY[0];
        }
      }

      return data_valid;
    },

    next_weekday_by_week: function next_weekday_by_week() {
      var end_of_data = 0;

      if (this.next_hour() == 0) {
        return end_of_data;
      }

      if (!this.has_by_data("BYDAY")) {
        return 1;
      }

      for (;;) {
        var tt = new ICAL.Time();
        this.by_indices.BYDAY++;

        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
          this.by_indices.BYDAY = 0;
          end_of_data = 1;
        }

        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
        var parts = this.ruleDayOfWeek(coded_day);
        var dow = parts[1];

        dow -= this.rule.wkst;

        if (dow < 0) {
          dow += 7;
        }

        tt.year = this.last.year;
        tt.month = this.last.month;
        tt.day = this.last.day;

        var startOfWeek = tt.startDoyWeek(this.rule.wkst);

        if (dow + startOfWeek < 1) {
          // The selected date is in the previous year
          if (!end_of_data) {
            continue;
          }
        }

        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,
                                                  this.last.year);

        /**
         * The normalization horrors below are due to
         * the fact that when the year/month/day changes
         * it can effect the other operations that come after.
         */
        this.last.year = next.year;
        this.last.month = next.month;
        this.last.day = next.day;

        return end_of_data;
      }
    },

    next_year: function next_year() {

      if (this.next_hour() == 0) {
        return 0;
      }

      if (++this.days_index == this.days.length) {
        this.days_index = 0;
        do {
          this.increment_year(this.rule.interval);
          this.expand_year_days(this.last.year);
        } while (this.days.length == 0);
      }

      this._nextByYearDay();

      return 1;
    },

    _nextByYearDay: function _nextByYearDay() {
        var doy = this.days[this.days_index];
        var year = this.last.year;
        if (doy < 1) {
            // Time.fromDayOfYear(doy, year) indexes relative to the
            // start of the given year. That is different from the
            // semantics of BYYEARDAY where negative indexes are an
            // offset from the end of the given year.
            doy += 1;
            year += 1;
        }
        var next = ICAL.Time.fromDayOfYear(doy, year);
        this.last.day = next.day;
        this.last.month = next.month;
    },

    /**
     * @param dow (eg: '1TU', '-1MO')
     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
     */
    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
      if (matches) {
        var pos = parseInt(matches[1] || 0, 10);
        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);
        return [pos, dow];
      } else {
        return [0, 0];
      }
    },

    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,
                                        aFollowingAttr, aPreviousIncr) {
      var has_by_rule = (aRuleType in this.by_data);
      var this_freq = (this.rule.freq == aInterval);
      var end_of_data = 0;

      if (aPreviousIncr && this[aPreviousIncr]() == 0) {
        return end_of_data;
      }

      if (has_by_rule) {
        this.by_indices[aRuleType]++;
        var idx = this.by_indices[aRuleType];
        var dta = this.by_data[aRuleType];

        if (this.by_indices[aRuleType] == dta.length) {
          this.by_indices[aRuleType] = 0;
          end_of_data = 1;
        }
        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
      } else if (this_freq) {
        this["increment_" + aDateAttr](this.rule.interval);
      }

      if (has_by_rule && end_of_data && this_freq) {
        this["increment_" + aFollowingAttr](1);
      }

      return end_of_data;
    },

    increment_monthday: function increment_monthday(inc) {
      for (var i = 0; i < inc; i++) {
        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
        this.last.day++;

        if (this.last.day > daysInMonth) {
          this.last.day -= daysInMonth;
          this.increment_month();
        }
      }
    },

    increment_month: function increment_month() {
      this.last.day = 1;
      if (this.has_by_data("BYMONTH")) {
        this.by_indices.BYMONTH++;

        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
          this.by_indices.BYMONTH = 0;
          this.increment_year(1);
        }

        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
      } else {
        if (this.rule.freq == "MONTHLY") {
          this.last.month += this.rule.interval;
        } else {
          this.last.month++;
        }

        this.last.month--;
        var years = ICAL.helpers.trunc(this.last.month / 12);
        this.last.month %= 12;
        this.last.month++;

        if (years != 0) {
          this.increment_year(years);
        }
      }
    },

    increment_year: function increment_year(inc) {
      this.last.year += inc;
    },

    increment_generic: function increment_generic(inc, aDateAttr,
                                                  aFactor, aNextIncrement) {
      this.last[aDateAttr] += inc;
      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);
      this.last[aDateAttr] %= aFactor;
      if (nextunit != 0) {
        this["increment_" + aNextIncrement](nextunit);
      }
    },

    has_by_data: function has_by_data(aRuleType) {
      return (aRuleType in this.rule.parts);
    },

    expand_year_days: function expand_year_days(aYear) {
      var t = new ICAL.Time();
      this.days = [];

      // We need our own copy with a few keys set
      var parts = {};
      var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
      for (var p in rules) {
        /* istanbul ignore else */
        if (rules.hasOwnProperty(p)) {
          var part = rules[p];
          if (part in this.rule.parts) {
            parts[part] = this.rule.parts[part];
          }
        }
      }

      if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
        var valid = 1;
        var validWeeks = {};
        t.year = aYear;
        t.isDate = true;

        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
          var month = this.by_data.BYMONTH[monthIdx];
          t.month = month;
          t.day = 1;
          var first_week = t.weekNumber(this.rule.wkst);
          t.day = ICAL.Time.daysInMonth(month, aYear);
          var last_week = t.weekNumber(this.rule.wkst);
          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
            validWeeks[monthIdx] = 1;
          }
        }

        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
          var weekno = this.by_data.BYWEEKNO[weekIdx];
          if (weekno < 52) {
            valid &= validWeeks[weekIdx];
          } else {
            valid = 0;
          }
        }

        if (valid) {
          delete parts.BYMONTH;
        } else {
          delete parts.BYWEEKNO;
        }
      }

      var partCount = Object.keys(parts).length;

      if (partCount == 0) {
        var t1 = this.dtstart.clone();
        t1.year = this.last.year;
        this.days.push(t1.dayOfYear());
      } else if (partCount == 1 && "BYMONTH" in parts) {
        for (var monthkey in this.by_data.BYMONTH) {
          /* istanbul ignore if */
          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
            continue;
          }
          var t2 = this.dtstart.clone();
          t2.year = aYear;
          t2.month = this.by_data.BYMONTH[monthkey];
          t2.isDate = true;
          this.days.push(t2.dayOfYear());
        }
      } else if (partCount == 1 && "BYMONTHDAY" in parts) {
        for (var monthdaykey in this.by_data.BYMONTHDAY) {
          /* istanbul ignore if */
          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
            continue;
          }
          var t3 = this.dtstart.clone();
          var day_ = this.by_data.BYMONTHDAY[monthdaykey];
          if (day_ < 0) {
            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);
            day_ = day_ + daysInMonth + 1;
          }
          t3.day = day_;
          t3.year = aYear;
          t3.isDate = true;
          this.days.push(t3.dayOfYear());
        }
      } else if (partCount == 2 &&
                 "BYMONTHDAY" in parts &&
                 "BYMONTH" in parts) {
        for (var monthkey in this.by_data.BYMONTH) {
          /* istanbul ignore if */
          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
            continue;
          }
          var month_ = this.by_data.BYMONTH[monthkey];
          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);
          for (var monthdaykey in this.by_data.BYMONTHDAY) {
            /* istanbul ignore if */
            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
              continue;
            }
            var day_ = this.by_data.BYMONTHDAY[monthdaykey];
            if (day_ < 0) {
              day_ = day_ + daysInMonth + 1;
            }
            t.day = day_;
            t.month = month_;
            t.year = aYear;
            t.isDate = true;

            this.days.push(t.dayOfYear());
          }
        }
      } else if (partCount == 1 && "BYWEEKNO" in parts) {
        // TODO unimplemented in libical
      } else if (partCount == 2 &&
                 "BYWEEKNO" in parts &&
                 "BYMONTHDAY" in parts) {
        // TODO unimplemented in libical
      } else if (partCount == 1 && "BYDAY" in parts) {
        this.days = this.days.concat(this.expand_by_day(aYear));
      } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
        for (var monthkey in this.by_data.BYMONTH) {
          /* istanbul ignore if */
          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
            continue;
          }
          var month = this.by_data.BYMONTH[monthkey];
          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);

          t.year = aYear;
          t.month = this.by_data.BYMONTH[monthkey];
          t.day = 1;
          t.isDate = true;

          var first_dow = t.dayOfWeek();
          var doy_offset = t.dayOfYear() - 1;

          t.day = daysInMonth;
          var last_dow = t.dayOfWeek();

          if (this.has_by_data("BYSETPOS")) {
            var set_pos_counter = 0;
            var by_month_day = [];
            for (var day = 1; day <= daysInMonth; day++) {
              t.day = day;
              if (this.is_day_in_byday(t)) {
                by_month_day.push(day);
              }
            }

            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
              if (this.check_set_position(spIndex + 1) ||
                  this.check_set_position(spIndex - by_month_day.length)) {
                this.days.push(doy_offset + by_month_day[spIndex]);
              }
            }
          } else {
            for (var daycodedkey in this.by_data.BYDAY) {
              /* istanbul ignore if */
              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                continue;
              }
              var coded_day = this.by_data.BYDAY[daycodedkey];
              var bydayParts = this.ruleDayOfWeek(coded_day);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var month_day;

              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;
              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);

              if (pos == 0) {
                for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                  this.days.push(doy_offset + day);
                }
              } else if (pos > 0) {
                month_day = first_matching_day + (pos - 1) * 7;

                if (month_day <= daysInMonth) {
                  this.days.push(doy_offset + month_day);
                }
              } else {
                month_day = last_matching_day + (pos + 1) * 7;

                if (month_day > 0) {
                  this.days.push(doy_offset + month_day);
                }
              }
            }
          }
        }
        // Return dates in order of occurrence (1,2,3,...) instead
        // of by groups of weekdays (1,8,15,...,2,9,16,...).
        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.
      } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
        var expandedDays = this.expand_by_day(aYear);

        for (var daykey in expandedDays) {
          /* istanbul ignore if */
          if (!expandedDays.hasOwnProperty(daykey)) {
            continue;
          }
          var day = expandedDays[daykey];
          var tt = ICAL.Time.fromDayOfYear(day, aYear);
          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
            this.days.push(day);
          }
        }
      } else if (partCount == 3 &&
                 "BYDAY" in parts &&
                 "BYMONTHDAY" in parts &&
                 "BYMONTH" in parts) {
        var expandedDays = this.expand_by_day(aYear);

        for (var daykey in expandedDays) {
          /* istanbul ignore if */
          if (!expandedDays.hasOwnProperty(daykey)) {
            continue;
          }
          var day = expandedDays[daykey];
          var tt = ICAL.Time.fromDayOfYear(day, aYear);

          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&
              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
            this.days.push(day);
          }
        }
      } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
        var expandedDays = this.expand_by_day(aYear);

        for (var daykey in expandedDays) {
          /* istanbul ignore if */
          if (!expandedDays.hasOwnProperty(daykey)) {
            continue;
          }
          var day = expandedDays[daykey];
          var tt = ICAL.Time.fromDayOfYear(day, aYear);
          var weekno = tt.weekNumber(this.rule.wkst);

          if (this.by_data.BYWEEKNO.indexOf(weekno)) {
            this.days.push(day);
          }
        }
      } else if (partCount == 3 &&
                 "BYDAY" in parts &&
                 "BYWEEKNO" in parts &&
                 "BYMONTHDAY" in parts) {
        // TODO unimplemted in libical
      } else if (partCount == 1 && "BYYEARDAY" in parts) {
        this.days = this.days.concat(this.by_data.BYYEARDAY);
      } else {
        this.days = [];
      }
      return 0;
    },

    expand_by_day: function expand_by_day(aYear) {

      var days_list = [];
      var tmp = this.last.clone();

      tmp.year = aYear;
      tmp.month = 1;
      tmp.day = 1;
      tmp.isDate = true;

      var start_dow = tmp.dayOfWeek();

      tmp.month = 12;
      tmp.day = 31;
      tmp.isDate = true;

      var end_dow = tmp.dayOfWeek();
      var end_year_day = tmp.dayOfYear();

      for (var daykey in this.by_data.BYDAY) {
        /* istanbul ignore if */
        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
          continue;
        }
        var day = this.by_data.BYDAY[daykey];
        var parts = this.ruleDayOfWeek(day);
        var pos = parts[0];
        var dow = parts[1];

        if (pos == 0) {
          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;

          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
            days_list.push(doy);
          }

        } else if (pos > 0) {
          var first;
          if (dow >= start_dow) {
            first = dow - start_dow + 1;
          } else {
            first = dow - start_dow + 8;
          }

          days_list.push(first + (pos - 1) * 7);
        } else {
          var last;
          pos = -pos;

          if (dow <= end_dow) {
            last = end_year_day - end_dow + dow;
          } else {
            last = end_year_day - end_dow + dow - 7;
          }

          days_list.push(last - (pos - 1) * 7);
        }
      }
      return days_list;
    },

    is_day_in_byday: function is_day_in_byday(tt) {
      for (var daykey in this.by_data.BYDAY) {
        /* istanbul ignore if */
        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
          continue;
        }
        var day = this.by_data.BYDAY[daykey];
        var parts = this.ruleDayOfWeek(day);
        var pos = parts[0];
        var dow = parts[1];
        var this_dow = tt.dayOfWeek();

        if ((pos == 0 && dow == this_dow) ||
            (tt.nthWeekDay(dow, pos) == tt.day)) {
          return 1;
        }
      }

      return 0;
    },

    /**
     * Checks if given value is in BYSETPOS.
     *
     * @private
     * @param {Numeric} aPos position to check for.
     * @return {Boolean} false unless BYSETPOS rules exist
     *                   and the given value is present in rules.
     */
    check_set_position: function check_set_position(aPos) {
      if (this.has_by_data('BYSETPOS')) {
        var idx = this.by_data.BYSETPOS.indexOf(aPos);
        // negative numbers are not false-y
        return idx !== -1;
      }
      return false;
    },

    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
      for (var i = 0; i < aRules.length; i++) {
        for (var j = 0; j < i; j++) {
          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];
          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];

          if (one > two) {
            var tmp = aRules[i];
            aRules[i] = aRules[j];
            aRules[j] = tmp;
          }
        }
      }
    },

    check_contract_restriction: function check_contract_restriction(aRuleType, v) {
      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
      var pass = false;

      if (aRuleType in this.by_data &&
          ruleMapValue == icalrecur_iterator.CONTRACT) {

        var ruleType = this.by_data[aRuleType];

        for (var bydatakey in ruleType) {
          /* istanbul ignore else */
          if (ruleType.hasOwnProperty(bydatakey)) {
            if (ruleType[bydatakey] == v) {
              pass = true;
              break;
            }
          }
        }
      } else {
        // Not a contracting byrule or has no data, test passes
        pass = true;
      }
      return pass;
    },

    check_contracting_rules: function check_contracting_rules() {
      var dow = this.last.dayOfWeek();
      var weekNo = this.last.weekNumber(this.rule.wkst);
      var doy = this.last.dayOfYear();

      return (this.check_contract_restriction("BYSECOND", this.last.second) &&
              this.check_contract_restriction("BYMINUTE", this.last.minute) &&
              this.check_contract_restriction("BYHOUR", this.last.hour) &&
              this.check_contract_restriction("BYDAY", ICAL.Recur.numericDayToIcalDay(dow)) &&
              this.check_contract_restriction("BYWEEKNO", weekNo) &&
              this.check_contract_restriction("BYMONTHDAY", this.last.day) &&
              this.check_contract_restriction("BYMONTH", this.last.month) &&
              this.check_contract_restriction("BYYEARDAY", doy));
    },

    setup_defaults: function setup_defaults(aRuleType, req, deftime) {
      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];

      if (ruleMapValue != icalrecur_iterator.CONTRACT) {
        if (!(aRuleType in this.by_data)) {
          this.by_data[aRuleType] = [deftime];
        }
        if (this.rule.freq != req) {
          return this.by_data[aRuleType][0];
        }
      }
      return deftime;
    },

    /**
     * Convert iterator into a serialize-able object.  Will preserve current
     * iteration sequence to ensure the seamless continuation of the recurrence
     * rule.
     * @return {Object}
     */
    toJSON: function() {
      var result = Object.create(null);

      result.initialized = this.initialized;
      result.rule = this.rule.toJSON();
      result.dtstart = this.dtstart.toJSON();
      result.by_data = this.by_data;
      result.days = this.days;
      result.last = this.last.toJSON();
      result.by_indices = this.by_indices;
      result.occurrence_number = this.occurrence_number;

      return result;
    }
  };

  icalrecur_iterator._indexMap = {
    "BYSECOND": 0,
    "BYMINUTE": 1,
    "BYHOUR": 2,
    "BYDAY": 3,
    "BYMONTHDAY": 4,
    "BYYEARDAY": 5,
    "BYWEEKNO": 6,
    "BYMONTH": 7,
    "BYSETPOS": 8
  };

  icalrecur_iterator._expandMap = {
    "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
    "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
    "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
    "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
    "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
    "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
    "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
  };
  icalrecur_iterator.UNKNOWN = 0;
  icalrecur_iterator.CONTRACT = 1;
  icalrecur_iterator.EXPAND = 2;
  icalrecur_iterator.ILLEGAL = 3;

  return icalrecur_iterator;

}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.RecurExpansion = (function() {
  function formatTime(item) {
    return ICAL.helpers.formatClassType(item, ICAL.Time);
  }

  function compareTime(a, b) {
    return a.compare(b);
  }

  function isRecurringComponent(comp) {
    return comp.hasProperty('rdate') ||
           comp.hasProperty('rrule') ||
           comp.hasProperty('recurrence-id');
  }

  /**
   * @classdesc
   * Primary class for expanding recurring rules.  Can take multiple rrules,
   * rdates, exdate(s) and iterate (in order) over each next occurrence.
   *
   * Once initialized this class can also be serialized saved and continue
   * iteration from the last point.
   *
   * NOTE: it is intended that this class is to be used
   *       with ICAL.Event which handles recurrence exceptions.
   *
   * @example
   * // assuming event is a parsed ical component
   * var event;
   *
   * var expand = new ICAL.RecurExpansion({
   *   component: event,
   *   dtstart: event.getFirstPropertyValue('dtstart')
   * });
   *
   * // remember there are infinite rules
   * // so it is a good idea to limit the scope
   * // of the iterations then resume later on.
   *
   * // next is always an ICAL.Time or null
   * var next;
   *
   * while (someCondition && (next = expand.next())) {
   *   // do something with next
   * }
   *
   * // save instance for later
   * var json = JSON.stringify(expand);
   *
   * //...
   *
   * // NOTE: if the component's properties have
   * //       changed you will need to rebuild the
   * //       class and start over. This only works
   * //       when the component's recurrence info is the same.
   * var expand = new ICAL.RecurExpansion(JSON.parse(json));
   *
   * @description
   * The options object can be filled with the specified initial values. It can
   * also contain additional members, as a result of serializing a previous
   * expansion state, as shown in the example.
   *
   * @class
   * @alias ICAL.RecurExpansion
   * @param {Object} options
   *        Recurrence expansion options
   * @param {ICAL.Time} options.dtstart
   *        Start time of the event
   * @param {ICAL.Component=} options.component
   *        Component for expansion, required if not resuming.
   */
  function RecurExpansion(options) {
    this.ruleDates = [];
    this.exDates = [];
    this.fromData(options);
  }

  RecurExpansion.prototype = {
    /**
     * True when iteration is fully completed.
     * @type {Boolean}
     */
    complete: false,

    /**
     * Array of rrule iterators.
     *
     * @type {ICAL.RecurIterator[]}
     * @private
     */
    ruleIterators: null,

    /**
     * Array of rdate instances.
     *
     * @type {ICAL.Time[]}
     * @private
     */
    ruleDates: null,

    /**
     * Array of exdate instances.
     *
     * @type {ICAL.Time[]}
     * @private
     */
    exDates: null,

    /**
     * Current position in ruleDates array.
     * @type {Number}
     * @private
     */
    ruleDateInc: 0,

    /**
     * Current position in exDates array
     * @type {Number}
     * @private
     */
    exDateInc: 0,

    /**
     * Current negative date.
     *
     * @type {ICAL.Time}
     * @private
     */
    exDate: null,

    /**
     * Current additional date.
     *
     * @type {ICAL.Time}
     * @private
     */
    ruleDate: null,

    /**
     * Start date of recurring rules.
     *
     * @type {ICAL.Time}
     */
    dtstart: null,

    /**
     * Last expanded time
     *
     * @type {ICAL.Time}
     */
    last: null,

    /**
     * Initialize the recurrence expansion from the data object. The options
     * object may also contain additional members, see the
     * {@link ICAL.RecurExpansion constructor} for more details.
     *
     * @param {Object} options
     *        Recurrence expansion options
     * @param {ICAL.Time} options.dtstart
     *        Start time of the event
     * @param {ICAL.Component=} options.component
     *        Component for expansion, required if not resuming.
     */
    fromData: function(options) {
      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);

      if (!start) {
        throw new Error('.dtstart (ICAL.Time) must be given');
      } else {
        this.dtstart = start;
      }

      if (options.component) {
        this._init(options.component);
      } else {
        this.last = formatTime(options.last) || start.clone();

        if (!options.ruleIterators) {
          throw new Error('.ruleIterators or .component must be given');
        }

        this.ruleIterators = options.ruleIterators.map(function(item) {
          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);
        });

        this.ruleDateInc = options.ruleDateInc;
        this.exDateInc = options.exDateInc;

        if (options.ruleDates) {
          this.ruleDates = options.ruleDates.map(formatTime);
          this.ruleDate = this.ruleDates[this.ruleDateInc];
        }

        if (options.exDates) {
          this.exDates = options.exDates.map(formatTime);
          this.exDate = this.exDates[this.exDateInc];
        }

        if (typeof(options.complete) !== 'undefined') {
          this.complete = options.complete;
        }
      }
    },

    /**
     * Retrieve the next occurrence in the series.
     * @return {ICAL.Time}
     */
    next: function() {
      var iter;
      var ruleOfDay;
      var next;
      var compare;

      var maxTries = 500;
      var currentTry = 0;

      while (true) {
        if (currentTry++ > maxTries) {
          throw new Error(
            'max tries have occured, rule may be impossible to forfill.'
          );
        }

        next = this.ruleDate;
        iter = this._nextRecurrenceIter(this.last);

        // no more matches
        // because we increment the rule day or rule
        // _after_ we choose a value this should be
        // the only spot where we need to worry about the
        // end of events.
        if (!next && !iter) {
          // there are no more iterators or rdates
          this.complete = true;
          break;
        }

        // no next rule day or recurrence rule is first.
        if (!next || (iter && next.compare(iter.last) > 0)) {
          // must be cloned, recur will reuse the time element.
          next = iter.last.clone();
          // move to next so we can continue
          iter.next();
        }

        // if the ruleDate is still next increment it.
        if (this.ruleDate === next) {
          this._nextRuleDay();
        }

        this.last = next;

        // check the negative rules
        if (this.exDate) {
          compare = this.exDate.compare(this.last);

          if (compare < 0) {
            this._nextExDay();
          }

          // if the current rule is excluded skip it.
          if (compare === 0) {
            this._nextExDay();
            continue;
          }
        }

        //XXX: The spec states that after we resolve the final
        //     list of dates we execute exdate this seems somewhat counter
        //     intuitive to what I have seen most servers do so for now
        //     I exclude based on the original date not the one that may
        //     have been modified by the exception.
        return this.last;
      }
    },

    /**
     * Converts object into a serialize-able format. This format can be passed
     * back into the expansion to resume iteration.
     * @return {Object}
     */
    toJSON: function() {
      function toJSON(item) {
        return item.toJSON();
      }

      var result = Object.create(null);
      result.ruleIterators = this.ruleIterators.map(toJSON);

      if (this.ruleDates) {
        result.ruleDates = this.ruleDates.map(toJSON);
      }

      if (this.exDates) {
        result.exDates = this.exDates.map(toJSON);
      }

      result.ruleDateInc = this.ruleDateInc;
      result.exDateInc = this.exDateInc;
      result.last = this.last.toJSON();
      result.dtstart = this.dtstart.toJSON();
      result.complete = this.complete;

      return result;
    },

    /**
     * Extract all dates from the properties in the given component. The
     * properties will be filtered by the property name.
     *
     * @private
     * @param {ICAL.Component} component        The component to search in
     * @param {String} propertyName             The property name to search for
     * @return {ICAL.Time[]}                    The extracted dates.
     */
    _extractDates: function(component, propertyName) {
      function handleProp(prop) {
        idx = ICAL.helpers.binsearchInsert(
          result,
          prop,
          compareTime
        );

        // ordered insert
        result.splice(idx, 0, prop);
      }

      var result = [];
      var props = component.getAllProperties(propertyName);
      var len = props.length;
      var i = 0;
      var prop;

      var idx;

      for (; i < len; i++) {
        props[i].getValues().forEach(handleProp);
      }

      return result;
    },

    /**
     * Initialize the recurrence expansion.
     *
     * @private
     * @param {ICAL.Component} component    The component to initialize from.
     */
    _init: function(component) {
      this.ruleIterators = [];

      this.last = this.dtstart.clone();

      // to provide api consistency non-recurring
      // events can also use the iterator though it will
      // only return a single time.
      if (!isRecurringComponent(component)) {
        this.ruleDate = this.last.clone();
        this.complete = true;
        return;
      }

      if (component.hasProperty('rdate')) {
        this.ruleDates = this._extractDates(component, 'rdate');

        // special hack for cases where first rdate is prior
        // to the start date. We only check for the first rdate.
        // This is mostly for google's crazy recurring date logic
        // (contacts birthdays).
        if ((this.ruleDates[0]) &&
            (this.ruleDates[0].compare(this.dtstart) < 0)) {

          this.ruleDateInc = 0;
          this.last = this.ruleDates[0].clone();
        } else {
          this.ruleDateInc = ICAL.helpers.binsearchInsert(
            this.ruleDates,
            this.last,
            compareTime
          );
        }

        this.ruleDate = this.ruleDates[this.ruleDateInc];
      }

      if (component.hasProperty('rrule')) {
        var rules = component.getAllProperties('rrule');
        var i = 0;
        var len = rules.length;

        var rule;
        var iter;

        for (; i < len; i++) {
          rule = rules[i].getFirstValue();
          iter = rule.iterator(this.dtstart);
          this.ruleIterators.push(iter);

          // increment to the next occurrence so future
          // calls to next return times beyond the initial iteration.
          // XXX: I find this suspicious might be a bug?
          iter.next();
        }
      }

      if (component.hasProperty('exdate')) {
        this.exDates = this._extractDates(component, 'exdate');
        // if we have a .last day we increment the index to beyond it.
        this.exDateInc = ICAL.helpers.binsearchInsert(
          this.exDates,
          this.last,
          compareTime
        );

        this.exDate = this.exDates[this.exDateInc];
      }
    },

    /**
     * Advance to the next exdate
     * @private
     */
    _nextExDay: function() {
      this.exDate = this.exDates[++this.exDateInc];
    },

    /**
     * Advance to the next rule date
     * @private
     */
    _nextRuleDay: function() {
      this.ruleDate = this.ruleDates[++this.ruleDateInc];
    },

    /**
     * Find and return the recurrence rule with the most recent event and
     * return it.
     *
     * @private
     * @return {?ICAL.RecurIterator}    Found iterator.
     */
    _nextRecurrenceIter: function() {
      var iters = this.ruleIterators;

      if (iters.length === 0) {
        return null;
      }

      var len = iters.length;
      var iter;
      var iterTime;
      var iterIdx = 0;
      var chosenIter;

      // loop through each iterator
      for (; iterIdx < len; iterIdx++) {
        iter = iters[iterIdx];
        iterTime = iter.last;

        // if iteration is complete
        // then we must exclude it from
        // the search and remove it.
        if (iter.completed) {
          len--;
          if (iterIdx !== 0) {
            iterIdx--;
          }
          iters.splice(iterIdx, 1);
          continue;
        }

        // find the most recent possible choice
        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
          // that iterator is saved
          chosenIter = iter;
        }
      }

      // the chosen iterator is returned but not mutated
      // this iterator contains the most recent event.
      return chosenIter;
    }
  };

  return RecurExpansion;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.Event = (function() {

  /**
   * @classdesc
   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal
   * object, followed by the component/property layer. The highest level is the
   * event representation, which this class is part of. See the
   * {@tutorial layers} guide for more details.
   *
   * @class
   * @alias ICAL.Event
   * @param {ICAL.Component=} component         The ICAL.Component to base this event on
   * @param {Object} options                    Options for this event
   * @param {Boolean} options.strictExceptions
   *          When true, will verify exceptions are related by their UUID
   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions
   *          Exceptions to this event, either as components or events. If not
   *            specified exceptions will automatically be set in relation of
   *            component's parent
   */
  function Event(component, options) {
    if (!(component instanceof ICAL.Component)) {
      options = component;
      component = null;
    }

    if (component) {
      this.component = component;
    } else {
      this.component = new ICAL.Component('vevent');
    }

    this._rangeExceptionCache = Object.create(null);
    this.exceptions = Object.create(null);
    this.rangeExceptions = [];

    if (options && options.strictExceptions) {
      this.strictExceptions = options.strictExceptions;
    }

    if (options && options.exceptions) {
      options.exceptions.forEach(this.relateException, this);
    } else if (this.component.parent && !this.isRecurrenceException()) {
      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {
        if (event.hasProperty('recurrence-id')) {
          this.relateException(event);
        }
      }, this);
    }
  }

  Event.prototype = {

    THISANDFUTURE: 'THISANDFUTURE',

    /**
     * List of related event exceptions.
     *
     * @type {ICAL.Event[]}
     */
    exceptions: null,

    /**
     * When true, will verify exceptions are related by their UUID.
     *
     * @type {Boolean}
     */
    strictExceptions: false,

    /**
     * Relates a given event exception to this object.  If the given component
     * does not share the UID of this event it cannot be related and will throw
     * an exception.
     *
     * If this component is an exception it cannot have other exceptions
     * related to it.
     *
     * @param {ICAL.Component|ICAL.Event} obj       Component or event
     */
    relateException: function(obj) {
      if (this.isRecurrenceException()) {
        throw new Error('cannot relate exception to exceptions');
      }

      if (obj instanceof ICAL.Component) {
        obj = new ICAL.Event(obj);
      }

      if (this.strictExceptions && obj.uid !== this.uid) {
        throw new Error('attempted to relate unrelated exception');
      }

      var id = obj.recurrenceId.toString();

      // we don't sort or manage exceptions directly
      // here the recurrence expander handles that.
      this.exceptions[id] = obj;

      // index RANGE=THISANDFUTURE exceptions so we can
      // look them up later in getOccurrenceDetails.
      if (obj.modifiesFuture()) {
        var item = [
          obj.recurrenceId.toUnixTime(), id
        ];

        // we keep them sorted so we can find the nearest
        // value later on...
        var idx = ICAL.helpers.binsearchInsert(
          this.rangeExceptions,
          item,
          compareRangeException
        );

        this.rangeExceptions.splice(idx, 0, item);
      }
    },

    /**
     * Checks if this record is an exception and has the RANGE=THISANDFUTURE
     * value.
     *
     * @return {Boolean}        True, when exception is within range
     */
    modifiesFuture: function() {
      if (!this.component.hasProperty('recurrence-id')) {
        return false;
      }

      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');
      return range === this.THISANDFUTURE;
    },

    /**
     * Finds the range exception nearest to the given date.
     *
     * @param {ICAL.Time} time usually an occurrence time of an event
     * @return {?ICAL.Event} the related event/exception or null
     */
    findRangeException: function(time) {
      if (!this.rangeExceptions.length) {
        return null;
      }

      var utc = time.toUnixTime();
      var idx = ICAL.helpers.binsearchInsert(
        this.rangeExceptions,
        [utc],
        compareRangeException
      );

      idx -= 1;

      // occurs before
      if (idx < 0) {
        return null;
      }

      var rangeItem = this.rangeExceptions[idx];

      /* istanbul ignore next: sanity check only */
      if (utc < rangeItem[0]) {
        return null;
      }

      return rangeItem[1];
    },

    /**
     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
     *
     * @typedef {Object} occurrenceDetails
     * @memberof ICAL.Event
     * @property {ICAL.Time} recurrenceId       The passed in recurrence id
     * @property {ICAL.Event} item              The occurrence
     * @property {ICAL.Time} startDate          The start of the occurrence
     * @property {ICAL.Time} endDate            The end of the occurrence
     */

    /**
     * Returns the occurrence details based on its start time.  If the
     * occurrence has an exception will return the details for that exception.
     *
     * NOTE: this method is intend to be used in conjunction
     *       with the {@link ICAL.Event#iterator iterator} method.
     *
     * @param {ICAL.Time} occurrence time occurrence
     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
     */
    getOccurrenceDetails: function(occurrence) {
      var id = occurrence.toString();
      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();
      var item;
      var result = {
        //XXX: Clone?
        recurrenceId: occurrence
      };

      if (id in this.exceptions) {
        item = result.item = this.exceptions[id];
        result.startDate = item.startDate;
        result.endDate = item.endDate;
        result.item = item;
      } else if (utcId in this.exceptions) {
        item = this.exceptions[utcId];
        result.startDate = item.startDate;
        result.endDate = item.endDate;
        result.item = item;
      } else {
        // range exceptions (RANGE=THISANDFUTURE) have a
        // lower priority then direct exceptions but
        // must be accounted for first. Their item is
        // always the first exception with the range prop.
        var rangeExceptionId = this.findRangeException(
          occurrence
        );
        var end;

        if (rangeExceptionId) {
          var exception = this.exceptions[rangeExceptionId];

          // range exception must modify standard time
          // by the difference (if any) in start/end times.
          result.item = exception;

          var startDiff = this._rangeExceptionCache[rangeExceptionId];

          if (!startDiff) {
            var original = exception.recurrenceId.clone();
            var newStart = exception.startDate.clone();

            // zones must be same otherwise subtract may be incorrect.
            original.zone = newStart.zone;
            startDiff = newStart.subtractDate(original);

            this._rangeExceptionCache[rangeExceptionId] = startDiff;
          }

          var start = occurrence.clone();
          start.zone = exception.startDate.zone;
          start.addDuration(startDiff);

          end = start.clone();
          end.addDuration(exception.duration);

          result.startDate = start;
          result.endDate = end;
        } else {
          // no range exception standard expansion
          end = occurrence.clone();
          end.addDuration(this.duration);

          result.endDate = end;
          result.startDate = occurrence;
          result.item = this;
        }
      }

      return result;
    },

    /**
     * Builds a recur expansion instance for a specific point in time (defaults
     * to startDate).
     *
     * @param {ICAL.Time} startTime     Starting point for expansion
     * @return {ICAL.RecurExpansion}    Expansion object
     */
    iterator: function(startTime) {
      return new ICAL.RecurExpansion({
        component: this.component,
        dtstart: startTime || this.startDate
      });
    },

    /**
     * Checks if the event is recurring
     *
     * @return {Boolean}        True, if event is recurring
     */
    isRecurring: function() {
      var comp = this.component;
      return comp.hasProperty('rrule') || comp.hasProperty('rdate');
    },

    /**
     * Checks if the event describes a recurrence exception. See
     * {@tutorial terminology} for details.
     *
     * @return {Boolean}    True, if the event describes a recurrence exception
     */
    isRecurrenceException: function() {
      return this.component.hasProperty('recurrence-id');
    },

    /**
     * Returns the types of recurrences this event may have.
     *
     * Returned as an object with the following possible keys:
     *
     *    - YEARLY
     *    - MONTHLY
     *    - WEEKLY
     *    - DAILY
     *    - MINUTELY
     *    - SECONDLY
     *
     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
     *          Object of recurrence flags
     */
    getRecurrenceTypes: function() {
      var rules = this.component.getAllProperties('rrule');
      var i = 0;
      var len = rules.length;
      var result = Object.create(null);

      for (; i < len; i++) {
        var value = rules[i].getFirstValue();
        result[value.freq] = true;
      }

      return result;
    },

    /**
     * The uid of this event
     * @type {String}
     */
    get uid() {
      return this._firstProp('uid');
    },

    set uid(value) {
      this._setProp('uid', value);
    },

    /**
     * The start date
     * @type {ICAL.Time}
     */
    get startDate() {
      return this._firstProp('dtstart');
    },

    set startDate(value) {
      this._setTime('dtstart', value);
    },

    /**
     * The end date. This can be the result directly from the property, or the
     * end date calculated from start date and duration. Setting the property
     * will remove any duration properties.
     * @type {ICAL.Time}
     */
    get endDate() {
      var endDate = this._firstProp('dtend');
      if (!endDate) {
          var duration = this._firstProp('duration');
          endDate = this.startDate.clone();
          if (duration) {
              endDate.addDuration(duration);
          } else if (endDate.isDate) {
              endDate.day += 1;
          }
      }
      return endDate;
    },

    set endDate(value) {
      if (this.component.hasProperty('duration')) {
        this.component.removeProperty('duration');
      }
      this._setTime('dtend', value);
    },

    /**
     * The duration. This can be the result directly from the property, or the
     * duration calculated from start date and end date. Setting the property
     * will remove any `dtend` properties.
     * @type {ICAL.Duration}
     */
    get duration() {
      var duration = this._firstProp('duration');
      if (!duration) {
        return this.endDate.subtractDateTz(this.startDate);
      }
      return duration;
    },

    set duration(value) {
      if (this.component.hasProperty('dtend')) {
        this.component.removeProperty('dtend');
      }

      this._setProp('duration', value);
    },

    /**
     * The location of the event.
     * @type {String}
     */
    get location() {
      return this._firstProp('location');
    },

    set location(value) {
      return this._setProp('location', value);
    },

    /**
     * The attendees in the event
     * @type {ICAL.Property[]}
     * @readonly
     */
    get attendees() {
      //XXX: This is way lame we should have a better
      //     data structure for this later.
      return this.component.getAllProperties('attendee');
    },


    /**
     * The event summary
     * @type {String}
     */
    get summary() {
      return this._firstProp('summary');
    },

    set summary(value) {
      this._setProp('summary', value);
    },

    /**
     * The event description.
     * @type {String}
     */
    get description() {
      return this._firstProp('description');
    },

    set description(value) {
      this._setProp('description', value);
    },

    /**
     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
     * @type {String}
     */
    get color() {
      return this._firstProp('color');
    },

    set color(value) {
      this._setProp('color', value);
    },

    /**
     * The organizer value as an uri. In most cases this is a mailto: uri, but
     * it can also be something else, like urn:uuid:...
     * @type {String}
     */
    get organizer() {
      return this._firstProp('organizer');
    },

    set organizer(value) {
      this._setProp('organizer', value);
    },

    /**
     * The sequence value for this event. Used for scheduling
     * see {@tutorial terminology}.
     * @type {Number}
     */
    get sequence() {
      return this._firstProp('sequence');
    },

    set sequence(value) {
      this._setProp('sequence', value);
    },

    /**
     * The recurrence id for this event. See {@tutorial terminology} for details.
     * @type {ICAL.Time}
     */
    get recurrenceId() {
      return this._firstProp('recurrence-id');
    },

    set recurrenceId(value) {
      this._setTime('recurrence-id', value);
    },

    /**
     * Set/update a time property's value.
     * This will also update the TZID of the property.
     *
     * TODO: this method handles the case where we are switching
     * from a known timezone to an implied timezone (one without TZID).
     * This does _not_ handle the case of moving between a known
     *  (by TimezoneService) timezone to an unknown timezone...
     *
     * We will not add/remove/update the VTIMEZONE subcomponents
     *  leading to invalid ICAL data...
     * @private
     * @param {String} propName     The property name
     * @param {ICAL.Time} time      The time to set
     */
    _setTime: function(propName, time) {
      var prop = this.component.getFirstProperty(propName);

      if (!prop) {
        prop = new ICAL.Property(propName);
        this.component.addProperty(prop);
      }

      // utc and local don't get a tzid
      if (
        time.zone === ICAL.Timezone.localTimezone ||
        time.zone === ICAL.Timezone.utcTimezone
      ) {
        // remove the tzid
        prop.removeParameter('tzid');
      } else {
        prop.setParameter('tzid', time.zone.tzid);
      }

      prop.setValue(time);
    },

    _setProp: function(name, value) {
      this.component.updatePropertyWithValue(name, value);
    },

    _firstProp: function(name) {
      return this.component.getFirstPropertyValue(name);
    },

    /**
     * The string representation of this event.
     * @return {String}
     */
    toString: function() {
      return this.component.toString();
    }

  };

  function compareRangeException(a, b) {
    if (a[0] > b[0]) return 1;
    if (b[0] > a[0]) return -1;
    return 0;
  }

  return Event;
}());
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


/**
 * This symbol is further described later on
 * @ignore
 */
ICAL.ComponentParser = (function() {
  /**
   * @classdesc
   * The ComponentParser is used to process a String or jCal Object,
   * firing callbacks for various found components, as well as completion.
   *
   * @example
   * var options = {
   *   // when false no events will be emitted for type
   *   parseEvent: true,
   *   parseTimezone: true
   * };
   *
   * var parser = new ICAL.ComponentParser(options);
   *
   * parser.onevent(eventComponent) {
   *   //...
   * }
   *
   * // ontimezone, etc...
   *
   * parser.oncomplete = function() {
   *
   * };
   *
   * parser.process(stringOrComponent);
   *
   * @class
   * @alias ICAL.ComponentParser
   * @param {Object=} options        Component parser options
   * @param {Boolean} options.parseEvent        Whether events should be parsed
   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed
   */
  function ComponentParser(options) {
    if (typeof(options) === 'undefined') {
      options = {};
    }

    var key;
    for (key in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(key)) {
        this[key] = options[key];
      }
    }
  }

  ComponentParser.prototype = {

    /**
     * When true, parse events
     *
     * @type {Boolean}
     */
    parseEvent: true,

    /**
     * When true, parse timezones
     *
     * @type {Boolean}
     */
    parseTimezone: true,


    /* SAX like events here for reference */

    /**
     * Fired when parsing is complete
     * @callback
     */
    oncomplete: /* istanbul ignore next */ function() {},

    /**
     * Fired if an error occurs during parsing.
     *
     * @callback
     * @param {Error} err details of error
     */
    onerror: /* istanbul ignore next */ function(err) {},

    /**
     * Fired when a top level component (VTIMEZONE) is found
     *
     * @callback
     * @param {ICAL.Timezone} component     Timezone object
     */
    ontimezone: /* istanbul ignore next */ function(component) {},

    /**
     * Fired when a top level component (VEVENT) is found.
     *
     * @callback
     * @param {ICAL.Event} component    Top level component
     */
    onevent: /* istanbul ignore next */ function(component) {},

    /**
     * Process a string or parse ical object.  This function itself will return
     * nothing but will start the parsing process.
     *
     * Events must be registered prior to calling this method.
     *
     * @param {ICAL.Component|String|Object} ical      The component to process,
     *        either in its final form, as a jCal Object, or string representation
     */
    process: function(ical) {
      //TODO: this is sync now in the future we will have a incremental parser.
      if (typeof(ical) === 'string') {
        ical = ICAL.parse(ical);
      }

      if (!(ical instanceof ICAL.Component)) {
        ical = new ICAL.Component(ical);
      }

      var components = ical.getAllSubcomponents();
      var i = 0;
      var len = components.length;
      var component;

      for (; i < len; i++) {
        component = components[i];

        switch (component.name) {
          case 'vtimezone':
            if (this.parseTimezone) {
              var tzid = component.getFirstPropertyValue('tzid');
              if (tzid) {
                this.ontimezone(new ICAL.Timezone({
                  tzid: tzid,
                  component: component
                }));
              }
            }
            break;
          case 'vevent':
            if (this.parseEvent) {
              this.onevent(new ICAL.Event(component));
            }
            break;
          default:
            continue;
        }
      }

      //XXX: ideally we should do a "nextTick" here
      //     so in all cases this is actually async.
      this.oncomplete();
    }
  };

  return ComponentParser;
}());


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID
});

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");




function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/vue-material-design-icons/CalendarBlank.vue":
/*!******************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/CalendarBlank.vue ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalendarBlank.vue?vue&type=template&id=19d2573a& */ "./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a&");
/* harmony import */ var _CalendarBlank_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalendarBlank.vue?vue&type=script&lang=js& */ "./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _CalendarBlank_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__.render,
  _CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/vue-material-design-icons/CalendarBlank.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "CalendarBlankIcon",
  emits: ['click'],
  props: {
    title: {
      type: String,
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
});


/***/ }),

/***/ "./node_modules/vue-material-design-icons/Eye.vue":
/*!********************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Eye.vue ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Eye.vue?vue&type=template&id=6cfe2635& */ "./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635&");
/* harmony import */ var _Eye_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Eye.vue?vue&type=script&lang=js& */ "./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Eye_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__.render,
  _Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/vue-material-design-icons/Eye.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "EyeIcon",
  emits: ['click'],
  props: {
    title: {
      type: String,
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
});


/***/ }),

/***/ "./node_modules/vue-material-design-icons/EyeOff.vue":
/*!***********************************************************!*\
  !*** ./node_modules/vue-material-design-icons/EyeOff.vue ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EyeOff.vue?vue&type=template&id=5115b3aa& */ "./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa&");
/* harmony import */ var _EyeOff_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EyeOff.vue?vue&type=script&lang=js& */ "./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _EyeOff_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__.render,
  _EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/vue-material-design-icons/EyeOff.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "EyeOffIcon",
  emits: ['click'],
  props: {
    title: {
      type: String,
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
});


/***/ }),

/***/ "./node_modules/vue-material-design-icons/Web.vue":
/*!********************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Web.vue ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Web.vue?vue&type=template&id=02e31dd8& */ "./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8&");
/* harmony import */ var _Web_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Web.vue?vue&type=script&lang=js& */ "./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js&");
/* harmony import */ var _vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Web_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__.render,
  _Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "node_modules/vue-material-design-icons/Web.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: "WebIcon",
  emits: ['click'],
  props: {
    title: {
      type: String,
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
});


/***/ }),

/***/ "./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_CalendarBlank_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/index.js??vue-loader-options!./CalendarBlank.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_CalendarBlank_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js&":
/*!*********************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_Eye_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/index.js??vue-loader-options!./Eye.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_Eye_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js&":
/*!************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js& ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_EyeOff_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/index.js??vue-loader-options!./EyeOff.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_EyeOff_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js&":
/*!*********************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_index_js_vue_loader_options_Web_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/index.js??vue-loader-options!./Web.vue?vue&type=script&lang=js& */ "./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vue_loader_lib_index_js_vue_loader_options_Web_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a&":
/*!*************************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a& ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_CalendarBlank_vue_vue_type_template_id_19d2573a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../vue-loader/lib/index.js??vue-loader-options!./CalendarBlank.vue?vue&type=template&id=19d2573a& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a&");


/***/ }),

/***/ "./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635&":
/*!***************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Eye_vue_vue_type_template_id_6cfe2635___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../vue-loader/lib/index.js??vue-loader-options!./Eye.vue?vue&type=template&id=6cfe2635& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635&");


/***/ }),

/***/ "./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa&":
/*!******************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa& ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_EyeOff_vue_vue_type_template_id_5115b3aa___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../vue-loader/lib/index.js??vue-loader-options!./EyeOff.vue?vue&type=template&id=5115b3aa& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa&");


/***/ }),

/***/ "./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8&":
/*!***************************************************************************************!*\
  !*** ./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_3_vue_loader_lib_index_js_vue_loader_options_Web_vue_vue_type_template_id_02e31dd8___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../vue-loader/lib/index.js??vue-loader-options!./Web.vue?vue&type=template&id=02e31dd8& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a&":
/*!*****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/CalendarBlank.vue?vue&type=template&id=19d2573a& ***!
  \*****************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "span",
    _vm._b(
      {
        staticClass: "material-design-icon calendar-blank-icon",
        attrs: {
          "aria-hidden": !_vm.title,
          "aria-label": _vm.title,
          role: "img",
        },
        on: {
          click: function ($event) {
            return _vm.$emit("click", $event)
          },
        },
      },
      "span",
      _vm.$attrs,
      false
    ),
    [
      _c(
        "svg",
        {
          staticClass: "material-design-icon__svg",
          attrs: {
            fill: _vm.fillColor,
            width: _vm.size,
            height: _vm.size,
            viewBox: "0 0 24 24",
          },
        },
        [
          _c(
            "path",
            {
              attrs: {
                d: "M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1",
              },
            },
            [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()]
          ),
        ]
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635&":
/*!*******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Eye.vue?vue&type=template&id=6cfe2635& ***!
  \*******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "span",
    _vm._b(
      {
        staticClass: "material-design-icon eye-icon",
        attrs: {
          "aria-hidden": !_vm.title,
          "aria-label": _vm.title,
          role: "img",
        },
        on: {
          click: function ($event) {
            return _vm.$emit("click", $event)
          },
        },
      },
      "span",
      _vm.$attrs,
      false
    ),
    [
      _c(
        "svg",
        {
          staticClass: "material-design-icon__svg",
          attrs: {
            fill: _vm.fillColor,
            width: _vm.size,
            height: _vm.size,
            viewBox: "0 0 24 24",
          },
        },
        [
          _c(
            "path",
            {
              attrs: {
                d: "M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z",
              },
            },
            [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()]
          ),
        ]
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa&":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/EyeOff.vue?vue&type=template&id=5115b3aa& ***!
  \**********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "span",
    _vm._b(
      {
        staticClass: "material-design-icon eye-off-icon",
        attrs: {
          "aria-hidden": !_vm.title,
          "aria-label": _vm.title,
          role: "img",
        },
        on: {
          click: function ($event) {
            return _vm.$emit("click", $event)
          },
        },
      },
      "span",
      _vm.$attrs,
      false
    ),
    [
      _c(
        "svg",
        {
          staticClass: "material-design-icon__svg",
          attrs: {
            fill: _vm.fillColor,
            width: _vm.size,
            height: _vm.size,
            viewBox: "0 0 24 24",
          },
        },
        [
          _c(
            "path",
            {
              attrs: {
                d: "M11.83,9L15,12.16C15,12.11 15,12.05 15,12A3,3 0 0,0 12,9C11.94,9 11.89,9 11.83,9M7.53,9.8L9.08,11.35C9.03,11.56 9,11.77 9,12A3,3 0 0,0 12,15C12.22,15 12.44,14.97 12.65,14.92L14.2,16.47C13.53,16.8 12.79,17 12,17A5,5 0 0,1 7,12C7,11.21 7.2,10.47 7.53,9.8M2,4.27L4.28,6.55L4.73,7C3.08,8.3 1.78,10 1,12C2.73,16.39 7,19.5 12,19.5C13.55,19.5 15.03,19.2 16.38,18.66L16.81,19.08L19.73,22L21,20.73L3.27,3M12,7A5,5 0 0,1 17,12C17,12.64 16.87,13.26 16.64,13.82L19.57,16.75C21.07,15.5 22.27,13.86 23,12C21.27,7.61 17,4.5 12,4.5C10.6,4.5 9.26,4.75 8,5.2L10.17,7.35C10.74,7.13 11.35,7 12,7Z",
              },
            },
            [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()]
          ),
        ]
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8&":
/*!*******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./node_modules/vue-material-design-icons/Web.vue?vue&type=template&id=02e31dd8& ***!
  \*******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "span",
    _vm._b(
      {
        staticClass: "material-design-icon web-icon",
        attrs: {
          "aria-hidden": !_vm.title,
          "aria-label": _vm.title,
          role: "img",
        },
        on: {
          click: function ($event) {
            return _vm.$emit("click", $event)
          },
        },
      },
      "span",
      _vm.$attrs,
      false
    ),
    [
      _c(
        "svg",
        {
          staticClass: "material-design-icon__svg",
          attrs: {
            fill: _vm.fillColor,
            width: _vm.size,
            height: _vm.size,
            viewBox: "0 0 24 24",
          },
        },
        [
          _c(
            "path",
            {
              attrs: {
                d: "M16.36,14C16.44,13.34 16.5,12.68 16.5,12C16.5,11.32 16.44,10.66 16.36,10H19.74C19.9,10.64 20,11.31 20,12C20,12.69 19.9,13.36 19.74,14M14.59,19.56C15.19,18.45 15.65,17.25 15.97,16H18.92C17.96,17.65 16.43,18.93 14.59,19.56M14.34,14H9.66C9.56,13.34 9.5,12.68 9.5,12C9.5,11.32 9.56,10.65 9.66,10H14.34C14.43,10.65 14.5,11.32 14.5,12C14.5,12.68 14.43,13.34 14.34,14M12,19.96C11.17,18.76 10.5,17.43 10.09,16H13.91C13.5,17.43 12.83,18.76 12,19.96M8,8H5.08C6.03,6.34 7.57,5.06 9.4,4.44C8.8,5.55 8.35,6.75 8,8M5.08,16H8C8.35,17.25 8.8,18.45 9.4,19.56C7.57,18.93 6.03,17.65 5.08,16M4.26,14C4.1,13.36 4,12.69 4,12C4,11.31 4.1,10.64 4.26,10H7.64C7.56,10.66 7.5,11.32 7.5,12C7.5,12.68 7.56,13.34 7.64,14M12,4.03C12.83,5.23 13.5,6.57 13.91,8H10.09C10.5,6.57 11.17,5.23 12,4.03M18.92,8H15.97C15.65,6.75 15.19,5.55 14.59,4.44C16.43,5.07 17.96,6.34 18.92,8M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
              },
            },
            [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()]
          ),
        ]
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue2-datepicker/index.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/vue2-datepicker/index.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var date_format_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! date-format-parse */ "./node_modules/date-format-parse/es/index.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");


function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _extends$1() {
  return _extends$1 = Object.assign || function (a) {
    for (var b, c = 1; c < arguments.length; c++) {
      for (var d in b = arguments[c], b) {
        Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
      }
    }

    return a;
  }, _extends$1.apply(this, arguments);
}

var normalMerge = ["attrs", "props", "domProps"],
    toArrayMerge = ["class", "style", "directives"],
    functionalMerge = ["on", "nativeOn"],
    mergeJsxProps = function mergeJsxProps(a) {
  return a.reduce(function (c, a) {
    for (var b in a) {
      if (!c[b]) c[b] = a[b];else if (-1 !== normalMerge.indexOf(b)) c[b] = _extends$1({}, c[b], a[b]);else if (-1 !== toArrayMerge.indexOf(b)) {
        var d = c[b] instanceof Array ? c[b] : [c[b]],
            e = a[b] instanceof Array ? a[b] : [a[b]];
        c[b] = d.concat(e);
      } else if (-1 !== functionalMerge.indexOf(b)) {
        for (var f in a[b]) {
          if (c[b][f]) {
            var g = c[b][f] instanceof Array ? c[b][f] : [c[b][f]],
                h = a[b][f] instanceof Array ? a[b][f] : [a[b][f]];
            c[b][f] = g.concat(h);
          } else c[b][f] = a[b][f];
        }
      } else if ("hook" == b) for (var i in a[b]) {
        c[b][i] = c[b][i] ? mergeFn(c[b][i], a[b][i]) : a[b][i];
      } else c[b] = a[b];
    }

    return c;
  }, {});
},
    mergeFn = function mergeFn(a, b) {
  return function () {
    a && a.apply(this, arguments), b && b.apply(this, arguments);
  };
};

var helper = mergeJsxProps;

// new Date(10, 0, 1) The year from 0 to 99 will be incremented by 1900 automatically.
function createDate(y) {
  var M = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var m = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var ms = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var date = new Date(y, M, d, h, m, s, ms);

  if (y < 100 && y >= 0) {
    date.setFullYear(y);
  }

  return date;
}
function isValidDate(date) {
  return date instanceof Date && !isNaN(date);
}
function isValidRangeDate(date) {
  return Array.isArray(date) && date.length === 2 && date.every(isValidDate) && date[0] <= date[1];
}
function isValidDates(dates) {
  return Array.isArray(dates) && dates.every(isValidDate);
}
function getValidDate(value) {
  var date = new Date(value);

  if (isValidDate(date)) {
    return date;
  }

  for (var _len = arguments.length, backup = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    backup[_key - 1] = arguments[_key];
  }

  if (backup.length) {
    return getValidDate.apply(void 0, backup);
  }

  return new Date();
}
function startOfYear(value) {
  var date = new Date(value);
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfMonth(value) {
  var date = new Date(value);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfDay(value) {
  var date = new Date(value);
  date.setHours(0, 0, 0, 0);
  return date;
}
function getCalendar(_ref) {
  var firstDayOfWeek = _ref.firstDayOfWeek,
      year = _ref.year,
      month = _ref.month;
  var arr = []; // change to the last day of the last month

  var calendar = createDate(year, month, 0);
  var lastDayInLastMonth = calendar.getDate(); // getDay() 0 is Sunday, 1 is Monday

  var firstDayInLastMonth = lastDayInLastMonth - (calendar.getDay() + 7 - firstDayOfWeek) % 7;

  for (var i = firstDayInLastMonth; i <= lastDayInLastMonth; i++) {
    arr.push(createDate(year, month, i - lastDayInLastMonth));
  } // change to the last day of the current month


  calendar.setMonth(month + 1, 0);
  var lastDayInCurrentMonth = calendar.getDate();

  for (var _i = 1; _i <= lastDayInCurrentMonth; _i++) {
    arr.push(createDate(year, month, _i));
  }

  var lastMonthLength = lastDayInLastMonth - firstDayInLastMonth + 1;
  var nextMonthLength = 6 * 7 - lastMonthLength - lastDayInCurrentMonth;

  for (var _i2 = 1; _i2 <= nextMonthLength; _i2++) {
    arr.push(createDate(year, month, lastDayInCurrentMonth + _i2));
  }

  return arr;
}
function setMonth(dirtyDate, dirtyMonth) {
  var date = new Date(dirtyDate);
  var month = typeof dirtyMonth === 'function' ? dirtyMonth(date.getMonth()) : Number(dirtyMonth);
  var year = date.getFullYear();
  var daysInMonth = createDate(year, month + 1, 0).getDate();
  var day = date.getDate();
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function setYear(dirtyDate, dirtyYear) {
  var date = new Date(dirtyDate);
  var year = typeof dirtyYear === 'function' ? dirtyYear(date.getFullYear()) : dirtyYear;
  date.setFullYear(year);
  return date;
}
function assignTime(target, source) {
  var date = new Date(target);
  var time = new Date(source);
  date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
  return date;
}

/**
 * chunk the array
 * @param {Array} arr
 * @param {Number} size
 */
function chunk(arr, size) {
  if (!Array.isArray(arr)) {
    return [];
  }

  var result = [];
  var len = arr.length;
  var i = 0;
  size = size || len;

  while (i < len) {
    result.push(arr.slice(i, i += size));
  }

  return result;
}
/**
 * isObject
 * @param {*} obj
 * @returns {Boolean}
 */

function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
/**
 * pick object
 * @param {Object} obj
 * @param {Array|String} props
 */

function pick(obj, props) {
  if (!isObject(obj)) return {};

  if (!Array.isArray(props)) {
    props = [props];
  }

  var res = {};
  props.forEach(function (prop) {
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  });
  return res;
}
/**
 * deep merge two object without merging array
 * @param {object} target
 * @param {object} source
 */

function mergeDeep(target, source) {
  if (!isObject(target)) {
    return {};
  }

  var result = target;

  if (isObject(source)) {
    Object.keys(source).forEach(function (key) {
      var value = source[key];

      if (isObject(value) && isObject(target[key])) {
        value = mergeDeep(target[key], value);
      }

      result = _objectSpread2({}, result, _defineProperty({}, key, value));
    });
  }

  return result;
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var en = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var locale = {
  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  weekdaysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  firstDayOfWeek: 0,
  firstWeekContainsDate: 1
};
var _default = locale;
exports["default"] = _default;
module.exports = exports.default;
});

var en$1 = unwrapExports(en);

var lang = {
  formatLocale: en$1,
  yearFormat: 'YYYY',
  monthFormat: 'MMM',
  monthBeforeYear: true
};

var defaultLocale = 'en';
var locales = {};
locales[defaultLocale] = lang;
function locale(name, object, isLocal) {
  if (typeof name !== 'string') return locales[defaultLocale];
  var l = defaultLocale;

  if (locales[name]) {
    l = name;
  }

  if (object) {
    locales[name] = object;
    l = name;
  }

  if (!isLocal) {
    defaultLocale = l;
  }

  return locales[name] || locales[defaultLocale];
}
/**
 * get locale object
 * @param {string} name lang
 */

function getLocale(name) {
  return locale(name, null, true);
}

/* istanbul ignore file */
function rafThrottle(fn) {
  var isRunning = false;
  return function fnBinfRaf() {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (isRunning) return;
    isRunning = true;
    requestAnimationFrame(function () {
      isRunning = false;
      fn.apply(_this, args);
    });
  };
}

/**
 * get the hidden element width, height
 * @param {HTMLElement} element dom
 */
function getPopupElementSize(element) {
  var originalDisplay = element.style.display;
  var originalVisibility = element.style.visibility;
  element.style.display = 'block';
  element.style.visibility = 'hidden';
  var styles = window.getComputedStyle(element);
  var width = element.offsetWidth + parseInt(styles.marginLeft, 10) + parseInt(styles.marginRight, 10);
  var height = element.offsetHeight + parseInt(styles.marginTop, 10) + parseInt(styles.marginBottom, 10);
  element.style.display = originalDisplay;
  element.style.visibility = originalVisibility;
  return {
    width: width,
    height: height
  };
}
/**
 * get the popup position
 * @param {HTMLElement} el relative element
 * @param {Number} targetWidth target element's width
 * @param {Number} targetHeight target element's height
 * @param {Boolean} fixed
 */

function getRelativePosition(el, targetWidth, targetHeight, fixed) {
  var left = 0;
  var top = 0;
  var offsetX = 0;
  var offsetY = 0;
  var relativeRect = el.getBoundingClientRect();
  var dw = document.documentElement.clientWidth;
  var dh = document.documentElement.clientHeight;

  if (fixed) {
    offsetX = window.pageXOffset + relativeRect.left;
    offsetY = window.pageYOffset + relativeRect.top;
  }

  if (dw - relativeRect.left < targetWidth && relativeRect.right < targetWidth) {
    left = offsetX - relativeRect.left + 1;
  } else if (relativeRect.left + relativeRect.width / 2 <= dw / 2) {
    left = offsetX;
  } else {
    left = offsetX + relativeRect.width - targetWidth;
  }

  if (relativeRect.top <= targetHeight && dh - relativeRect.bottom <= targetHeight) {
    top = offsetY + dh - relativeRect.top - targetHeight;
  } else if (relativeRect.top + relativeRect.height / 2 <= dh / 2) {
    top = offsetY + relativeRect.height;
  } else {
    top = offsetY - targetHeight;
  }

  return {
    left: "".concat(left, "px"),
    top: "".concat(top, "px")
  };
}
function getScrollParent(node) {
  var until = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;

  if (!node || node === until) {
    return null;
  }

  var style = function style(value, prop) {
    return getComputedStyle(value, null).getPropertyValue(prop);
  };

  var regex = /(auto|scroll)/;
  var scroll = regex.test(style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x'));
  return scroll ? node : getScrollParent(node.parentNode, until);
}

//
var script = {
  name: 'Popup',
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    appendToBody: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      top: '',
      left: ''
    };
  },
  watch: {
    visible: {
      immediate: true,
      handler: function handler(val) {
        var _this = this;

        this.$nextTick(function () {
          if (val) {
            _this.displayPopup();
          }
        });
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.appendToBody) {
      document.body.appendChild(this.$el);
    }

    this._clickoutEvent = 'ontouchend' in document ? 'touchstart' : 'mousedown';
    document.addEventListener(this._clickoutEvent, this.handleClickOutside); // change the popup position when resize or scroll

    var relativeElement = this.$parent.$el;
    this._displayPopup = rafThrottle(function () {
      return _this2.displayPopup();
    });
    this._scrollParent = getScrollParent(relativeElement) || window;

    this._scrollParent.addEventListener('scroll', this._displayPopup);

    window.addEventListener('resize', this._displayPopup);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.appendToBody && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }

    document.removeEventListener(this._clickoutEvent, this.handleClickOutside);

    this._scrollParent.removeEventListener('scroll', this._displayPopup);

    window.removeEventListener('resize', this._displayPopup);
  },
  methods: {
    handleClickOutside: function handleClickOutside(evt) {
      if (!this.visible) return;
      var target = evt.target;
      var el = this.$el;

      if (el && !el.contains(target)) {
        this.$emit('clickoutside', evt);
      }
    },
    displayPopup: function displayPopup() {
      if (!this.visible) return;
      var popup = this.$el;
      var relativeElement = this.$parent.$el;
      var appendToBody = this.appendToBody;

      if (!this._popupRect) {
        this._popupRect = getPopupElementSize(popup);
      }

      var _this$_popupRect = this._popupRect,
          width = _this$_popupRect.width,
          height = _this$_popupRect.height;

      var _getRelativePosition = getRelativePosition(relativeElement, width, height, appendToBody),
          left = _getRelativePosition.left,
          top = _getRelativePosition.top;

      this.left = left;
      this.top = top;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function (context) {
      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": _vm.prefixClass + "-zoom-in-down"
    }
  }, [_vm.visible ? _c('div', {
    class: _vm.prefixClass + "-datepicker-main " + _vm.prefixClass + "-datepicker-popup",
    style: {
      top: _vm.top,
      left: _vm.left,
      position: 'absolute'
    }
  }, [_vm._t("default")], 2) : _vm._e()]);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__ = normalizeComponent({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

/* script */

/* template */
var __vue_render__$1 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 1024 1024",
      "width": "1em",
      "height": "1em"
    }
  }, [_c('path', {
    attrs: {
      "d": "M940.218182 107.054545h-209.454546V46.545455h-65.163636v60.50909H363.054545V46.545455H297.890909v60.50909H83.781818c-18.618182 0-32.581818 13.963636-32.581818 32.581819v805.236363c0 18.618182 13.963636 32.581818 32.581818 32.581818h861.090909c18.618182 0 32.581818-13.963636 32.581818-32.581818V139.636364c-4.654545-18.618182-18.618182-32.581818-37.236363-32.581819zM297.890909 172.218182V232.727273h65.163636V172.218182h307.2V232.727273h65.163637V172.218182h176.872727v204.8H116.363636V172.218182h181.527273zM116.363636 912.290909V442.181818h795.927273v470.109091H116.363636z"
    }
  })]);
};

var __vue_staticRenderFns__$1 = [];
/* style */

var __vue_inject_styles__$1 = undefined;
/* scoped */

var __vue_scope_id__$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1 = normalizeComponent({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$1, {}, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

/* script */

/* template */
var __vue_render__$2 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    }
  }, [_c('path', {
    attrs: {
      "d": "M0 0h24v24H0z",
      "fill": "none"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "d": "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "d": "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
    }
  })]);
};

var __vue_staticRenderFns__$2 = [];
/* style */

var __vue_inject_styles__$2 = undefined;
/* scoped */

var __vue_scope_id__$2 = undefined;
/* module identifier */

var __vue_module_identifier__$2 = undefined;
/* functional template */

var __vue_is_functional_template__$2 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$2 = normalizeComponent({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$2, {}, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

/* script */

/* template */
var __vue_render__$3 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 1024 1024",
      "width": "1em",
      "height": "1em"
    }
  }, [_c('path', {
    attrs: {
      "d": "M810.005333 274.005333l-237.994667 237.994667 237.994667 237.994667-60.010667 60.010667-237.994667-237.994667-237.994667 237.994667-60.010667-60.010667 237.994667-237.994667-237.994667-237.994667 60.010667-60.010667 237.994667 237.994667 237.994667-237.994667z"
    }
  })]);
};

var __vue_staticRenderFns__$3 = [];
/* style */

var __vue_inject_styles__$3 = undefined;
/* scoped */

var __vue_scope_id__$3 = undefined;
/* module identifier */

var __vue_module_identifier__$3 = undefined;
/* functional template */

var __vue_is_functional_template__$3 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$3 = normalizeComponent({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$3, {}, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1 = {
  props: {
    type: String,
    disabled: Boolean
  },
  inject: {
    prefixClass: {
      default: 'mx'
    }
  }
};

/* script */
var __vue_script__$1 = script$1;
/* template */

var __vue_render__$4 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('button', _vm._g({
    class: [_vm.prefixClass + "-btn " + _vm.prefixClass + "-btn-text " + _vm.prefixClass + "-btn-icon-" + _vm.type, {
      disabled: _vm.disabled
    }],
    attrs: {
      "type": "button",
      "disabled": _vm.disabled
    }
  }, _vm.$listeners), [_c('i', {
    class: _vm.prefixClass + "-icon-" + _vm.type
  })]);
};

var __vue_staticRenderFns__$4 = [];
/* style */

var __vue_inject_styles__$4 = undefined;
/* scoped */

var __vue_scope_id__$4 = undefined;
/* module identifier */

var __vue_module_identifier__$4 = undefined;
/* functional template */

var __vue_is_functional_template__$4 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$4 = normalizeComponent({
  render: __vue_render__$4,
  staticRenderFns: __vue_staticRenderFns__$4
}, __vue_inject_styles__$4, __vue_script__$1, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

var script$2 = {
  name: 'TableDate',
  components: {
    IconButton: __vue_component__$4
  },
  inject: {
    getLocale: {
      default: function _default() {
        return getLocale;
      }
    },
    getWeek: {
      default: function _default() {
        return date_format_parse__WEBPACK_IMPORTED_MODULE_0__.getWeek;
      }
    },
    prefixClass: {
      default: 'mx'
    },
    onDateMouseEnter: {
      default: undefined
    },
    onDateMouseLeave: {
      default: undefined
    }
  },
  props: {
    disabledCalendarChanger: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    calendar: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    titleFormat: {
      type: String,
      default: 'YYYY-MM-DD'
    },
    getRowClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    },
    getCellClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    firstDayOfWeek: function firstDayOfWeek() {
      return this.getLocale().formatLocale.firstDayOfWeek || 0;
    },
    yearMonth: function yearMonth() {
      var _this$getLocale = this.getLocale(),
          yearFormat = _this$getLocale.yearFormat,
          monthBeforeYear = _this$getLocale.monthBeforeYear,
          _this$getLocale$month = _this$getLocale.monthFormat,
          monthFormat = _this$getLocale$month === void 0 ? 'MMM' : _this$getLocale$month;

      var yearLabel = {
        panel: 'year',
        label: this.formatDate(this.calendar, yearFormat)
      };
      var monthLabel = {
        panel: 'month',
        label: this.formatDate(this.calendar, monthFormat)
      };
      return monthBeforeYear ? [monthLabel, yearLabel] : [yearLabel, monthLabel];
    },
    days: function days() {
      var locale = this.getLocale();
      var days = locale.days || locale.formatLocale.weekdaysMin;
      return days.concat(days).slice(this.firstDayOfWeek, this.firstDayOfWeek + 7);
    },
    dates: function dates() {
      var year = this.calendar.getFullYear();
      var month = this.calendar.getMonth();
      var arr = getCalendar({
        firstDayOfWeek: this.firstDayOfWeek,
        year: year,
        month: month
      });
      return chunk(arr, 7);
    }
  },
  methods: {
    isDisabledArrows: function isDisabledArrows(type) {
      var date = new Date(this.calendar);

      switch (type) {
        case 'last-year':
          date.setFullYear(date.getFullYear() - 1, date.getMonth() + 1, 0);
          date.setHours(23, 59, 59, 999);
          break;

        case 'next-year':
          date.setFullYear(date.getFullYear() + 1);
          break;

        case 'last-month':
          date.setMonth(date.getMonth(), 0);
          date.setHours(23, 59, 59, 999);
          break;

        case 'next-month':
          date.setMonth(date.getMonth() + 1);
          break;
      }

      return this.disabledCalendarChanger(date, type);
    },
    handleIconLeftClick: function handleIconLeftClick() {
      this.$emit('changecalendar', setMonth(this.calendar, function (v) {
        return v - 1;
      }), 'last-month');
    },
    handleIconRightClick: function handleIconRightClick() {
      this.$emit('changecalendar', setMonth(this.calendar, function (v) {
        return v + 1;
      }), 'next-month');
    },
    handleIconDoubleLeftClick: function handleIconDoubleLeftClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v - 1;
      }), 'last-year');
    },
    handleIconDoubleRightClick: function handleIconDoubleRightClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v + 1;
      }), 'next-year');
    },
    handlePanelChange: function handlePanelChange(panel) {
      this.$emit('changepanel', panel);
    },
    handleMouseEnter: function handleMouseEnter(cell) {
      if (typeof this.onDateMouseEnter === 'function') {
        this.onDateMouseEnter(cell);
      }
    },
    handleMouseLeave: function handleMouseLeave(cell) {
      if (typeof this.onDateMouseLeave === 'function') {
        this.onDateMouseLeave(cell);
      }
    },
    handleCellClick: function handleCellClick(evt) {
      var target = evt.target;

      if (target.tagName.toUpperCase() === 'DIV') {
        target = target.parentNode;
      }

      var index = target.getAttribute('data-row-col');

      if (index) {
        var _index$split$map = index.split(',').map(function (v) {
          return parseInt(v, 10);
        }),
            _index$split$map2 = _slicedToArray(_index$split$map, 2),
            row = _index$split$map2[0],
            col = _index$split$map2[1];

        var date = this.dates[row][col];
        this.$emit('select', new Date(date));
      }
    },
    formatDate: function formatDate(date, fmt) {
      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.format)(date, fmt, {
        locale: this.getLocale().formatLocale
      });
    },
    getCellTitle: function getCellTitle(date) {
      var fmt = this.titleFormat;
      return this.formatDate(date, fmt);
    },
    getWeekNumber: function getWeekNumber(date) {
      return this.getWeek(date, this.getLocale().formatLocale);
    }
  }
};

/* script */
var __vue_script__$2 = script$2;
/* template */

var __vue_render__$5 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-calendar " + _vm.prefixClass + "-calendar-panel-date"
  }, [_c('div', {
    class: _vm.prefixClass + "-calendar-header"
  }, [_c('icon-button', {
    attrs: {
      "type": "double-left",
      "disabled": _vm.isDisabledArrows('last-year')
    },
    on: {
      "click": _vm.handleIconDoubleLeftClick
    }
  }), _vm._v(" "), _c('icon-button', {
    attrs: {
      "type": "left",
      "disabled": _vm.isDisabledArrows('last-month')
    },
    on: {
      "click": _vm.handleIconLeftClick
    }
  }), _vm._v(" "), _c('icon-button', {
    attrs: {
      "type": "double-right",
      "disabled": _vm.isDisabledArrows('next-year')
    },
    on: {
      "click": _vm.handleIconDoubleRightClick
    }
  }), _vm._v(" "), _c('icon-button', {
    attrs: {
      "type": "right",
      "disabled": _vm.isDisabledArrows('next-month')
    },
    on: {
      "click": _vm.handleIconRightClick
    }
  }), _vm._v(" "), _c('span', {
    class: _vm.prefixClass + "-calendar-header-label"
  }, _vm._l(_vm.yearMonth, function (item) {
    return _c('button', {
      key: item.panel,
      class: _vm.prefixClass + "-btn " + _vm.prefixClass + "-btn-text " + _vm.prefixClass + "-btn-current-" + item.panel,
      attrs: {
        "type": "button"
      },
      on: {
        "click": function click($event) {
          return _vm.handlePanelChange(item.panel);
        }
      }
    }, [_vm._v("\n        " + _vm._s(item.label) + "\n      ")]);
  }), 0)], 1), _vm._v(" "), _c('div', {
    class: _vm.prefixClass + "-calendar-content"
  }, [_c('table', {
    class: _vm.prefixClass + "-table " + _vm.prefixClass + "-table-date"
  }, [_c('thead', [_c('tr', [_vm.showWeekNumber ? _c('th', {
    class: _vm.prefixClass + "-week-number-header"
  }) : _vm._e(), _vm._v(" "), _vm._l(_vm.days, function (day) {
    return _c('th', {
      key: day
    }, [_vm._v(_vm._s(day))]);
  })], 2)]), _vm._v(" "), _c('tbody', {
    on: {
      "click": _vm.handleCellClick
    }
  }, _vm._l(_vm.dates, function (row, i) {
    return _c('tr', {
      key: i,
      class: [_vm.prefixClass + "-date-row", _vm.getRowClasses(row)]
    }, [_vm.showWeekNumber ? _c('td', {
      class: _vm.prefixClass + "-week-number",
      attrs: {
        "data-row-col": i + ",0"
      }
    }, [_vm._v("\n            " + _vm._s(_vm.getWeekNumber(row[0])) + "\n          ")]) : _vm._e(), _vm._v(" "), _vm._l(row, function (cell, j) {
      return _c('td', {
        key: j,
        staticClass: "cell",
        class: _vm.getCellClasses(cell),
        attrs: {
          "data-row-col": i + "," + j,
          "title": _vm.getCellTitle(cell)
        },
        on: {
          "mouseenter": function mouseenter($event) {
            return _vm.handleMouseEnter(cell);
          },
          "mouseleave": function mouseleave($event) {
            return _vm.handleMouseLeave(cell);
          }
        }
      }, [_c('div', [_vm._v(_vm._s(cell.getDate()))])]);
    })], 2);
  }), 0)])])]);
};

var __vue_staticRenderFns__$5 = [];
/* style */

var __vue_inject_styles__$5 = undefined;
/* scoped */

var __vue_scope_id__$5 = undefined;
/* module identifier */

var __vue_module_identifier__$5 = undefined;
/* functional template */

var __vue_is_functional_template__$5 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$5 = normalizeComponent({
  render: __vue_render__$5,
  staticRenderFns: __vue_staticRenderFns__$5
}, __vue_inject_styles__$5, __vue_script__$2, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

//
var script$3 = {
  name: 'TableMonth',
  components: {
    IconButton: __vue_component__$4
  },
  inject: {
    getLocale: {
      default: function _default() {
        return getLocale;
      }
    },
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    disabledCalendarChanger: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    calendar: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    getCellClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    calendarYear: function calendarYear() {
      return this.calendar.getFullYear();
    },
    months: function months() {
      var locale = this.getLocale();
      var monthsLocale = locale.months || locale.formatLocale.monthsShort;
      var months = monthsLocale.map(function (text, month) {
        return {
          text: text,
          month: month
        };
      });
      return chunk(months, 3);
    }
  },
  methods: {
    isDisabledArrows: function isDisabledArrows(type) {
      var date = new Date(this.calendar);

      switch (type) {
        case 'last-year':
          date.setFullYear(date.getFullYear() - 1, 11, 31);
          date.setHours(23, 59, 59, 999);
          break;

        case 'next-year':
          date.setFullYear(date.getFullYear() + 1, 0, 1);
          break;
      }

      return this.disabledCalendarChanger(date, type);
    },
    handleIconDoubleLeftClick: function handleIconDoubleLeftClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v - 1;
      }), 'last-year');
    },
    handleIconDoubleRightClick: function handleIconDoubleRightClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v + 1;
      }), 'next-year');
    },
    handlePanelChange: function handlePanelChange() {
      this.$emit('changepanel', 'year');
    },
    handleClick: function handleClick(evt) {
      var target = evt.target;

      if (target.tagName.toUpperCase() === 'DIV') {
        target = target.parentNode;
      }

      var month = target.getAttribute('data-month');

      if (month && !target.classList.contains('disabled')) {
        this.$emit('select', parseInt(month, 10));
      }
    }
  }
};

/* script */
var __vue_script__$3 = script$3;
/* template */

var __vue_render__$6 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-calendar " + _vm.prefixClass + "-calendar-panel-month"
  }, [_c('div', {
    class: _vm.prefixClass + "-calendar-header"
  }, [_c('icon-button', {
    attrs: {
      "type": "double-left",
      "disabled": _vm.isDisabledArrows('last-year')
    },
    on: {
      "click": _vm.handleIconDoubleLeftClick
    }
  }), _vm._v(" "), _c('icon-button', {
    attrs: {
      "type": "double-right",
      "disabled": _vm.isDisabledArrows('next-year')
    },
    on: {
      "click": _vm.handleIconDoubleRightClick
    }
  }), _vm._v(" "), _c('span', {
    class: _vm.prefixClass + "-calendar-header-label"
  }, [_c('button', {
    class: _vm.prefixClass + "-btn " + _vm.prefixClass + "-btn-text",
    attrs: {
      "type": "button"
    },
    on: {
      "click": _vm.handlePanelChange
    }
  }, [_vm._v("\n        " + _vm._s(_vm.calendarYear) + "\n      ")])])], 1), _vm._v(" "), _c('div', {
    class: _vm.prefixClass + "-calendar-content"
  }, [_c('table', {
    class: _vm.prefixClass + "-table " + _vm.prefixClass + "-table-month",
    on: {
      "click": _vm.handleClick
    }
  }, _vm._l(_vm.months, function (row, i) {
    return _c('tr', {
      key: i
    }, _vm._l(row, function (cell, j) {
      return _c('td', {
        key: j,
        staticClass: "cell",
        class: _vm.getCellClasses(cell.month),
        attrs: {
          "data-month": cell.month
        }
      }, [_c('div', [_vm._v(_vm._s(cell.text))])]);
    }), 0);
  }), 0)])]);
};

var __vue_staticRenderFns__$6 = [];
/* style */

var __vue_inject_styles__$6 = undefined;
/* scoped */

var __vue_scope_id__$6 = undefined;
/* module identifier */

var __vue_module_identifier__$6 = undefined;
/* functional template */

var __vue_is_functional_template__$6 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$6 = normalizeComponent({
  render: __vue_render__$6,
  staticRenderFns: __vue_staticRenderFns__$6
}, __vue_inject_styles__$6, __vue_script__$3, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

//
var script$4 = {
  name: 'TableYear',
  components: {
    IconButton: __vue_component__$4
  },
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    disabledCalendarChanger: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    calendar: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    getCellClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    },
    getYearPanel: {
      type: Function
    }
  },
  computed: {
    years: function years() {
      var calendar = new Date(this.calendar);

      if (typeof this.getYearPanel === 'function') {
        return this.getYearPanel(calendar);
      }

      return this.getYears(calendar);
    },
    firstYear: function firstYear() {
      return this.years[0][0];
    },
    lastYear: function lastYear() {
      var last = function last(arr) {
        return arr[arr.length - 1];
      };

      return last(last(this.years));
    }
  },
  methods: {
    isDisabledArrows: function isDisabledArrows(type) {
      var date = new Date(this.calendar);

      switch (type) {
        case 'last-decade':
          date.setFullYear(this.firstYear - 1, 11, 31);
          date.setHours(23, 59, 59, 999);
          break;

        case 'next-decade':
          date.setFullYear(this.lastYear + 1, 0, 1);
          break;
      }

      return this.disabledCalendarChanger(date, type);
    },
    getYears: function getYears(calendar) {
      var firstYear = Math.floor(calendar.getFullYear() / 10) * 10;
      var years = [];

      for (var i = 0; i < 10; i++) {
        years.push(firstYear + i);
      }

      return chunk(years, 2);
    },
    handleIconDoubleLeftClick: function handleIconDoubleLeftClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v - 10;
      }), 'last-decade');
    },
    handleIconDoubleRightClick: function handleIconDoubleRightClick() {
      this.$emit('changecalendar', setYear(this.calendar, function (v) {
        return v + 10;
      }), 'next-decade');
    },
    handleClick: function handleClick(evt) {
      var target = evt.target;

      if (target.tagName.toUpperCase() === 'DIV') {
        target = target.parentNode;
      }

      var year = target.getAttribute('data-year');

      if (year && !target.classList.contains('disabled')) {
        this.$emit('select', parseInt(year, 10));
      }
    }
  }
};

/* script */
var __vue_script__$4 = script$4;
/* template */

var __vue_render__$7 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-calendar " + _vm.prefixClass + "-calendar-panel-year"
  }, [_c('div', {
    class: _vm.prefixClass + "-calendar-header"
  }, [_c('icon-button', {
    attrs: {
      "type": "double-left",
      "disabled": _vm.isDisabledArrows('last-decade')
    },
    on: {
      "click": _vm.handleIconDoubleLeftClick
    }
  }), _vm._v(" "), _c('icon-button', {
    attrs: {
      "type": "double-right",
      "disabled": _vm.isDisabledArrows('next-decade')
    },
    on: {
      "click": _vm.handleIconDoubleRightClick
    }
  }), _vm._v(" "), _c('span', {
    class: _vm.prefixClass + "-calendar-header-label"
  }, [_c('span', [_vm._v(_vm._s(_vm.firstYear))]), _vm._v(" "), _c('span', {
    class: _vm.prefixClass + "-calendar-decade-separator"
  }), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.lastYear))])])], 1), _vm._v(" "), _c('div', {
    class: _vm.prefixClass + "-calendar-content"
  }, [_c('table', {
    class: _vm.prefixClass + "-table " + _vm.prefixClass + "-table-year",
    on: {
      "click": _vm.handleClick
    }
  }, _vm._l(_vm.years, function (row, i) {
    return _c('tr', {
      key: i
    }, _vm._l(row, function (cell, j) {
      return _c('td', {
        key: j,
        staticClass: "cell",
        class: _vm.getCellClasses(cell),
        attrs: {
          "data-year": cell
        }
      }, [_c('div', [_vm._v(_vm._s(cell))])]);
    }), 0);
  }), 0)])]);
};

var __vue_staticRenderFns__$7 = [];
/* style */

var __vue_inject_styles__$7 = undefined;
/* scoped */

var __vue_scope_id__$7 = undefined;
/* module identifier */

var __vue_module_identifier__$7 = undefined;
/* functional template */

var __vue_is_functional_template__$7 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$7 = normalizeComponent({
  render: __vue_render__$7,
  staticRenderFns: __vue_staticRenderFns__$7
}, __vue_inject_styles__$7, __vue_script__$4, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

var CalendarPanel = {
  name: 'CalendarPanel',
  inject: {
    prefixClass: {
      default: 'mx'
    },
    dispatchDatePicker: {
      default: function _default() {
        return function () {};
      }
    }
  },
  props: {
    value: {},
    defaultValue: {
      default: function _default() {
        var date = new Date();
        date.setHours(0, 0, 0, 0);
        return date;
      }
    },
    defaultPanel: {
      type: String
    },
    disabledCalendarChanger: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    disabledDate: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    type: {
      type: String,
      default: 'date'
    },
    getClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    },
    showWeekNumber: {
      type: Boolean,
      default: undefined
    },
    getYearPanel: {
      type: Function
    },
    titleFormat: {
      type: String,
      default: 'YYYY-MM-DD'
    },
    calendar: Date,
    // update date when select year or month
    partialUpdate: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    var panels = ['date', 'month', 'year'];
    var index = Math.max(panels.indexOf(this.type), panels.indexOf(this.defaultPanel));
    var panel = index !== -1 ? panels[index] : 'date';
    return {
      panel: panel,
      innerCalendar: new Date()
    };
  },
  computed: {
    innerValue: function innerValue() {
      var value = Array.isArray(this.value) ? this.value : [this.value];
      var map = {
        year: startOfYear,
        month: startOfMonth,
        date: startOfDay
      };
      var start = map[this.type] || map.date;
      return value.filter(isValidDate).map(function (v) {
        return start(v);
      });
    },
    calendarYear: function calendarYear() {
      return this.innerCalendar.getFullYear();
    },
    calendarMonth: function calendarMonth() {
      return this.innerCalendar.getMonth();
    }
  },
  watch: {
    value: {
      immediate: true,
      handler: 'initCalendar'
    },
    calendar: {
      handler: 'initCalendar'
    },
    defaultValue: {
      handler: 'initCalendar'
    }
  },
  methods: {
    initCalendar: function initCalendar() {
      var calendarDate = this.calendar;

      if (!isValidDate(calendarDate)) {
        var length = this.innerValue.length;
        calendarDate = getValidDate(length > 0 ? this.innerValue[length - 1] : this.defaultValue);
      }

      this.innerCalendar = startOfMonth(calendarDate);
    },
    isDisabled: function isDisabled(date) {
      return this.disabledDate(new Date(date), this.innerValue);
    },
    emitDate: function emitDate(date, type) {
      if (!this.isDisabled(date)) {
        this.$emit('select', date, type, this.innerValue); // someone need get the first selected date to set range value. (#429)

        this.dispatchDatePicker('pick', date, type);
      }
    },
    handleCalendarChange: function handleCalendarChange(calendar, type) {
      var oldCalendar = new Date(this.innerCalendar);
      this.innerCalendar = calendar;
      this.$emit('update:calendar', calendar);
      this.dispatchDatePicker('calendar-change', calendar, oldCalendar, type);
    },
    handelPanelChange: function handelPanelChange(panel) {
      var oldPanel = this.panel;
      this.panel = panel;
      this.dispatchDatePicker('panel-change', panel, oldPanel);
    },
    handleSelectYear: function handleSelectYear(year) {
      if (this.type === 'year') {
        var date = this.getYearCellDate(year);
        this.emitDate(date, 'year');
      } else {
        this.handleCalendarChange(createDate(year, this.calendarMonth), 'year');
        this.handelPanelChange('month');

        if (this.partialUpdate && this.innerValue.length === 1) {
          var _date = new Date(this.innerValue[0]);

          _date.setFullYear(year);

          this.emitDate(_date, 'year');
        }
      }
    },
    handleSelectMonth: function handleSelectMonth(month) {
      if (this.type === 'month') {
        var date = this.getMonthCellDate(month);
        this.emitDate(date, 'month');
      } else {
        this.handleCalendarChange(createDate(this.calendarYear, month), 'month');
        this.handelPanelChange('date');

        if (this.partialUpdate && this.innerValue.length === 1) {
          var _date2 = new Date(this.innerValue[0]);

          _date2.setFullYear(this.calendarYear);

          this.emitDate(setMonth(_date2, month), 'month');
        }
      }
    },
    handleSelectDate: function handleSelectDate(date) {
      this.emitDate(date, this.type === 'week' ? 'week' : 'date');
    },
    getMonthCellDate: function getMonthCellDate(month) {
      return createDate(this.calendarYear, month);
    },
    getYearCellDate: function getYearCellDate(year) {
      return createDate(year, 0);
    },
    getDateClasses: function getDateClasses(cellDate) {
      var notCurrentMonth = cellDate.getMonth() !== this.calendarMonth;
      var classes = [];

      if (cellDate.getTime() === new Date().setHours(0, 0, 0, 0)) {
        classes.push('today');
      }

      if (notCurrentMonth) {
        classes.push('not-current-month');
      }

      var state = this.getStateClass(cellDate);

      if (!(state === 'active' && notCurrentMonth)) {
        classes.push(state);
      }

      return classes.concat(this.getClasses(cellDate, this.innerValue, classes.join(' ')));
    },
    getMonthClasses: function getMonthClasses(month) {
      var classes = [];

      if (this.type !== 'month') {
        if (this.calendarMonth === month) {
          classes.push('active');
        }

        var _cellDate = this.getMonthCellDate(month);

        if (this.disabledCalendarChanger(_cellDate, 'month')) {
          classes.push('disabled');
        }

        return classes;
      }

      var cellDate = this.getMonthCellDate(month);
      classes.push(this.getStateClass(cellDate));
      return classes.concat(this.getClasses(cellDate, this.innerValue, classes.join(' ')));
    },
    getYearClasses: function getYearClasses(year) {
      var classes = [];

      if (this.type !== 'year') {
        if (this.calendarYear === year) {
          classes.push('active');
        }

        var _cellDate2 = this.getYearCellDate(year);

        if (this.disabledCalendarChanger(_cellDate2, 'year')) {
          classes.push('disabled');
        }

        return classes;
      }

      var cellDate = this.getYearCellDate(year);
      classes.push(this.getStateClass(cellDate));
      return classes.concat(this.getClasses(cellDate, this.innerValue, classes.join(' ')));
    },
    getStateClass: function getStateClass(cellDate) {
      if (this.isDisabled(cellDate)) {
        return 'disabled';
      }

      if (this.innerValue.some(function (v) {
        return v.getTime() === cellDate.getTime();
      })) {
        return 'active';
      }

      return '';
    },
    getWeekState: function getWeekState(row) {
      if (this.type !== 'week') return '';
      var start = row[0].getTime();
      var end = row[6].getTime();
      var active = this.innerValue.some(function (v) {
        var time = v.getTime();
        return time >= start && time <= end;
      });
      return active ? "".concat(this.prefixClass, "-active-week") : '';
    }
  },
  render: function render() {
    var h = arguments[0];
    var panel = this.panel,
        innerCalendar = this.innerCalendar;

    if (panel === 'year') {
      return h(__vue_component__$7, {
        "attrs": {
          "disabledCalendarChanger": this.disabledCalendarChanger,
          "calendar": innerCalendar,
          "getCellClasses": this.getYearClasses,
          "getYearPanel": this.getYearPanel
        },
        "on": {
          "select": this.handleSelectYear,
          "changecalendar": this.handleCalendarChange
        }
      });
    }

    if (panel === 'month') {
      return h(__vue_component__$6, {
        "attrs": {
          "disabledCalendarChanger": this.disabledCalendarChanger,
          "calendar": innerCalendar,
          "getCellClasses": this.getMonthClasses
        },
        "on": {
          "select": this.handleSelectMonth,
          "changepanel": this.handelPanelChange,
          "changecalendar": this.handleCalendarChange
        }
      });
    }

    return h(__vue_component__$5, {
      "attrs": {
        "disabledCalendarChanger": this.disabledCalendarChanger,
        "calendar": innerCalendar,
        "getCellClasses": this.getDateClasses,
        "getRowClasses": this.getWeekState,
        "titleFormat": this.titleFormat,
        "showWeekNumber": typeof this.showWeekNumber === 'boolean' ? this.showWeekNumber : this.type === 'week'
      },
      "class": _defineProperty({}, "".concat(this.prefixClass, "-calendar-week-mode"), this.type === 'week'),
      "on": {
        "select": this.handleSelectDate,
        "changepanel": this.handelPanelChange,
        "changecalendar": this.handleCalendarChange
      }
    });
  }
};

var CalendarRange = {
  name: 'CalendarRange',
  components: {
    CalendarPanel: CalendarPanel
  },
  provide: function provide() {
    return {
      onDateMouseEnter: this.onDateMouseEnter,
      onDateMouseLeave: this.onDateMouseLeave
    };
  },
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  props: _objectSpread2({}, CalendarPanel.props),
  data: function data() {
    return {
      innerValue: [],
      calendars: [],
      hoveredValue: null
    };
  },
  computed: {
    // Minimum difference between start and end calendars
    calendarMinDiff: function calendarMinDiff() {
      var map = {
        date: 1,
        // type:date  min 1 month
        month: 1 * 12,
        // type:month min 1 year
        year: 10 * 12 // type:year  min 10 year

      };
      return map[this.type] || map.date;
    },
    calendarMaxDiff: function calendarMaxDiff() {
      return Infinity;
    },
    defaultValues: function defaultValues() {
      return Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue, this.defaultValue];
    }
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler() {
        var _this = this;

        this.innerValue = isValidRangeDate(this.value) ? this.value : [new Date(NaN), new Date(NaN)];
        var calendars = this.innerValue.map(function (v, i) {
          return startOfMonth(getValidDate(v, _this.defaultValues[i]));
        });
        this.updateCalendars(calendars);
      }
    }
  },
  methods: {
    handleSelect: function handleSelect(date, type) {
      var _this$innerValue = _slicedToArray(this.innerValue, 2),
          startValue = _this$innerValue[0],
          endValue = _this$innerValue[1];

      if (isValidDate(startValue) && !isValidDate(endValue)) {
        if (startValue.getTime() > date.getTime()) {
          this.innerValue = [date, startValue];
        } else {
          this.innerValue = [startValue, date];
        }

        this.emitDate(this.innerValue, type);
      } else {
        this.innerValue = [date, new Date(NaN)];
      }
    },
    onDateMouseEnter: function onDateMouseEnter(cell) {
      this.hoveredValue = cell;
    },
    onDateMouseLeave: function onDateMouseLeave() {
      this.hoveredValue = null;
    },
    emitDate: function emitDate(dates, type) {
      this.$emit('select', dates, type);
    },
    updateStartCalendar: function updateStartCalendar(value) {
      this.updateCalendars([value, this.calendars[1]], 1);
    },
    updateEndCalendar: function updateEndCalendar(value) {
      this.updateCalendars([this.calendars[0], value], 0);
    },
    updateCalendars: function updateCalendars(calendars) {
      var adjustIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var gap = this.getCalendarGap(calendars);

      if (gap) {
        var calendar = new Date(calendars[adjustIndex]);
        calendar.setMonth(calendar.getMonth() + (adjustIndex === 0 ? -gap : gap));
        calendars[adjustIndex] = calendar;
      }

      this.calendars = calendars;
    },
    getCalendarGap: function getCalendarGap(calendars) {
      var _calendars = _slicedToArray(calendars, 2),
          calendarLeft = _calendars[0],
          calendarRight = _calendars[1];

      var yearDiff = calendarRight.getFullYear() - calendarLeft.getFullYear();
      var monthDiff = calendarRight.getMonth() - calendarLeft.getMonth();
      var diff = yearDiff * 12 + monthDiff;
      var min = this.calendarMinDiff;
      var max = this.calendarMaxDiff;

      if (diff < min) {
        return min - diff;
      }

      if (diff > max) {
        return max - diff;
      }

      return 0;
    },
    getRangeClasses: function getRangeClasses(cellDate, currentDates, classnames) {
      var classes = [].concat(this.getClasses(cellDate, currentDates, classnames));
      if (/disabled|active/.test(classnames)) return classes;

      var inRange = function inRange(data, range) {
        var fn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
          return v.getTime();
        };
        var value = fn(data);

        var _range$map = range.map(fn),
            _range$map2 = _slicedToArray(_range$map, 2),
            min = _range$map2[0],
            max = _range$map2[1];

        if (min > max) {
          var _ref = [max, min];
          min = _ref[0];
          max = _ref[1];
        }

        return value > min && value < max;
      };

      if (currentDates.length === 2 && inRange(cellDate, currentDates)) {
        return classes.concat('in-range');
      }

      if (currentDates.length === 1 && this.hoveredValue && inRange(cellDate, [currentDates[0], this.hoveredValue])) {
        return classes.concat('hover-in-range');
      }

      return classes;
    }
  },
  render: function render() {
    var _this2 = this;

    var h = arguments[0];
    var calendarRange = this.calendars.map(function (calendar, index) {
      var props = _objectSpread2({}, _this2.$props, {
        calendar: calendar,
        value: _this2.innerValue,
        defaultValue: _this2.defaultValues[index],
        getClasses: _this2.getRangeClasses,
        // don't update when range is true
        partialUpdate: false
      });

      var on = {
        select: _this2.handleSelect,
        'update:calendar': index === 0 ? _this2.updateStartCalendar : _this2.updateEndCalendar
      };
      return h("calendar-panel", {
        "props": _objectSpread2({}, props),
        "on": _objectSpread2({}, on)
      });
    });
    var prefixClass = this.prefixClass;
    return h("div", {
      "class": "".concat(prefixClass, "-range-wrapper")
    }, [calendarRange]);
  }
};

var scrollBarWidth;
function getScrollbarWidth () {
  if (typeof window === 'undefined') return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;
  var outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  scrollBarWidth = outer.offsetWidth - inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  return scrollBarWidth;
}

//
var script$5 = {
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  data: function data() {
    return {
      scrollbarWidth: 0,
      thumbTop: '',
      thumbHeight: ''
    };
  },
  created: function created() {
    this.scrollbarWidth = getScrollbarWidth();
    document.addEventListener('mouseup', this.handleDragend);
  },
  beforeDestroy: function beforeDestroy() {
    document.addEventListener('mouseup', this.handleDragend);
  },
  mounted: function mounted() {
    this.$nextTick(this.getThumbSize);
  },
  methods: {
    getThumbSize: function getThumbSize() {
      var wrap = this.$refs.wrap;
      if (!wrap) return;
      var heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
      this.thumbHeight = heightPercentage < 100 ? "".concat(heightPercentage, "%") : '';
    },
    handleScroll: function handleScroll(evt) {
      var el = evt.currentTarget;
      var scrollHeight = el.scrollHeight,
          scrollTop = el.scrollTop;
      this.thumbTop = "".concat(scrollTop * 100 / scrollHeight, "%");
    },
    handleDragstart: function handleDragstart(evt) {
      evt.stopImmediatePropagation();
      this._draggable = true;
      var offsetTop = this.$refs.thumb.offsetTop;
      this._prevY = evt.clientY - offsetTop;
      document.addEventListener('mousemove', this.handleDraging);
    },
    handleDraging: function handleDraging(evt) {
      if (!this._draggable) return;
      var clientY = evt.clientY;
      var wrap = this.$refs.wrap;
      var scrollHeight = wrap.scrollHeight,
          clientHeight = wrap.clientHeight;
      var offsetY = clientY - this._prevY;
      var top = offsetY * scrollHeight / clientHeight;
      wrap.scrollTop = top;
    },
    handleDragend: function handleDragend() {
      if (this._draggable) {
        this._draggable = false;
        document.removeEventListener('mousemove', this.handleDraging);
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;
/* template */

var __vue_render__$8 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-scrollbar",
    style: {
      position: 'relative',
      overflow: 'hidden'
    }
  }, [_c('div', {
    ref: "wrap",
    class: _vm.prefixClass + "-scrollbar-wrap",
    style: {
      marginRight: "-" + _vm.scrollbarWidth + "px"
    },
    on: {
      "scroll": _vm.handleScroll
    }
  }, [_vm._t("default")], 2), _vm._v(" "), _c('div', {
    class: _vm.prefixClass + "-scrollbar-track"
  }, [_c('div', {
    ref: "thumb",
    class: _vm.prefixClass + "-scrollbar-thumb",
    style: {
      height: _vm.thumbHeight,
      top: _vm.thumbTop
    },
    on: {
      "mousedown": _vm.handleDragstart
    }
  })])]);
};

var __vue_staticRenderFns__$8 = [];
/* style */

var __vue_inject_styles__$8 = undefined;
/* scoped */

var __vue_scope_id__$8 = undefined;
/* module identifier */

var __vue_module_identifier__$8 = undefined;
/* functional template */

var __vue_is_functional_template__$8 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$8 = normalizeComponent({
  render: __vue_render__$8,
  staticRenderFns: __vue_staticRenderFns__$8
}, __vue_inject_styles__$8, __vue_script__$5, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

//

var padNumber = function padNumber(value) {
  value = parseInt(value, 10);
  return value < 10 ? "0".concat(value) : "".concat(value);
};

var generateOptions = function generateOptions(length, step, options) {
  if (Array.isArray(options)) {
    return options.filter(function (v) {
      return v >= 0 && v < length;
    });
  }

  if (step <= 0) {
    step = 1;
  }

  var arr = [];

  for (var i = 0; i < length; i += step) {
    arr.push(i);
  }

  return arr;
};

var scrollTo = function scrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  // jump to target if duration zero
  if (duration <= 0) {
    requestAnimationFrame(function () {
      element.scrollTop = to;
    });
    return;
  }

  var difference = to - element.scrollTop;
  var tick = difference / duration * 10;
  requestAnimationFrame(function () {
    var scrollTop = element.scrollTop + tick;

    if (scrollTop >= to) {
      element.scrollTop = to;
      return;
    }

    element.scrollTop = scrollTop;
    scrollTo(element, to, duration - 10);
  });
};

var script$6 = {
  name: 'ListColumns',
  components: {
    ScrollbarVertical: __vue_component__$8
  },
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    date: Date,
    scrollDuration: {
      type: Number,
      default: 100
    },
    getClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    },
    hourOptions: Array,
    minuteOptions: Array,
    secondOptions: Array,
    showHour: {
      type: Boolean,
      default: true
    },
    showMinute: {
      type: Boolean,
      default: true
    },
    showSecond: {
      type: Boolean,
      default: true
    },
    hourStep: {
      type: Number,
      default: 1
    },
    minuteStep: {
      type: Number,
      default: 1
    },
    secondStep: {
      type: Number,
      default: 1
    },
    use12h: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    columns: function columns() {
      var cols = [];
      if (this.showHour) cols.push({
        type: 'hour',
        list: this.getHoursList()
      });
      if (this.showMinute) cols.push({
        type: 'minute',
        list: this.getMinutesList()
      });
      if (this.showSecond) cols.push({
        type: 'second',
        list: this.getSecondsList()
      });
      if (this.use12h) cols.push({
        type: 'ampm',
        list: this.getAMPMList()
      });
      return cols.filter(function (v) {
        return v.list.length > 0;
      });
    }
  },
  watch: {
    date: {
      handler: function handler() {
        var _this = this;

        this.$nextTick(function () {
          _this.scrollToSelected(_this.scrollDuration);
        });
      }
    }
  },
  mounted: function mounted() {
    this.scrollToSelected(0);
  },
  methods: {
    getHoursList: function getHoursList() {
      var _this2 = this;

      return generateOptions(this.use12h ? 12 : 24, this.hourStep, this.hourOptions).map(function (num) {
        var date = new Date(_this2.date);
        var text = padNumber(num);

        if (_this2.use12h) {
          if (num === 0) {
            text = '12';
          }

          if (date.getHours() >= 12) {
            num += 12;
          }
        }

        var value = date.setHours(num);
        return {
          value: value,
          text: text
        };
      });
    },
    getMinutesList: function getMinutesList() {
      var _this3 = this;

      return generateOptions(60, this.minuteStep, this.minuteOptions).map(function (num) {
        var value = new Date(_this3.date).setMinutes(num);
        return {
          value: value,
          text: padNumber(num)
        };
      });
    },
    getSecondsList: function getSecondsList() {
      var _this4 = this;

      return generateOptions(60, this.secondStep, this.secondOptions).map(function (num) {
        var value = new Date(_this4.date).setSeconds(num);
        return {
          value: value,
          text: padNumber(num)
        };
      });
    },
    getAMPMList: function getAMPMList() {
      var _this5 = this;

      return ['AM', 'PM'].map(function (text, i) {
        var date = new Date(_this5.date);
        var value = date.setHours(date.getHours() % 12 + i * 12);
        return {
          text: text,
          value: value
        };
      });
    },
    scrollToSelected: function scrollToSelected(duration) {
      var elements = this.$el.querySelectorAll('.active');

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var scrollElement = getScrollParent(element, this.$el);

        if (scrollElement) {
          var to = element.offsetTop;
          scrollTo(scrollElement, to, duration);
        }
      }
    },
    handleSelect: function handleSelect(evt) {
      var target = evt.target,
          currentTarget = evt.currentTarget;
      if (target.tagName.toUpperCase() !== 'LI') return;
      var type = currentTarget.getAttribute('data-type');
      var colIndex = parseInt(currentTarget.getAttribute('data-index'), 10);
      var cellIndex = parseInt(target.getAttribute('data-index'), 10);
      var value = this.columns[colIndex].list[cellIndex].value;
      this.$emit('select', value, type);
    }
  }
};

/* script */
var __vue_script__$6 = script$6;
/* template */

var __vue_render__$9 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-time-columns"
  }, _vm._l(_vm.columns, function (col, i) {
    return _c('scrollbar-vertical', {
      key: i,
      class: _vm.prefixClass + "-time-column"
    }, [_c('ul', {
      class: _vm.prefixClass + "-time-list",
      attrs: {
        "data-type": col.type,
        "data-index": i
      },
      on: {
        "click": _vm.handleSelect
      }
    }, _vm._l(col.list, function (item, j) {
      return _c('li', {
        key: item.value,
        class: [_vm.prefixClass + "-time-item", _vm.getClasses(item.value, col.type)],
        attrs: {
          "data-index": j
        }
      }, [_vm._v("\n        " + _vm._s(item.text) + "\n      ")]);
    }), 0)]);
  }), 1);
};

var __vue_staticRenderFns__$9 = [];
/* style */

var __vue_inject_styles__$9 = undefined;
/* scoped */

var __vue_scope_id__$9 = undefined;
/* module identifier */

var __vue_module_identifier__$9 = undefined;
/* functional template */

var __vue_is_functional_template__$9 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$9 = normalizeComponent({
  render: __vue_render__$9,
  staticRenderFns: __vue_staticRenderFns__$9
}, __vue_inject_styles__$9, __vue_script__$6, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

//

function parseOption() {
  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var values = time.split(':');

  if (values.length >= 2) {
    var hours = parseInt(values[0], 10);
    var minutes = parseInt(values[1], 10);
    return {
      hours: hours,
      minutes: minutes
    };
  }

  return null;
}

var scrollTo$1 = function scrollTo(element, to) {
  if (element) {
    element.scrollTop = to;
  }
};

var script$7 = {
  name: 'ListOptions',
  components: {
    ScrollbarVertical: __vue_component__$8
  },
  inject: {
    getLocale: {
      default: function _default() {
        return getLocale;
      }
    },
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    date: Date,
    options: {
      type: [Object, Function],
      default: function _default() {
        return [];
      }
    },
    format: {
      type: String,
      default: 'HH:mm:ss'
    },
    getClasses: {
      type: Function,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    list: function list() {
      var result = [];
      var options = this.options;

      if (typeof options === 'function') {
        return options() || [];
      }

      var start = parseOption(options.start);
      var end = parseOption(options.end);
      var step = parseOption(options.step);
      var fmt = options.format || this.format;

      if (start && end && step) {
        var startMinutes = start.minutes + start.hours * 60;
        var endMinutes = end.minutes + end.hours * 60;
        var stepMinutes = step.minutes + step.hours * 60;
        var len = Math.floor((endMinutes - startMinutes) / stepMinutes);

        for (var i = 0; i <= len; i++) {
          var timeMinutes = startMinutes + i * stepMinutes;
          var hours = Math.floor(timeMinutes / 60);
          var minutes = timeMinutes % 60;
          var value = new Date(this.date).setHours(hours, minutes, 0);
          result.push({
            value: value,
            text: this.formatDate(value, fmt)
          });
        }
      }

      return result;
    }
  },
  mounted: function mounted() {
    this.scrollToSelected();
  },
  methods: {
    formatDate: function formatDate(date, fmt) {
      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.format)(date, fmt, {
        locale: this.getLocale().formatLocale
      });
    },
    scrollToSelected: function scrollToSelected() {
      var element = this.$el.querySelector('.active');
      if (!element) return;
      var scrollElement = getScrollParent(element, this.$el);
      if (!scrollElement) return;
      var to = element.offsetTop;
      scrollTo$1(scrollElement, to);
    },
    handleSelect: function handleSelect(value) {
      this.$emit('select', value, 'time');
    }
  }
};

/* script */
var __vue_script__$7 = script$7;
/* template */

var __vue_render__$a = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('scrollbar-vertical', _vm._l(_vm.list, function (item) {
    return _c('div', {
      key: item.value,
      class: [_vm.prefixClass + "-time-option", _vm.getClasses(item.value)],
      on: {
        "click": function click($event) {
          return _vm.handleSelect(item.value);
        }
      }
    }, [_vm._v("\n    " + _vm._s(item.text) + "\n  ")]);
  }), 0);
};

var __vue_staticRenderFns__$a = [];
/* style */

var __vue_inject_styles__$a = undefined;
/* scoped */

var __vue_scope_id__$a = undefined;
/* module identifier */

var __vue_module_identifier__$a = undefined;
/* functional template */

var __vue_is_functional_template__$a = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$a = normalizeComponent({
  render: __vue_render__$a,
  staticRenderFns: __vue_staticRenderFns__$a
}, __vue_inject_styles__$a, __vue_script__$7, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

//
var script$8 = {
  name: 'TimePanel',
  components: {
    ListColumns: __vue_component__$9,
    ListOptions: __vue_component__$a
  },
  inject: {
    getLocale: {
      default: function _default() {
        return getLocale;
      }
    },
    prefixClass: {
      default: 'mx'
    }
  },
  props: {
    value: {},
    defaultValue: {
      default: function _default() {
        var date = new Date();
        date.setHours(0, 0, 0, 0);
        return date;
      }
    },
    format: {
      default: 'HH:mm:ss'
    },
    timeTitleFormat: {
      type: String,
      default: 'YYYY-MM-DD'
    },
    showTimeHeader: {
      type: Boolean,
      default: false
    },
    disabledTime: {
      type: Function,
      default: function _default() {
        return false;
      }
    },
    timePickerOptions: {
      type: [Object, Function],
      default: function _default() {
        return null;
      }
    },
    hourOptions: Array,
    minuteOptions: Array,
    secondOptions: Array,
    hourStep: {
      type: Number,
      default: 1
    },
    minuteStep: {
      type: Number,
      default: 1
    },
    secondStep: {
      type: Number,
      default: 1
    },
    showHour: {
      type: Boolean,
      default: undefined
    },
    showMinute: {
      type: Boolean,
      default: undefined
    },
    showSecond: {
      type: Boolean,
      default: undefined
    },
    use12h: {
      type: Boolean,
      default: undefined
    },
    scrollDuration: {
      type: Number,
      default: 100
    }
  },
  data: function data() {
    return {
      innerValue: getValidDate(this.value, this.defaultValue)
    };
  },
  computed: {
    title: function title() {
      var titleFormat = this.timeTitleFormat;
      var date = new Date(this.innerValue);
      return this.formatDate(date, titleFormat);
    },
    innerForamt: function innerForamt() {
      return typeof this.format === 'string' ? this.format : 'HH:mm:ss';
    },
    ShowHourMinuteSecondAMPM: function ShowHourMinuteSecondAMPM() {
      var _this = this;

      var fmt = this.innerForamt;
      var defaultProps = {
        showHour: /[HhKk]/.test(fmt),
        showMinute: /m/.test(fmt),
        showSecond: /s/.test(fmt),
        use12h: /a/i.test(fmt)
      };
      var obj = {};
      Object.keys(defaultProps).forEach(function (key) {
        obj[key] = typeof _this[key] === 'boolean' ? _this[key] : defaultProps[key];
      });
      return obj;
    }
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler() {
        this.innerValue = getValidDate(this.value, this.defaultValue);
      }
    }
  },
  methods: {
    formatDate: function formatDate(date, fmt) {
      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.format)(date, fmt, {
        locale: this.getLocale().formatLocale
      });
    },
    isDisabledTime: function isDisabledTime(value) {
      return this.disabledTime(new Date(value));
    },
    isDisabledHour: function isDisabledHour(date) {
      var value = new Date(date);
      return this.isDisabledTime(value) && this.isDisabledTime(value.setMinutes(0, 0, 0)) && this.isDisabledTime(value.setMinutes(59, 59, 999));
    },
    isDisabledMinute: function isDisabledMinute(date) {
      var value = new Date(date);
      return this.isDisabledTime(value) && this.isDisabledTime(value.setSeconds(0, 0)) && this.isDisabledTime(value.setSeconds(59, 999));
    },
    isDisabledAMPM: function isDisabledAMPM(date) {
      var value = new Date(date);
      var minHour = value.getHours() < 12 ? 0 : 12;
      var maxHour = minHour + 11;
      return this.isDisabledTime(value) && this.isDisabledTime(value.setHours(minHour, 0, 0, 0)) && this.isDisabledTime(value.setHours(maxHour, 59, 59, 999));
    },
    isDisabled: function isDisabled(date, type) {
      if (type === 'hour') {
        return this.isDisabledHour(date);
      }

      if (type === 'minute') {
        return this.isDisabledMinute(date);
      }

      if (type === 'ampm') {
        return this.isDisabledAMPM(date);
      }

      return this.isDisabledTime(date);
    },
    handleSelect: function handleSelect(value, type) {
      var date = new Date(value);

      if (!this.isDisabled(value, type)) {
        this.innerValue = date;

        if (!this.isDisabledTime(date)) {
          this.$emit('select', date, type);
        }
      }
    },
    handleClickTitle: function handleClickTitle() {
      this.$emit('clicktitle');
    },
    getClasses: function getClasses(value, type) {
      var cellDate = new Date(value);

      if (this.isDisabled(value, type)) {
        return 'disabled';
      }

      if (cellDate.getTime() === this.innerValue.getTime()) {
        return 'active';
      }

      return '';
    }
  }
};

/* script */
var __vue_script__$8 = script$8;
/* template */

var __vue_render__$b = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.prefixClass + "-time"
  }, [_vm.showTimeHeader ? _c('div', {
    class: _vm.prefixClass + "-time-header"
  }, [_c('button', {
    class: _vm.prefixClass + "-btn " + _vm.prefixClass + "-btn-text " + _vm.prefixClass + "-time-header-title",
    attrs: {
      "type": "button"
    },
    on: {
      "click": _vm.handleClickTitle
    }
  }, [_vm._v("\n      " + _vm._s(_vm.title) + "\n    ")])]) : _vm._e(), _vm._v(" "), _c('div', {
    class: _vm.prefixClass + "-time-content"
  }, [_vm.timePickerOptions ? _c('list-options', {
    attrs: {
      "date": _vm.innerValue,
      "get-classes": _vm.getClasses,
      "options": _vm.timePickerOptions,
      "format": _vm.innerForamt
    },
    on: {
      "select": _vm.handleSelect
    }
  }) : _c('list-columns', _vm._b({
    attrs: {
      "date": _vm.innerValue,
      "get-classes": _vm.getClasses,
      "hour-options": _vm.hourOptions,
      "minute-options": _vm.minuteOptions,
      "second-options": _vm.secondOptions,
      "hour-step": _vm.hourStep,
      "minute-step": _vm.minuteStep,
      "second-step": _vm.secondStep,
      "scroll-duration": _vm.scrollDuration
    },
    on: {
      "select": _vm.handleSelect
    }
  }, 'list-columns', _vm.ShowHourMinuteSecondAMPM, false))], 1)]);
};

var __vue_staticRenderFns__$b = [];
/* style */

var __vue_inject_styles__$b = undefined;
/* scoped */

var __vue_scope_id__$b = undefined;
/* module identifier */

var __vue_module_identifier__$b = undefined;
/* functional template */

var __vue_is_functional_template__$b = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$b = normalizeComponent({
  render: __vue_render__$b,
  staticRenderFns: __vue_staticRenderFns__$b
}, __vue_inject_styles__$b, __vue_script__$8, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

var TimeRange = {
  name: 'TimeRange',
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  props: _objectSpread2({}, __vue_component__$b.props),
  data: function data() {
    return {
      startValue: new Date(NaN),
      endValue: new Date(NaN)
    };
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler() {
        if (isValidRangeDate(this.value)) {
          var _this$value = _slicedToArray(this.value, 2),
              startValue = _this$value[0],
              endValue = _this$value[1];

          this.startValue = startValue;
          this.endValue = endValue;
        } else {
          this.startValue = new Date(NaN);
          this.endValue = new Date(NaN);
        }
      }
    }
  },
  methods: {
    emitChange: function emitChange(type, index) {
      var date = [this.startValue, this.endValue];
      this.$emit('select', date, type === 'time' ? 'time-range' : type, index);
    },
    handleSelectStart: function handleSelectStart(date, type) {
      this.startValue = date; // check the NaN

      if (!(this.endValue.getTime() >= date.getTime())) {
        this.endValue = date;
      }

      this.emitChange(type, 0);
    },
    handleSelectEnd: function handleSelectEnd(date, type) {
      // check the NaN
      this.endValue = date;

      if (!(this.startValue.getTime() <= date.getTime())) {
        this.startValue = date;
      }

      this.emitChange(type, 1);
    },
    disabledStartTime: function disabledStartTime(date) {
      return this.disabledTime(date, 0);
    },
    disabledEndTime: function disabledEndTime(date) {
      return date.getTime() < this.startValue.getTime() || this.disabledTime(date, 1);
    }
  },
  render: function render() {
    var h = arguments[0];
    var defaultValues = Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue, this.defaultValue];
    var prefixClass = this.prefixClass;
    return h("div", {
      "class": "".concat(prefixClass, "-range-wrapper")
    }, [h(__vue_component__$b, {
      "props": _objectSpread2({}, _objectSpread2({}, this.$props, {
        value: this.startValue,
        defaultValue: defaultValues[0],
        disabledTime: this.disabledStartTime
      })),
      "on": _objectSpread2({}, _objectSpread2({}, this.$listeners, {
        select: this.handleSelectStart
      }))
    }), h(__vue_component__$b, {
      "props": _objectSpread2({}, _objectSpread2({}, this.$props, {
        value: this.endValue,
        defaultValue: defaultValues[1],
        disabledTime: this.disabledEndTime
      })),
      "on": _objectSpread2({}, _objectSpread2({}, this.$listeners, {
        select: this.handleSelectEnd
      }))
    })]);
  }
};

var DatetimePanel = {
  name: 'DatetimePanel',
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  emits: ['select', 'update:show-time-panel'],
  props: _objectSpread2({}, CalendarPanel.props, {}, __vue_component__$b.props, {
    showTimePanel: {
      type: Boolean,
      default: undefined
    }
  }),
  data: function data() {
    return {
      defaultTimeVisible: false,
      currentValue: this.value
    };
  },
  computed: {
    timeVisible: function timeVisible() {
      return typeof this.showTimePanel === 'boolean' ? this.showTimePanel : this.defaultTimeVisible;
    }
  },
  watch: {
    value: function value(val) {
      this.currentValue = val;
    }
  },
  methods: {
    closeTimePanel: function closeTimePanel() {
      this.defaultTimeVisible = false;
      this.$emit('update:show-time-panel', false);
    },
    openTimePanel: function openTimePanel() {
      this.defaultTimeVisible = true;
      this.$emit('update:show-time-panel', true);
    },
    emitDate: function emitDate(date, type) {
      this.$emit('select', date, type);
    },
    handleSelect: function handleSelect(date, type) {
      if (type === 'date') {
        this.openTimePanel();
      }

      var datetime = assignTime(date, getValidDate(this.value, this.defaultValue));

      if (this.disabledTime(new Date(datetime))) {
        // set the time of defalutValue;
        datetime = assignTime(date, this.defaultValue);

        if (this.disabledTime(new Date(datetime))) {
          // if disabled don't emit date
          this.currentValue = datetime;
          return;
        }
      }

      this.emitDate(datetime, type);
    }
  },
  render: function render() {
    var h = arguments[0];
    var calendarProps = {
      props: _objectSpread2({}, pick(this.$props, Object.keys(CalendarPanel.props)), {
        type: 'date',
        value: this.currentValue
      }),
      on: {
        select: this.handleSelect
      }
    };
    var timeProps = {
      props: _objectSpread2({}, pick(this.$props, Object.keys(__vue_component__$b.props)), {
        showTimeHeader: true,
        value: this.currentValue
      }),
      on: {
        select: this.emitDate,
        clicktitle: this.closeTimePanel
      }
    };
    var prefixClass = this.prefixClass;
    return h("div", [h(CalendarPanel, helper([{}, calendarProps])), this.timeVisible && h(__vue_component__$b, helper([{
      "class": "".concat(prefixClass, "-calendar-time")
    }, timeProps]))]);
  }
};

var DatetimeRange = {
  name: 'DatetimeRange',
  inject: {
    prefixClass: {
      default: 'mx'
    }
  },
  emits: ['select', 'update:show-time-panel'],
  props: _objectSpread2({}, CalendarRange.props, {}, TimeRange.props, {
    showTimePanel: {
      type: Boolean,
      default: undefined
    }
  }),
  data: function data() {
    return {
      defaultTimeVisible: false,
      currentValue: this.value
    };
  },
  computed: {
    timeVisible: function timeVisible() {
      return typeof this.showTimePanel === 'boolean' ? this.showTimePanel : this.defaultTimeVisible;
    }
  },
  watch: {
    value: function value(val) {
      this.currentValue = val;
    }
  },
  methods: {
    closeTimePanel: function closeTimePanel() {
      this.defaultTimeVisible = false;
      this.$emit('update:show-time-panel', false);
    },
    openTimePanel: function openTimePanel() {
      this.defaultTimeVisible = true;
      this.$emit('update:show-time-panel', true);
    },
    emitDate: function emitDate(dates, type) {
      this.$emit('select', dates, type);
    },
    handleSelect: function handleSelect(dates, type) {
      var _this = this;

      if (type === 'date') {
        this.openTimePanel();
      }

      var defaultValues = Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue, this.defaultValue];
      var datetimes = dates.map(function (date, i) {
        var time = isValidRangeDate(_this.value) ? _this.value[i] : defaultValues[i];
        return assignTime(date, time);
      });

      if (datetimes[1].getTime() < datetimes[0].getTime()) {
        datetimes = [datetimes[0], datetimes[0]];
      }

      if (datetimes.some(this.disabledTime)) {
        datetimes = dates.map(function (date, i) {
          return assignTime(date, defaultValues[i]);
        });

        if (datetimes.some(this.disabledTime)) {
          this.currentValue = datetimes;
          return;
        }
      }

      this.emitDate(datetimes, type);
    }
  },
  render: function render() {
    var h = arguments[0];
    var calendarProps = {
      props: _objectSpread2({}, pick(this.$props, Object.keys(CalendarRange.props)), {
        type: 'date',
        value: this.currentValue
      }),
      on: {
        select: this.handleSelect
      }
    };
    var timeProps = {
      props: _objectSpread2({}, pick(this.$props, Object.keys(TimeRange.props)), {
        value: this.currentValue,
        showTimeHeader: true
      }),
      on: {
        select: this.emitDate,
        clicktitle: this.closeTimePanel
      }
    };
    var prefixClass = this.prefixClass;
    return h("div", [h(CalendarRange, helper([{}, calendarProps])), this.timeVisible && h(TimeRange, helper([{
      "class": "".concat(prefixClass, "-calendar-time")
    }, timeProps]))]);
  }
};

var componentMap = {
  default: CalendarPanel,
  time: __vue_component__$b,
  datetime: DatetimePanel
};
var componentRangeMap = {
  default: CalendarRange,
  time: TimeRange,
  datetime: DatetimeRange
};
var DatePicker = {
  name: 'DatePicker',
  provide: function provide() {
    var _this = this;

    return {
      // make locale reactive
      getLocale: function getLocale() {
        return _this.locale;
      },
      getWeek: this.getWeek,
      prefixClass: this.prefixClass,
      dispatchDatePicker: this.$emit.bind(this)
    };
  },
  props: _objectSpread2({}, DatetimePanel.props, {
    value: {},
    valueType: {
      type: String,
      default: 'date' // date, format, timestamp, or token like 'YYYY-MM-DD'

    },
    type: {
      type: String,
      // ['date', 'datetime', 'time', 'year', 'month', 'week']
      default: 'date'
    },
    format: {
      type: String
    },
    formatter: {
      type: Object
    },
    range: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    rangeSeparator: {
      type: String
    },
    lang: {
      type: [String, Object]
    },
    placeholder: {
      type: String,
      default: ''
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: true
    },
    prefixClass: {
      type: String,
      default: 'mx'
    },
    inputClass: {},
    inputAttr: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    open: {
      type: Boolean,
      default: undefined
    },
    popupClass: {},
    popupStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    inline: {
      type: Boolean,
      default: false
    },
    confirm: {
      type: Boolean,
      default: false
    },
    confirmText: {
      type: String,
      default: 'OK'
    },
    renderInputText: {
      type: Function
    },
    shortcuts: {
      type: Array,
      validator: function validator(value) {
        return Array.isArray(value) && value.every(function (v) {
          return isObject(v) && typeof v.text === 'string' && typeof v.onClick === 'function';
        });
      },
      default: function _default() {
        return [];
      }
    }
  }),
  data: function data() {
    return {
      // cache the innervalue, wait to confirm
      currentValue: null,
      userInput: null,
      defaultOpen: false,
      mouseInInput: false
    };
  },
  computed: {
    popupVisible: function popupVisible() {
      return !this.disabled && (typeof this.open === 'boolean' ? this.open : this.defaultOpen);
    },
    innerRangeSeparator: function innerRangeSeparator() {
      return this.rangeSeparator || (this.multiple ? ',' : ' ~ ');
    },
    innerFormat: function innerFormat() {
      var map = {
        date: 'YYYY-MM-DD',
        datetime: 'YYYY-MM-DD HH:mm:ss',
        year: 'YYYY',
        month: 'YYYY-MM',
        time: 'HH:mm:ss',
        week: 'w'
      };
      return this.format || map[this.type] || map.date;
    },
    innerValue: function innerValue() {
      var value = this.value;

      if (this.validMultipleType) {
        value = Array.isArray(value) ? value : [];
        return value.map(this.value2date);
      }

      if (this.range) {
        value = Array.isArray(value) ? value.slice(0, 2) : [null, null];
        return value.map(this.value2date);
      }

      return this.value2date(value);
    },
    text: function text() {
      var _this2 = this;

      if (this.userInput !== null) {
        return this.userInput;
      }

      if (typeof this.renderInputText === 'function') {
        return this.renderInputText(this.innerValue);
      }

      if (!this.isValidValue(this.innerValue)) {
        return '';
      }

      if (Array.isArray(this.innerValue)) {
        return this.innerValue.map(function (v) {
          return _this2.formatDate(v);
        }).join(this.innerRangeSeparator);
      }

      return this.formatDate(this.innerValue);
    },
    showClearIcon: function showClearIcon() {
      return !this.disabled && this.clearable && this.text && this.mouseInInput;
    },
    locale: function locale() {
      if (isObject(this.lang)) {
        return mergeDeep(getLocale(), this.lang);
      }

      return getLocale(this.lang);
    },
    validMultipleType: function validMultipleType() {
      var types = ['date', 'month', 'year'];
      return this.multiple && !this.range && types.indexOf(this.type) !== -1;
    }
  },
  watch: {
    innerValue: {
      immediate: true,
      handler: function handler(val) {
        this.currentValue = val;
      }
    },
    popupVisible: {
      handler: function handler(val) {
        if (val) {
          this.currentValue = this.innerValue;
        }
      }
    }
  },
  created: function created() {
    if (_typeof(this.format) === 'object') {
      console.warn("[vue2-datepicker]: The prop `format` don't support Object any more. You can use the new prop `formatter` to replace it");
    }
  },
  methods: {
    handleMouseEnter: function handleMouseEnter() {
      this.mouseInInput = true;
    },
    handleMouseLeave: function handleMouseLeave() {
      this.mouseInInput = false;
    },
    handleClickOutSide: function handleClickOutSide(evt) {
      var target = evt.target;

      if (!this.$el.contains(target)) {
        this.closePopup();
      }
    },
    getFormatter: function getFormatter(key) {
      return isObject(this.formatter) && this.formatter[key] || isObject(this.format) && this.format[key];
    },
    getWeek: function getWeek$1(date, options) {
      if (typeof this.getFormatter('getWeek') === 'function') {
        return this.getFormatter('getWeek')(date, options);
      }

      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.getWeek)(date, options);
    },
    parseDate: function parseDate(value, fmt) {
      fmt = fmt || this.innerFormat;

      if (typeof this.getFormatter('parse') === 'function') {
        return this.getFormatter('parse')(value, fmt);
      }

      var backupDate = new Date();
      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.parse)(value, fmt, {
        locale: this.locale.formatLocale,
        backupDate: backupDate
      });
    },
    formatDate: function formatDate(date, fmt) {
      fmt = fmt || this.innerFormat;

      if (typeof this.getFormatter('stringify') === 'function') {
        return this.getFormatter('stringify')(date, fmt);
      }

      return (0,date_format_parse__WEBPACK_IMPORTED_MODULE_0__.format)(date, fmt, {
        locale: this.locale.formatLocale
      });
    },
    // transform the outer value to inner date
    value2date: function value2date(value) {
      switch (this.valueType) {
        case 'date':
          return value instanceof Date ? new Date(value.getTime()) : new Date(NaN);

        case 'timestamp':
          return typeof value === 'number' ? new Date(value) : new Date(NaN);

        case 'format':
          return typeof value === 'string' ? this.parseDate(value) : new Date(NaN);

        default:
          return typeof value === 'string' ? this.parseDate(value, this.valueType) : new Date(NaN);
      }
    },
    // transform the inner date to outer value
    date2value: function date2value(date) {
      if (!isValidDate(date)) return null;

      switch (this.valueType) {
        case 'date':
          return date;

        case 'timestamp':
          return date.getTime();

        case 'format':
          return this.formatDate(date);

        default:
          return this.formatDate(date, this.valueType);
      }
    },
    emitValue: function emitValue(date, type) {
      var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // fix IE11/10 trigger input event when input is focused. (placeholder !== '')
      this.userInput = null;
      var value = Array.isArray(date) ? date.map(this.date2value) : this.date2value(date);
      this.$emit('input', value);
      this.$emit('change', value, type);

      if (close) {
        this.closePopup();
      }

      return value;
    },
    isValidValue: function isValidValue(value) {
      if (this.validMultipleType) {
        return isValidDates(value);
      }

      if (this.range) {
        return isValidRangeDate(value);
      }

      return isValidDate(value);
    },
    isValidValueAndNotDisabled: function isValidValueAndNotDisabled(value) {
      if (!this.isValidValue(value)) {
        return false;
      }

      var disabledDate = typeof this.disabledDate === 'function' ? this.disabledDate : function () {
        return false;
      };
      var disabledTime = typeof this.disabledTime === 'function' ? this.disabledTime : function () {
        return false;
      };

      if (!Array.isArray(value)) {
        value = [value];
      }

      return value.every(function (v) {
        return !disabledDate(v) && !disabledTime(v);
      });
    },
    handleMultipleDates: function handleMultipleDates(date, dates) {
      if (this.validMultipleType && dates) {
        var nextDates = dates.filter(function (v) {
          return v.getTime() !== date.getTime();
        });

        if (nextDates.length === dates.length) {
          nextDates.push(date);
        }

        return nextDates;
      }

      return date;
    },
    handleSelectDate: function handleSelectDate(val, type, dates) {
      val = this.handleMultipleDates(val, dates);

      if (this.confirm) {
        this.currentValue = val;
      } else {
        this.emitValue(val, type, // this.type === 'datetime', click the time should close popup
        !this.validMultipleType && (type === this.type || type === 'time'));
      }
    },
    clear: function clear() {
      this.emitValue(this.range ? [null, null] : null);
      this.$emit('clear');
    },
    handleClear: function handleClear(evt) {
      evt.stopPropagation();
      this.clear();
    },
    handleConfirmDate: function handleConfirmDate() {
      var value = this.emitValue(this.currentValue);
      this.$emit('confirm', value);
    },
    handleSelectShortcut: function handleSelectShortcut(evt) {
      var index = evt.currentTarget.getAttribute('data-index');
      var item = this.shortcuts[parseInt(index, 10)];

      if (isObject(item) && typeof item.onClick === 'function') {
        var date = item.onClick(this);

        if (date) {
          this.emitValue(date);
        }
      }
    },
    openPopup: function openPopup(evt) {
      if (this.popupVisible || this.disabled) return;
      this.defaultOpen = true;
      this.$emit('open', evt);
      this.$emit('update:open', true);
    },
    closePopup: function closePopup() {
      if (!this.popupVisible) return;
      this.defaultOpen = false;
      this.$emit('close');
      this.$emit('update:open', false);
    },
    blur: function blur() {
      // when use slot input
      if (this.$refs.input) {
        this.$refs.input.blur();
      }
    },
    focus: function focus() {
      if (this.$refs.input) {
        this.$refs.input.focus();
      }
    },
    handleInputChange: function handleInputChange() {
      var _this3 = this;

      if (!this.editable || this.userInput === null) return;
      var text = this.userInput.trim();
      this.userInput = null;

      if (text === '') {
        this.clear();
        return;
      }

      var date;

      if (this.validMultipleType) {
        date = text.split(this.innerRangeSeparator).map(function (v) {
          return _this3.parseDate(v.trim());
        });
      } else if (this.range) {
        var arr = text.split(this.innerRangeSeparator);

        if (arr.length !== 2) {
          // Maybe the separator during the day is the same as the separator for the date
          // eg: 2019-10-09-2020-01-02
          arr = text.split(this.innerRangeSeparator.trim());
        }

        date = arr.map(function (v) {
          return _this3.parseDate(v.trim());
        });
      } else {
        date = this.parseDate(text);
      }

      if (this.isValidValueAndNotDisabled(date)) {
        this.emitValue(date);
        this.blur();
      } else {
        this.$emit('input-error', text);
      }
    },
    handleInputInput: function handleInputInput(evt) {
      // slot input v-model
      this.userInput = typeof evt === 'string' ? evt : evt.target.value;
    },
    handleInputKeydown: function handleInputKeydown(evt) {
      var keyCode = evt.keyCode; // Tab 9 or Enter 13

      if (keyCode === 9) {
        this.closePopup();
      } else if (keyCode === 13) {
        this.handleInputChange();
      }
    },
    handleInputBlur: function handleInputBlur(evt) {
      // tab close
      this.$emit('blur', evt);
    },
    handleInputFocus: function handleInputFocus(evt) {
      this.openPopup(evt);
      this.$emit('focus', evt);
    },
    hasSlot: function hasSlot(name) {
      return !!(this.$slots[name] || this.$scopedSlots[name]);
    },
    renderSlot: function renderSlot(name, fallback, props) {
      var slotFn = this.$scopedSlots[name];

      if (slotFn) {
        return slotFn(props) || fallback;
      }

      return this.$slots[name] || fallback;
    },
    renderInput: function renderInput() {
      var h = this.$createElement;
      var prefixClass = this.prefixClass;

      var props = _objectSpread2({
        name: 'date',
        type: 'text',
        autocomplete: 'off',
        value: this.text,
        class: this.inputClass || "".concat(this.prefixClass, "-input"),
        readonly: !this.editable,
        disabled: this.disabled,
        placeholder: this.placeholder
      }, this.inputAttr);

      var value = props.value,
          className = props.class,
          attrs = _objectWithoutProperties(props, ["value", "class"]);

      var events = {
        keydown: this.handleInputKeydown,
        focus: this.handleInputFocus,
        blur: this.handleInputBlur,
        input: this.handleInputInput,
        change: this.handleInputChange
      };
      var input = this.renderSlot('input', h("input", {
        "domProps": {
          "value": value
        },
        "class": className,
        "attrs": _objectSpread2({}, attrs),
        "on": _objectSpread2({}, events),
        "ref": "input"
      }), {
        props: props,
        events: events
      });
      var calendarIcon = this.type === 'time' ? h(__vue_component__$2) : h(__vue_component__$1); // remove touchstart event to avoid opens the popup while scrolling in mobile #469

      return h("div", {
        "class": "".concat(prefixClass, "-input-wrapper"),
        "on": {
          "mouseenter": this.handleMouseEnter,
          "mouseleave": this.handleMouseLeave,
          "click": this.openPopup
        },
        "ref": "inputWrapper"
      }, [input, this.showClearIcon ? h("i", {
        "class": "".concat(prefixClass, "-icon-clear"),
        "on": {
          "click": this.handleClear
        }
      }, [this.renderSlot('icon-clear', h(__vue_component__$3))]) : h("i", {
        "class": "".concat(prefixClass, "-icon-calendar")
      }, [this.renderSlot('icon-calendar', calendarIcon)])]);
    },
    renderContent: function renderContent() {
      var h = this.$createElement;
      var map = this.range ? componentRangeMap : componentMap;
      var Component = map[this.type] || map.default;

      var props = _objectSpread2({}, pick(this.$props, Object.keys(Component.props)), {
        value: this.currentValue
      });

      var on = _objectSpread2({}, pick(this.$listeners, Component.emits || []), {
        select: this.handleSelectDate
      });

      var content = h(Component, helper([{}, {
        props: props,
        on: on,
        ref: 'picker'
      }]));
      return h("div", {
        "class": "".concat(this.prefixClass, "-datepicker-body")
      }, [this.renderSlot('content', content, {
        value: this.currentValue,
        emit: this.handleSelectDate
      })]);
    },
    renderSidebar: function renderSidebar() {
      var _this4 = this;

      var h = this.$createElement;
      var prefixClass = this.prefixClass;
      return h("div", {
        "class": "".concat(prefixClass, "-datepicker-sidebar")
      }, [this.renderSlot('sidebar', null, {
        value: this.currentValue,
        emit: this.handleSelectDate
      }), this.shortcuts.map(function (v, i) {
        return h("button", {
          "key": i,
          "attrs": {
            "data-index": i,
            "type": "button"
          },
          "class": "".concat(prefixClass, "-btn ").concat(prefixClass, "-btn-text ").concat(prefixClass, "-btn-shortcut"),
          "on": {
            "click": _this4.handleSelectShortcut
          }
        }, [v.text]);
      })]);
    },
    renderHeader: function renderHeader() {
      var h = this.$createElement;
      return h("div", {
        "class": "".concat(this.prefixClass, "-datepicker-header")
      }, [this.renderSlot('header', null, {
        value: this.currentValue,
        emit: this.handleSelectDate
      })]);
    },
    renderFooter: function renderFooter() {
      var h = this.$createElement;
      var prefixClass = this.prefixClass;
      return h("div", {
        "class": "".concat(prefixClass, "-datepicker-footer")
      }, [this.renderSlot('footer', null, {
        value: this.currentValue,
        emit: this.handleSelectDate
      }), this.confirm ? h("button", {
        "attrs": {
          "type": "button"
        },
        "class": "".concat(prefixClass, "-btn ").concat(prefixClass, "-datepicker-btn-confirm"),
        "on": {
          "click": this.handleConfirmDate
        }
      }, [this.confirmText]) : null]);
    }
  },
  render: function render() {
    var _class;

    var h = arguments[0];
    var prefixClass = this.prefixClass,
        inline = this.inline,
        disabled = this.disabled;
    var sidedar = this.hasSlot('sidebar') || this.shortcuts.length ? this.renderSidebar() : null;
    var content = h("div", {
      "class": "".concat(prefixClass, "-datepicker-content")
    }, [this.hasSlot('header') ? this.renderHeader() : null, this.renderContent(), this.hasSlot('footer') || this.confirm ? this.renderFooter() : null]);
    return h("div", {
      "class": (_class = {}, _defineProperty(_class, "".concat(prefixClass, "-datepicker"), true), _defineProperty(_class, "".concat(prefixClass, "-datepicker-range"), this.range), _defineProperty(_class, "".concat(prefixClass, "-datepicker-inline"), inline), _defineProperty(_class, "disabled", disabled), _class)
    }, [!inline ? this.renderInput() : null, !inline ? h(__vue_component__, {
      "ref": "popup",
      "class": this.popupClass,
      "style": this.popupStyle,
      "attrs": {
        "visible": this.popupVisible,
        "appendToBody": this.appendToBody
      },
      "on": {
        "clickoutside": this.handleClickOutSide
      }
    }, [sidedar, content]) : h("div", {
      "class": "".concat(prefixClass, "-datepicker-main")
    }, [sidedar, content])]);
  }
};

DatePicker.locale = locale;

DatePicker.install = function install(Vue) {
  Vue.component(DatePicker.name, DatePicker);
};

if (typeof window !== 'undefined' && window.Vue) {
  DatePicker.install(window.Vue);
}

_extends(DatePicker, {
  CalendarPanel: CalendarPanel,
  CalendarRange: CalendarRange,
  TimePanel: __vue_component__$b,
  TimeRange: TimeRange,
  DatetimePanel: DatetimePanel,
  DatetimeRange: DatetimeRange
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DatePicker);


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_nextcloud_calendar-js_dist_index_esm_js-node_modules_vue-material-design-cff017-vendors-node_modules_nextcloud_calendar-js_dist_index_esm_js-node_modules_vue-material-design-cff017.js.map?v=319d0b0bd12a6d8183b8